# 1. RAII
## 用在什么地方了？
加锁TODO:





&emsp;
&emsp; 
# 2. local copy






&emsp;
&emsp; 
# 3.  对象池、弱回调
TODO: 后面自己实现一遍





&emsp;
&emsp; 
# 4. 分布式系统中，一般推荐用什么 进程通信 方法? 为什么？
## 4.1  用什么？
用 消息传递(message passing)。

## 4.2  为什么？
&emsp;&emsp; 共享内存只能用于同一个机器上的进程间通信，而消息传递不但可以用于同一机器中的进程间通信，还可以用于不同机器间的通信。在单机上， 我们也可以照搬message passing作为多个进程的并发模型。 这样整个分布式系统的架构的一致性很强， 扩容（scale out） 起来也较容易。





&emsp;
&emsp; 
# 5. muduo库中为什么不推荐使用 递归mutex?
## 5.1 因为 非递归mutex性能好？
&emsp;&emsp; 不是为了性能，而是为了体现设计意图。non-recursive和recursive的性能差别其实不大， 因为少用一个计数器，前者略快一点点而已。

## 5.2 那是为什么呢？
&emsp;&emsp; 毫无疑问recursive mutex使用起来要方便一些， 因为不用考虑一个线程会自己把自己给锁死了， 我猜这也是Java和Windows默认提供recursive mutex的原因。 
&emsp;&emsp; 正因为它方便，recursive mutex可能会隐藏代码里的一些问题。典型情况是你以为拿到一个锁就能修改对象了，没想到外层代码已经拿到了锁，正在修改（或读取） 同一个对象呢。 来看一个具体的例子：
```cpp
class Foo{
public:
    void doit() const;
};

MutexLock mutex;
std::vector<Foo> foos;

void post(const Foo& f){
    MutexLockGuard lock(mutex);
    foos.push_back(f); // 
}

void traverse()
{
    MutexLockGuard lock(mutex);
    for (std::vector<Foo>::const_iterator it = foos.begin(); it != foos.end(); ++it){
        it->doit();
    }
}

void Foo::doit() const{
    Foo f;
    post(f);
}

int main()
{
    Foo f;
    post(f);
    traverse();
}
```
`post()`加锁， 然后修改`foos`对象； `traverse()`加锁， 然后遍历`foos`向量。 这些都是正确的。
将来有一天， `Foo::doit()`间接调用了`post()`， 那么会很有戏剧性的结果：
> (1) mutex是非递归的， 于是死锁了。
> (2) mutex是递归的， 由于`push_back()`可能（但不总是）导致`vector迭代器`失效（`push_back()`导致内存重新分配后，迭代器会失效），程序偶尔会crash。
> 
这时候就能体现non-recursive的优越性：把程序的逻辑错误暴露出来。死锁比较容易debug，把各个线程的调用栈打出来，只要每个函数不是特别长，很容易看出来是怎么死的， 见§2.1.2的例子 9。或者可以用`PTHREAD_MUTEX_ERRORCHECK`一下子就能找到错误（前提是MutexLock带debug选项）。程序反正要死，不如死得有意义一点，留个“全尸”，让验尸（post-mortem）更容易些。
&emsp;&emsp; **换句话来说就是：使用非递归mutex可以尽早的将问题暴露出来，这样不容易在生产环境出问题。**





&emsp;
&emsp; 
# 6. 死锁
TODO: 只是自己实现了一下第一个程序，后面的调试涉及到`gdb`，后面学了之后再回来！
```cpp
pthread_mutex_t mtx;
pthread_mutexattr_t mtxAttr;

class Request{
public:
    void process(){
        int ret = pthread_mutex_lock(&mtx);
        print();
        cout << "process() : " << ret << endl;
        ret = pthread_mutex_unlock(&mtx);
    }

    void print(){
        int ret = pthread_mutex_lock(&mtx);
        ret = pthread_mutex_unlock(&mtx);
        cout << "The end of print() :" << ret << endl;
    }
};


int main()
{
    int s = pthread_mutexattr_init(&mtxAttr);
    // 不依赖默认属性，直接指定mutex类型为 PTHREAD_MUTEX_NORMAL
    s = pthread_mutexattr_settype(&mtxAttr, PTHREAD_MUTEX_NORMAL);
    s = pthread_mutex_init(&mtx, &mtxAttr);
    Request obj;
    obj.process();
}
```

## 6.2 自己写的时候犯的错误
(1) 编译的时候忘记加 `-pthread`选项
正确的应该是：
```shell
g++ -o test.o test.cpp --std=c++11 -pthread
```





&emsp;
&emsp; 
# 7 条件变量
## 7.1 使用建议
**对于wait端：**
> (1) 必须与mutex一起使用， 该布尔表达式的读写需受此mutex保护。
> (2) 在mutex已上锁的时候才能调用wait()。
> (3) 把判断布尔条件和wait()放到while循环中。
>
对于signal/broadcast端：
> (1) 不一定要在mutex已上锁的情况下调用signal（理论上） 。
> (2) 在signal之前一般要修改布尔表达式。
> (3) 修改布尔表达式通常要用mutex保护（至少用作full memory barrier） 。
> (4) 注意区分signal与broadcast：“broadcast通常用于表明状态变化， signal通常用于表示资源可用。
> 

## 7.2 如何确定，`pthread_cond_signal()`和 `pthread_cond_broadcast()`应该使用哪个？
(1) 下面情况适合用`pthread_cond_broadcast`：
> 一个生产者多消费者，生产者能一次产生多个产品的情况。
> 多生产者多消费者
> 读写锁实现（写入之后，通知所有读者）
> 
(2) 下面情况适合`pthread_cond_signal`的情况
> 单一生产者，生产者一次生产一个产品的情况，最好一个消费者
> 
**在muduo库2.2小节中，有这样一段话：**
> 注意区分signal与broadcast： “broadcast通常用于表明状态变化， signal通常用于表示资源可用。（broadcast should generally be used to indicate state change rather than resource availability。 ）
> 
对于这段话其实可以这么理解：
> 资源被释放时，一般只能同时供一个线程使用，因此用signal通知一个线程即
>






&emsp;
&emsp; 
# 8. 不要用 读写锁 和 信号量
## 8.1 为什么不要用 读写锁？
&emsp;&emsp; 
**从正确性方面来说**，一种典型的易犯错误是在持有read lock的时候修改了共享数据。 这通常发生在程序的维护阶段， 为了新增功能， 程序员不小心在原来read lock保护的函数中调用了会修改状态的函数。 这种错误的后果跟无保护并发读写共享数据是一样的。
**从性能方面来说**，读写锁不见得比普通mutex更高效。 无论如何reader lock加锁的开销不会比mutex lock小，因为它要更新当前reader的数目。如果临界区很小，锁竞争不激烈，那么mutex往往会更快。

## 8.2 为什么不要用 信号量？
&emsp;&emsp; 笔者说：我没有遇到过需要使用信号量的情况，无从谈及个人经验。我认为信号量不是必备的同步原语，因为条件变量配合互斥器可以完全替代其功能，而且更不易用错。除了[RWC]指出的“semaphore has no notion of ownership”之外，信号量的另一个问题在于它有自己的计数值，而通常我们自己的数据结构也有长度值，这就造成了同样的信息存了两份，需要时刻保持一致，这增加了程序员的负担和出错的可能。如果要控制并发度，可以考虑用`muduo::ThreadPool`。






&emsp;
&emsp; 
# 9 用RAII封装`mutex`类
有几点要注意：
(1) 不应该使用系统默认的互斥锁类型（即`PTHREAD_MUTEX_DEFAULT`），而应该用`mutexattr`来显示指定mutex的类型（这里是`PTHREAD_MUTEX_NORMAL`）。（在本文前面关于 [死锁]()的介绍中就是这么做的 ）






&emsp;
&emsp; 
# 9 封装`Condition`类
TODO: 代码分析

## 9.2 同时使用`mutex`和`condition`时需要注意什么？
&emsp;&emsp; 注意它们的声明顺序和初始化顺序， mutex_应先于condition_构造， 并作为后者的构造参数。
&emsp;&emsp; 因为成员变量在类中的声明次序 就是 其在初始化列表中的初始化顺序，与其在初始化列表中的先后次序无关。






&emsp;
&emsp; 
# 10. 线程安全的`Singleton`实现







&emsp;
&emsp; 
# 11. sleep(3) 不是同步原语
&emsp;&emsp; `sleep()/usleep()/nanosleep()`只能出现在测试代码中 比如写单元测试的时候；或者用于有意延长临界区，加速复现死锁的情况。







&emsp;
&emsp; 
# 12. 