# 1. RAII
## 用在什么地方了？
加锁TODO:


# local copy


# 对象池、弱回调
```cpp
class Stock : boost::noncopyable
{
    public:
    Stock(const string& name)
        : name_(name)
    {
        printf(" Stock[%p] %s\n", this, name_.c_str());
    }

    ~Stock()
    {
        printf("~Stock[%p] %s\n", this, name_.c_str());
    }

    const string& key() const { return name_; }

    private:
    string name_;
    };

namespace version1
{

// questionable code
class StockFactory : boost::noncopyable
{
public:
    boost::shared_ptr<Stock> get(const string& key)
    {
        muduo::MutexLockGuard lock(mutex_);
        boost::shared_ptr<Stock>& pStock = stocks_[key];
        if (!pStock)
        {
            pStock.reset(new Stock(key));
        }
        return pStock;
    }
private:
    mutable muduo::MutexLock mutex_;
    std::map<string, boost::shared_ptr<Stock> > stocks_;
};

}

namespace version2
{

class StockFactory : boost::noncopyable
{
    public:
    boost::shared_ptr<Stock> get(const string& key)
    {
        boost::shared_ptr<Stock> pStock;
        muduo::MutexLockGuard lock(mutex_);
        boost::weak_ptr<Stock>& wkStock = stocks_[key];
        pStock = wkStock.lock();
        if (!pStock)
        {
            pStock.reset(new Stock(key));
            wkStock = pStock;
        }
        return pStock;
    }

    private:
    mutable muduo::MutexLock mutex_;
    std::map<string, boost::weak_ptr<Stock> > stocks_;
};

}

namespace version3
{

class StockFactory : boost::noncopyable
{
 public:

  boost::shared_ptr<Stock> get(const string& key)
  {
    boost::shared_ptr<Stock> pStock;
    muduo::MutexLockGuard lock(mutex_);
    boost::weak_ptr<Stock>& wkStock = stocks_[key];
    pStock = wkStock.lock();
    if (!pStock)
    {
      pStock.reset(new Stock(key),
                   boost::bind(&StockFactory::deleteStock, this, _1));
      wkStock = pStock;
    }
    return pStock;
  }

 private:

  void deleteStock(Stock* stock)
  {
    printf("deleteStock[%p]\n", stock);
    if (stock)
    {
      muduo::MutexLockGuard lock(mutex_);
      stocks_.erase(stock->key());  // This is wrong, see removeStock below for correct implementation.
    }
    delete stock;  // sorry, I lied
  }
  mutable muduo::MutexLock mutex_;
  std::map<string, boost::weak_ptr<Stock> > stocks_;
};

}

namespace version4
{

class StockFactory : public boost::enable_shared_from_this<StockFactory>,
                     boost::noncopyable
{
 public:

  boost::shared_ptr<Stock> get(const string& key)
  {
    boost::shared_ptr<Stock> pStock;
    muduo::MutexLockGuard lock(mutex_);
    boost::weak_ptr<Stock>& wkStock = stocks_[key];
    pStock = wkStock.lock();
    if (!pStock)
    {
      pStock.reset(new Stock(key),
                   boost::bind(&StockFactory::deleteStock,
                               shared_from_this(),
                               _1));
      wkStock = pStock;
    }
    return pStock;
  }

 private:

  void deleteStock(Stock* stock)
  {
    printf("deleteStock[%p]\n", stock);
    if (stock)
    {
      muduo::MutexLockGuard lock(mutex_);
      stocks_.erase(stock->key());  // This is wrong, see removeStock below for correct implementation.
    }
    delete stock;  // sorry, I lied
  }
  mutable muduo::MutexLock mutex_;
  std::map<string, boost::weak_ptr<Stock> > stocks_;
};

}

class StockFactory : public boost::enable_shared_from_this<StockFactory>,
                     boost::noncopyable
{
 public:
  boost::shared_ptr<Stock> get(const string& key)
  {
    boost::shared_ptr<Stock> pStock;
    muduo::MutexLockGuard lock(mutex_);
    boost::weak_ptr<Stock>& wkStock = stocks_[key];
    pStock = wkStock.lock();
    if (!pStock)
    {
      pStock.reset(new Stock(key),
                   boost::bind(&StockFactory::weakDeleteCallback,
                               boost::weak_ptr<StockFactory>(shared_from_this()),
                               _1));
      wkStock = pStock;
    }
    return pStock;
  }

 private:
  static void weakDeleteCallback(const boost::weak_ptr<StockFactory>& wkFactory,
                                 Stock* stock)
  {
    printf("weakDeleteStock[%p]\n", stock);
    boost::shared_ptr<StockFactory> factory(wkFactory.lock());
    if (factory)
    {
      factory->removeStock(stock);
    }
    else
    {
      printf("factory died.\n");
    }
    delete stock;  // sorry, I lied
  }

  void removeStock(Stock* stock)
  {
    if (stock)
    {
      muduo::MutexLockGuard lock(mutex_);
      auto it = stocks_.find(stock->key());
      if (it != stocks_.end() && it->second.expired())
      {
        stocks_.erase(stock->key());
      }
    }
  }

 private:
  mutable muduo::MutexLock mutex_;
  std::map<string, boost::weak_ptr<Stock> > stocks_;
};
```


# 分布式系统中，一般推荐用什么 进程通信 方法?为什么
# 用什么？
用 消息传递(message passing)。
# 为什么？
&emsp;&emsp; 共享内存只能用于同一个机器上的进程间通信，而消息传递不但可以用于同一机器中的进程间通信，还可以用于不同机器间的通信。在单机上， 我们也可以照搬message passing作为多个进程的并发模型。 这样整个分布式系统的架构的一致性很强， 扩容（scale out） 起来也较容易。



# muduo库中为什么不推荐使用 递归mutex?
