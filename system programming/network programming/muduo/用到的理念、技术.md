# 1. RAII
## 用在什么地方了？
加锁TODO:





&emsp;
&emsp; 
# 2. local copy






&emsp;
&emsp; 
# 3.  对象池、弱回调
TODO: 后面自己实现一遍





&emsp;
&emsp; 
# 4. 分布式系统中，一般推荐用什么 进程通信 方法? 为什么？
## 4.1  用什么？
用 消息传递(message passing)。

## 4.2  为什么？
&emsp;&emsp; 共享内存只能用于同一个机器上的进程间通信，而消息传递不但可以用于同一机器中的进程间通信，还可以用于不同机器间的通信。在单机上， 我们也可以照搬message passing作为多个进程的并发模型。 这样整个分布式系统的架构的一致性很强， 扩容（scale out） 起来也较容易。





&emsp;
&emsp; 
# 5. muduo库中为什么不推荐使用 递归mutex?
## 5.1 因为 非递归mutex性能好？
&emsp;&emsp; 不是为了性能，而是为了体现设计意图。non-recursive和recursive的性能差别其实不大， 因为少用一个计数器，前者略快一点点而已。

## 5.2 那是为什么呢？
&emsp;&emsp; 毫无疑问recursive mutex使用起来要方便一些， 因为不用考虑一个线程会自己把自己给锁死了， 我猜这也是Java和Windows默认提供recursive mutex的原因。 
&emsp;&emsp; 正因为它方便，recursive mutex可能会隐藏代码里的一些问题。典型情况是你以为拿到一个锁就能修改对象了，没想到外层代码已经拿到了锁，正在修改（或读取） 同一个对象呢。 来看一个具体的例子：
```cpp
class Foo{
public:
    void doit() const;
};

MutexLock mutex;
std::vector<Foo> foos;

void post(const Foo& f){
    MutexLockGuard lock(mutex);
    foos.push_back(f); // 
}

void traverse()
{
    MutexLockGuard lock(mutex);
    for (std::vector<Foo>::const_iterator it = foos.begin(); it != foos.end(); ++it){
        it->doit();
    }
}

void Foo::doit() const{
    Foo f;
    post(f);
}

int main()
{
    Foo f;
    post(f);
    traverse();
}
```
`post()`加锁， 然后修改`foos`对象； `traverse()`加锁， 然后遍历`foos`向量。 这些都是正确的。
将来有一天， `Foo::doit()`间接调用了`post()`， 那么会很有戏剧性的结果：
> (1) mutex是非递归的， 于是死锁了。
> (2) mutex是递归的， 由于`push_back()`可能（但不总是）导致`vector迭代器`失效（`push_back()`导致内存重新分配后，迭代器会失效），程序偶尔会crash。
> 
这时候就能体现non-recursive的优越性：把程序的逻辑错误暴露出来。死锁比较容易debug，把各个线程的调用栈打出来，只要每个函数不是特别长，很容易看出来是怎么死的， 见§2.1.2的例子 9。或者可以用`PTHREAD_MUTEX_ERRORCHECK`一下子就能找到错误（前提是MutexLock带debug选项）。程序反正要死，不如死得有意义一点，留个“全尸”，让验尸（post-mortem）更容易些。
&emsp;&emsp; **换句话来说就是：使用非递归mutex可以尽早的将问题暴露出来，这样不容易在生产环境出问题。**





&emsp;
&emsp; 
# 6. 死锁
TODO: 只是自己实现了一下第一个程序，后面的调试涉及到`gdb`，后面学了之后再回来！
```cpp
pthread_mutex_t mtx;
pthread_mutexattr_t mtxAttr;

class Request{
public:
    void process(){
        int ret = pthread_mutex_lock(&mtx);
        print();
        cout << "process() : " << ret << endl;
        ret = pthread_mutex_unlock(&mtx);
    }

    void print(){
        int ret = pthread_mutex_lock(&mtx);
        ret = pthread_mutex_unlock(&mtx);
        cout << "The end of print() :" << ret << endl;
    }
};


int main()
{
    int s = pthread_mutexattr_init(&mtxAttr);
    // 不依赖默认属性，直接指定mutex类型为 PTHREAD_MUTEX_NORMAL
    s = pthread_mutexattr_settype(&mtxAttr, PTHREAD_MUTEX_NORMAL);
    s = pthread_mutex_init(&mtx, &mtxAttr);
    Request obj;
    obj.process();
}
```

## 6.2 自己写的时候犯的错误
(1) 编译的时候忘记加 `-pthread`选项
正确的应该是：
```shell
g++ -o test.o test.cpp --std=c++11 -pthread
```