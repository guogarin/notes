# 1. 背景知识
## 1.1 何为IO？
**IO (Input/Output，输入/输出)** 即数据的读取（接收）或写入（发送）操作，通常用户进程中的一个完整IO分为两阶段：
> ① 用户进程空间 <——> 内核空间;
> ② 内核空间 <——> 设备空间（磁盘、网络等）
> 
<div align = "center"><img src = "./pic/IO model of Unix(Linux)/pic13.jpg"></div>

IO有内存IO、网络IO和磁盘IO三种，通常我们说的IO指的是后两者。

## 1.2 一个网络输入操作 通常包括几个阶段？
&emsp;&emsp; LINUX中进程无法直接操作I/O设备，其必须通过系统调用请求kernel来协助完成I/O动作；内核会为每个I/O设备维护一个缓冲区。
&emsp;&emsp; 对于一个输入操作来说，进程IO系统调用后，内核会先看缓冲区中有没有相应的缓存数据，没有的话再到设备中读取，因为设备IO一般速度较慢，需要等待；内核缓冲区有数据则直接复制到进程空间。所以，对于一个网络输入操作通常包括两个不同阶段：
>（1）等待网络数据到达网卡→读取到内核缓冲区，数据准备好；
>（2）从内核缓冲区复制数据到进程空间。
>






&emsp;
&emsp; 
# 2. Unix IO模型 概述
## 2.1 Unix(Linux) 有哪几种IO模型？
UNIX有5种I/O模型,阻塞会发生在两个阶段上:
**(1) 阻塞式I/O**
&emsp;&emsp; 等待数据时阻塞 数据从内核复制到用户空间时阻塞 
**(2) 非阻塞式I/O** 
&emsp;&emsp; 阻塞式I/O又称为同步阻塞IO，即传统的IO模型，用户线程在内核进行IO操作时被阻塞：
&emsp;&emsp; 等待数据不阻塞,但是轮询会占用cpu资源 数据从内核复制到用户空间时阻塞 
**(3) I/O复用** 
&emsp;&emsp; 考虑到轮询占用cpu资源的问题,阻塞在选择器上,减轻处理器负担 将数据从内核复制到用户空间时阻塞 
**(4) 信号驱动式I/O** 
&emsp;&emsp; 等待数据不阻塞,数据准备好时通知接收数据,将数据从内核复制到用户空间时阻塞
以上四种或多或少均有阻塞现象存在,它们都是同步I/O模型。
**(5) 异步I/O** 
&emsp;&emsp; 等待数据时不阻塞 将数据从内核复制到用户空间时也不阻塞. 
     数据到了用户空间以后才发信号,就像你在网上下了订单,快递员拿着你的快件站在你家门口才通知你开门签收的样子.而在网上下了订单,货物到了离你家最近的自提点,商城通知你去自提点取提货.你专门抽出时间去提货.这是4.信号驱动式I/O.因为在来回自提点的路上你其实是阻塞的。

## 2.2 Unix IO模型 分类
### 2.2.1 阻塞式IO 和 非阻塞式IO
&emsp;&emsp; 所谓阻塞就是发起读取数据请求的时，当数据还没准备就绪的时候，这时请求是即刻返回，还是在这里等待数据的就绪，如果需要等待的话就是阻塞，反之如果即刻返回就是非阻塞。

### 2.2.2 同步IO 和 异步IO
> **同步IO**：导致请求进程阻塞，直到I/O操作完成。
> **异步IO**：不导致请求进程阻塞。
> 
上面两个定义是《UNIX网络编程 卷1：套接字联网API》给出的。这不是很好理解，我们来扩展一下，先说说同步和异步，同步和异步 关注的是双方的消息通信机制：
> 同步：双方的动作是经过双方协调的，步调一致的。
> 异步：双方并不需要协调，都可以随意进行各自的操作。
> 
这里我们的双方是指，用户进程和IO设备；明确同步和异步之后，我们在上面网络输入操作例子的基础上，进行扩展定义：
> **同步IO**：用户进程发出IO调用，去获取IO设备数据，双方的数据要经过内核缓冲区同步，完全准备好后，再复制返回到用户进程。而复制返回到用户进程会导致请求进程阻塞，直到I/O操作完成。
> **异步IO**：用户进程发出IO调用，去获取IO设备数据，并不需要同步，内核直接复制到进程，整个过程不导致请求进程阻塞。
> 
### 2.2.3 这五种IO模型中，哪些是同步的，哪些是异步的？
根据前面的定义很容易知道： 阻塞IO模型、非阻塞IO模型、IO复用模型、信号驱动的IO模型者为同步IO模型，只有异步IO模型是异步IO。

## 2.3 使用 同步IO 还是 异步IO 比较好？
&emsp;&emsp; 目前Linux下的AIO还是不太成熟，现在基本用的都是IO多路复用（`epoll`接口）。






&emsp;
&emsp; 
# 3. Unix IO模型 详述
## 3.1 TCP发送数据的流程
&emsp;&emsp; 要深入的理解各种IO模型，那么必须先了解下产生各种IO的原因是什么，要知道这其中的本质问题那么我们就必须要知一条消息是如何从过一个人发送到另外一个人的，下面以两个应用程序通讯为例，我们来了解一下当“A”向"B" 发送一条消息，简单来说会经过如下流程：
> 第一步：应用A 把消息发送到 TCP发送缓冲区。
> 第二步：TCP发送缓冲区 再把消息发送出去，经过网络传递后，消息会发送到 B服务器的 TCP接收缓冲区。
> 第三步：B再从 TCP接收缓冲区 去读取属于自己的数据。
> 
<div align = "center"><img src = "./pic/IO model of Unix(Linux)/pic1.jpg"></div>

## 3.2 阻塞式I/O（Blocking IO）和 非阻塞式I/O（Non-blocking IO）
&emsp;&emsp; 我们把视角切换到上面图中的第三步， 也就是应用B从TCP缓冲区中读取数据：
<div align = "center"><img src = "./pic/IO model of Unix(Linux)/pic2.jpg"></div>

我们来思考这样一个问题：
&emsp;&emsp; 因为应用之间发送消息是间断性的，也就是说：在上图中的 TCP缓冲区 还没有接收到属于应用B该读取的消息时，若此时应用B向TCP缓冲区发起读取申请，TCP接收缓冲区有两种选择：
> ① 应该马上告诉应用B 现在没有你的数据
> ② 让应用B在这里等着，直到有数据再把数据交给应用B。
> 
在上面两个选择中，TCP缓冲区应该怎么做呢？
&emsp;&emsp; 把这个问题应用到第一个步骤也是一样，应用A在向TCP发送缓冲区发送数据时，如果TCP发送缓冲区已经满了：
> 那么是告诉应用A现在没空间了，
> 还是让应用A等待着，等TCP发送缓冲区有空间了再把应用A的数据访拷贝到发送缓冲区。
> 
## 3.2.1 阻塞式I/O
&emsp;&emsp; 所谓阻塞IO就是当应用B发起读取数据申请时，在内核数据没有准备好之前，应用B会一直处于等待数据状态，直到内核把数据准备好了交给应用B才结束。
&emsp;&emsp; **术语描述**：在应用调用`recvfrom()`读取数据时，其系统调用直到数据包到达且被复制到应用缓冲区中或者发送错误时才返回，在此期间一直会等待，进程从调用到返回这段时间内都是被阻塞的称为阻塞IO；大致流程为：
> (1) 应用进程向内核发起recfrom读取数据。
> (2) 准备数据报（应用进程阻塞）。
> (3) 将数据从内核负责到应用空间。
> (4) 复制完成后，返回成功提示。
> 
<div align = "center"><img src = "./pic/IO model of Unix(Linux)/pic3.jpg"></div>

## 3.2.2 非阻塞式I/O
&emsp;&emsp; 所谓非阻塞IO就是当应用B发起读取数据申请时，如果内核数据没有准备好会即刻告诉应用B，不会让B在这里等待。
&emsp;&emsp; **术语描述**：非阻塞IO 是在应用调用`recvfrom`读取数据时，如果该缓冲区没有数据的话，就会直接返回一个`EWOULDBLOCK`错误，不会让应用一直等待中。在没有数据的时候会即刻返回错误标识，那也意味着如果应用要读取数据就需要不断的调用`recvfrom`请求，直到读取到它数据要的数据为止。大致流程为：
> (1) 应用进程向内核发起`recvfrom`读取数据。
> (2) 没有数据报准备好，即刻返回`EWOULDBLOCK`错误码。
> (3) 应用进程不停地向内核发起`recvfrom`读取数据，已有数据包准备好就进行一下 步骤，否则还是返回错误码。
> (4) 将数据从内核拷贝到用户空间。
> (5) 完成后，返回成功提示。
> 
<div align="center"><img src="./pic/IO model of Unix(Linux)/pic11.jpg"></div>

## 3.2.3 优缺点
(1) 阻塞式I/O
> 线程(进程)一直阻塞，导致其不能做其它工作，浪费了资源。
> 
(2) 非阻塞式I/O
> 在数据没准备好的时候，CPU一直轮询看数据是否准备完毕，这样很浪费CPU资源
> 

## 3.3 I/O复用（IO Multiplexing）
### 3.3.1 为什么需要 IO复用？它能解决什么问题？
**思考一个问题：**
> &emsp;&emsp; 我们还是把视角放到 应用B 从TCP缓冲区中 读取数据这个环节来。如果在并发的环境下，可能会N个用户向应用B发送消息，这种情况下我们的应用就必须创建多个线程去读取数据，每个线程都会自己调用`recvfrom` 去读取数据。那么此时情况可能如下图：
> 
<div align="center"><img src="./pic/IO model of Unix(Linux)/pic4.jpg"></div>

&emsp;&emsp; 如上图一样，并发情况下服务器很可能一瞬间会收到几十上百万的请求，这种情况下应用B就需要创建几十上百万的线程去读取数据，同时又因为应用线程是不知道什么时候会有数据读取，为了保证消息能及时读取到，那么这些线程自己必须不断的向内核发送`recvfrom` 请求来读取数据；
&emsp;&emsp; 那么问题来了，这么多的线程不断调用`recvfrom` 请求数据，先不说服务器能不能扛得住这么多线程，就算扛得住那么很明显这种方式是不是太浪费资源了，线程是我们操作系统的宝贵资源，大量的线程用来去读取数据了，那么就意味着能做其它事情的线程就会少。
&emsp;&emsp; 所以，有人就提出了一个思路，能不能提供一种方式，可以由一个线程监控多个网络请求（我们后面将称为fd文件描述符，linux系统把所有网络请求以一个fd来标识），这样就可以只需要一个或几个线程就可以完成数据状态询问的操作，当有数据准备就绪之后再分配对应的线程去读取数据，这么做就可以节省出大量的线程资源出来，这个就是IO复用模型的思路。
<div align="center"><img src="./pic/IO model of Unix(Linux)/pic5.jpg"></div>

正如上图，IO复用模型的思路就是系统提供了一种函数可以同时监控多个fd的操作，这个函数就是我们常说到的select、poll、epoll函数，有了这个函数后，应用线程通过调用select函数就可以同时监控多个fd，select函数监控的fd中只要有任何一个数据状态准备就绪了，select函数就会返回可读状态，这时询问线程再去通知处理数据的线程，对应线程此时再发起`recvfrom`请求去读取数据。

### 3.3.2 IO多路复用 能解决什么问题？
&emsp;&emsp; IO多路复用 通过slect或poll、epoll 来监控多fd ，来达到不必为每个fd创建一个对应的监控线程，从而减少线程资源创建的目的。

### 3.3.3 什么是 IO多路复用
&emsp;&emsp; 进程通过将一个或多个fd传递给`select`，阻塞在`select`操作上，`select`帮我们侦测多个fd是否准备就绪，当有fd准备就绪时，`select`返回数据可读状态，应用程序再调用`recvfrom`读取数据。
<div align="center"><img src="./pic/IO model of Unix(Linux)/pic6.jpg"></div>

### 3.3.4 有哪些 IO多路复用 接口？
`select、poll、epoll`

## 3.4 信号驱动式I/O
## 3.4.1 为什么需要 信号驱动式I/O
&emsp;&emsp; IO多路模型 可以使用一个线程可以监控多个fd，但是`select`仍然是采用轮询的方式来监控多个fd的，通过不断的轮询fd的可读状态来知道是否就可读的数据，而无脑的轮询就显得有点暴力，因为大部分情况下的轮询都是无效的，所以有人就想，能不能不要我总是去问你是否数据准备就绪，能不能我发出请求后等你数据准备好了就通知我，所以就衍生了信号驱动IO模型。
## 3.4.2 信号驱动式I/O 工作原理
&emsp;&emsp; 于是信号驱动IO不是用循环请求询问的方式去监控数据就绪状态，而是在调用`sigaction`时候建立一个`SIGIO`的信号联系，当内核数据准备好之后再通过`SIGIO`信号通知线程数据准备好后的可读状态，当线程收到可读状态的信号后，此时再向内核发起`recvfrom`读取数据的请求，因为信号驱动IO的模型下应用线程在发出信号监控后即可返回，不会阻塞，所以这样的方式下，一个应用线程也可以同时监控多个fd。大致原理如下图：
<div align="center"><img src="./pic/IO model of Unix(Linux)/pic7.jpg"></div>

&emsp;&emsp; **术语描述**：首先开启套接口信号驱动IO功能，并通过系统调用`sigaction`执行一个信号处理函数，此时请求即刻返回，当数据准备就绪时，就生成对应进程的SIGIO信号，通过信号回调通知应用线程调用`recvfrom`来读取数据。
<div align="center"><img src="./pic/IO model of Unix(Linux)/pic8.jpg"></div>

&emsp;&emsp; **总结**： IO复用模型里面的`select`虽然可以监控多个fd了，但select其实现的本质上还是通过不断的轮询fd来监控数据状态， 因为大部分轮询请求其实都是无效的，所以信号驱动IO意在通过这种建立信号关联的方式，实现了发出请求后只需要等待数据就绪的通知即可，这样就可以避免大量无效的数据状态轮询操作。

## 3.4.3 信号驱动式I/O 和 IO多路复用 有何区别？
它们都可以监控多个fd，但是它们原理不一样：
> &emsp;&emsp; **IO多路复用** 是使用一个线程阻塞在`select`调用上，以此来监控多个fd，但是`select`本质上仍然是采用轮询的方式来监控多个fd的，占用了CPU时间。
> &emsp;&emsp;  **信号驱动式I/O** 是调用`sigaction`时候建立一个`SIGIO`的信号联系，当内核数据准备好之后再通过`SIGIO`信号通知线程数据准备好后的可读状态，当线程收到可读状态的信号后，此时再向内核发起`recvfrom`读取数据的请求。
> 

## 3.5 异步IO（Asynchronous IO）
### 3.5.1 异步IO 的工作原理
思考这样一个问题：
> 也许你一开始就有一个疑问，为什么我们明明是想读取数据，什么非得要分两步走：
> &emsp;&emsp;① 先发起一个select询问数据状态的请求；
> &emsp;&emsp;② 然后再发起真正的读取数据请求；
> 能不能有一种一劳永逸的方式，我只要发送一个请求我告诉内核我要读取数据，然后我就什么都不管了，然后内核去帮我去完成剩下的所有事情？
> 
当然既然你想得出来，那么就会有人做得到，有人设计了一种方案，应用只需要向内核发送一个read 请求,告诉内核它要读取数据后即刻返回；内核收到请求后会建立一个信号联系，当数据准备就绪，内核会主动把数据从内核复制到用户空间，等所有操作都完成之后，内核会发起一个通知告诉应用，我们称这种一劳永逸的模式为**异步IO模型**：
<div align="center"><img src="./pic/IO model of Unix(Linux)/pic9.jpg"></div>

**术语描述**： 应用告知内核启动某个操作，并让内核在整个操作完成之后，通知应用，这种模型与信号驱动模型的主要区别在于，信号驱动IO只是由内核通知我们合适可以开始下一个IO操作，而异步IO模型是由内核通知我们操作什么时候完成。
<div align="center"><img src="./pic/IO model of Unix(Linux)/pic10.jpg"></div>

**总结**：异步IO的优化思路是解决了应用程序需要先后发送询问请求、发送接收数据请求两个阶段的模式，在异步IO的模式下，只需要向内核发送一次请求就可以完成状态询问和数拷贝的所有操作。

### 3.5.2 相比与 IO复用 和 信号驱动IO，异步IO 有何优势？
&emsp;&emsp; 通过观察我们不难发现，不管是IO复用还是信号驱动IO，我们要读取一个数据总是要发起两阶段的请求：
> 第一次发送select请求，询问数据状态是否准备好;
> 第二次发送recevform请求读取数据。
> 
异步IO进行了优化，解决了应用程序需要先后发送询问请求、发送接收数据请求两个阶段的模式，在异步IO的模式下，只需要向内核发送一次请求就可以完成状态询问和数拷贝的所有操作。

## 3.6 五种IO模型比较
我们之前已经介绍过了，一个网络输入操作通常包括两个不同阶段：
>（1）等待网络数据到达网卡→读取到内核缓冲区，数据准备好；
>（2）从内核缓冲区复制数据到进程空间。
>
那么根据两个阶段各个模型的应对方式，可将五种IO模型的特征画图如下：
<div align="center"><img src="./pic/IO model of Unix(Linux)/pic12.jpg"></div>

可以看到的是：
**(1) 阻塞IO** 两个阶段都阻塞了；
**(2) 非阻塞IO** 第一个结算不停的轮询检查网络数据是否到的，第二个阶段阻塞；
**(3) IO多路复用** 第一个阶段阻塞与`select`(`poll`或`epoll`)，第二个结算阻塞
**(4) 信号IO** 第一个阶段只需注册一下SIGIO，第二个阶段阻塞；
**(5) 异步IO** 两个阶段都不阻塞

## IO多路复用与非阻塞有何区别？
https://zhuanlan.zhihu.com/p/348979899



&emsp;
&emsp; 
# 4. 如何使用 IO多路复用的接口？


# 5. 水平触发 和 边沿触发



&emsp;
&emsp; 
# 参考文献
1. [《Linux/UNIX系统编程手册》](https://book.douban.com/subject/25809330/)
2. [Linux高性能服务器编程](https://book.douban.com/subject/24722611/)
3. [100%弄明白5种IO模型](https://zhuanlan.zhihu.com/p/115912936)
4. [IO model](https://www.cnblogs.com/glh-ty/p/8812564.html)
5. [5种IO模型、阻塞IO和非阻塞IO、同步IO和异步IO](https://blog.csdn.net/tjiyu/article/details/52959418)