# 1. Unix IO模型 概述
## 1.1 Unix(Linux) 有哪几种IO模型？
UNIX有5种I/O模型,阻塞会发生在两个阶段上:
**(1) 阻塞式I/O**
&emsp;&emsp; 等待数据时阻塞 数据从内核复制到用户空间时阻塞 
**(2) 非阻塞式I/O** 
&emsp;&emsp; 阻塞式I/O又称为同步阻塞IO，即传统的IO模型，用户线程在内核进行IO操作时被阻塞：
&emsp;&emsp; 等待数据不阻塞,但是轮询会占用cpu资源 数据从内核复制到用户空间时阻塞 
**(3) I/O复用** 
&emsp;&emsp; 考虑到轮询占用cpu资源的问题,阻塞在选择器上,减轻处理器负担 将数据从内核复制到用户空间时阻塞 
**(4) 信号驱动式I/O** 
&emsp;&emsp; 等待数据不阻塞,数据准备好时通知接收数据,将数据从内核复制到用户空间时阻塞
以上四种或多或少均有阻塞现象存在,它们都是同步I/O模型。
**(5) 异步I/O** 
&emsp;&emsp; 等待数据时不阻塞 将数据从内核复制到用户空间时也不阻塞. 
     数据到了用户空间以后才发信号,就像你在网上下了订单,快递员拿着你的快件站在你家门口才通知你开门签收的样子.而在网上下了订单,货物到了离你家最近的自提点,商城通知你去自提点取提货.你专门抽出时间去提货.这是4.信号驱动式I/O.因为在来回自提点的路上你其实是阻塞的。

## 1.2 阻塞式IO 和 非阻塞式IO


## 1.3 同步IO 和 异步IO






&emsp;
&emsp; 
# 2. Unix IO模型 详述
## 2.1 TCP发送数据的流程
&emsp;&emsp; 要深入的理解各种IO模型，那么必须先了解下产生各种IO的原因是什么，要知道这其中的本质问题那么我们就必须要知一条消息是如何从过一个人发送到另外一个人的，下面以两个应用程序通讯为例，我们来了解一下当“A”向"B" 发送一条消息，简单来说会经过如下流程：
> 第一步：应用A 把消息发送到 TCP发送缓冲区。
> 第二步：TCP发送缓冲区 再把消息发送出去，经过网络传递后，消息会发送到 B服务器的 TCP接收缓冲区。
> 第三步：B再从 TCP接收缓冲区 去读取属于自己的数据。
> 
<div align = "center"><img src = "./pic/IO model of Unix(Linux)/pic1.jpg"></div>

## 2.2 阻塞式I/O（Blocking IO）和 非阻塞式I/O（Non-blocking IO）
&emsp;&emsp; 我们把视角切换到上面图中的第三步， 也就是应用B从TCP缓冲区中读取数据：
<div align = "center"><img src = "./pic/IO model of Unix(Linux)/pic2.jpg"></div>

我们来思考这样一个问题：
&emsp;&emsp; 因为应用之间发送消息是间断性的，也就是说：在上图中的 TCP缓冲区 还没有接收到属于应用B该读取的消息时，若此时应用B向TCP缓冲区发起读取申请，TCP接收缓冲区有两种选择：
> ① 应该马上告诉应用B 现在没有你的数据
> ② 让应用B在这里等着，直到有数据再把数据交给应用B。
> 
在上面两个选择中，TCP缓冲区应该怎么做呢？
&emsp;&emsp; 把这个问题应用到第一个步骤也是一样，应用A在向TCP发送缓冲区发送数据时，如果TCP发送缓冲区已经满了：
> 那么是告诉应用A现在没空间了，
> 还是让应用A等待着，等TCP发送缓冲区有空间了再把应用A的数据访拷贝到发送缓冲区。
> 
## 2.2.1 阻塞式I/O
&emsp;&emsp; 所谓阻塞IO就是当应用B发起读取数据申请时，在内核数据没有准备好之前，应用B会一直处于等待数据状态，直到内核把数据准备好了交给应用B才结束。
&emsp;&emsp; **术语描述**：在应用调用`recvfrom()`读取数据时，其系统调用直到数据包到达且被复制到应用缓冲区中或者发送错误时才返回，在此期间一直会等待，进程从调用到返回这段时间内都是被阻塞的称为阻塞IO；大致流程为：
> (1) 应用进程向内核发起recfrom读取数据。
> (2) 准备数据报（应用进程阻塞）。
> (3) 将数据从内核负责到应用空间。
> (4) 复制完成后，返回成功提示。
> 
<div align = "center"><img src = "./pic/IO model of Unix(Linux)/pic3.jpg"></div>

## 2.2.2 非阻塞式I/O
&emsp;&emsp; 所谓非阻塞IO就是当应用B发起读取数据申请时，如果内核数据没有准备好会即刻告诉应用B，不会让B在这里等待。
&emsp;&emsp; **术语描述**：非阻塞IO 是在应用调用`recvfrom`读取数据时，如果该缓冲区没有数据的话，就会直接返回一个`EWOULDBLOCK`错误，不会让应用一直等待中。在没有数据的时候会即刻返回错误标识，那也意味着如果应用要读取数据就需要不断的调用`recvfrom`请求，直到读取到它数据要的数据为止。大致流程为：
> (1) 应用进程向内核发起`recvfrom`读取数据。
> (2) 没有数据报准备好，即刻返回`EWOULDBLOCK`错误码。
> (3) 应用进程不停地向内核发起`recvfrom`读取数据，已有数据包准备好就进行一下 步骤，否则还是返回错误码。
> (4) 将数据从内核拷贝到用户空间。
> (5) 完成后，返回成功提示。
> 
## 2.2.3 优缺点
(1) 阻塞式I/O
> 线程(进程)一直阻塞，导致其不能做其它工作，浪费了资源。
> 
(2) 非阻塞式I/O
> 在数据没准备好的时候，CPU一直轮询看数据是否准备完毕，这样很浪费CPU资源
> 

## 2.3 I/O复用（IO Multiplexing）



## 2.4 信号驱动式I/O



## 2.5 异步IO（Asynchronous IO）



## 2.6 






&emsp;
&emsp; 
# 参考文献
1. [《Linux/UNIX系统编程手册》](https://book.douban.com/subject/25809330/)
2. [Linux高性能服务器编程](https://book.douban.com/subject/24722611/)
3. [100%弄明白5种IO模型](https://zhuanlan.zhihu.com/p/115912936)
4. [IO model](https://www.cnblogs.com/glh-ty/p/8812564.html)