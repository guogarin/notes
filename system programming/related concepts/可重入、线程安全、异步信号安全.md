## 1. 可重入函数(reentrant function)
### 1.1 什么是可重入函数
&emsp;&emsp; 要解释可重入函数为何物，首先需要区分单线程程序和多线程程序。典型 UNIX 程序都具有一条执行线程，贯穿程序始终， CPU 围绕单条执行逻辑来处理指令。而对于多线程程序而言，同一进程却存在多条独立、并发的执行逻辑流。
&emsp;&emsp; 如果 <span style="color:red;"> 同一个进程的 </span><span style="color:green;">多条线程</span> 可以<span style="color:red;">同时安全地</span>调用某一函数，那么该函数就是可重入的。此处，“安全”意味着，无论其他线程调用该函数的执行状态如何，函数均可产生预期结果。
&emsp;&emsp;**SUSv3 对可重入函数的定义是**：函数由两条或多条线程调用时，即便是交叉执行，其效果也与各线程以未定义1顺序依次调用时一致。

### 1.2 什么样的函数是可重入函数？为什么？
* (1) 不能使用`malloc`系列函数，因为`malloc`函数内部是通过全局链表实现的
&emsp;&emsp;  `malloc()`和 `free()`维护有一个针对已释放内存块的链表，用于从堆中重新分配内存。如果主程序在调用 malloc()期间为一个同样调用 malloc()的信号处理器函数所中断，那么该链表可能会遭到破坏。因此，`malloc()`函数族以及使用它们的其他库函数都是不可重入的。
* (2) 不可以调用标准`I/O`库函数，这些库函数很多都不是可重入的
&emsp;&emsp; 就拿 `stdio`函数库成员 来说吧（`printf()`、 `scanf()`等），它们会为缓冲区 `I/O` 更新内部数据结构。所以，如果在信号处理器函数中调用了 `printf()`， 而主程序又在调用` printf()`或其他 `stdio` 函数期间遭到了处理器函数。
的中断，那么有时就会看到奇怪的输出，甚至导致程序崩溃或者数据的损坏。
* (3) 函数不能有全局或者静态变量，否则连线程安全都不满足了
&emsp;&emsp;更新全局变量或静态数据结构的函数可能是不可重入的。（只用到本地变量的函数肯定是可
重入的。）如果对函数的两个调用（例如：分别由两条执行线程发起）同时试图更新同一全局变量或数据类型，那么二者很可能会相互干扰并产生不正确的结果。例如，假设某线程正在为一链表数据结构添加一个新的链表项，而另一线程也正试图更新同一链表。由于为链表添加新项涉及对多枚指针的更新，一旦另一线程中断这些步骤并修改了相同的指针，结果就会产生混乱。






&emsp;
&emsp; 
## 2. 线程安全(thread safe)
### 2.1 什么是线程安全？
&emsp;&emsp; 依据[JCP]， 一个线程安全的class应当满足以下三个条件：
* (1)多个线程同时访问时， 其表现出正确的行为。
* (2)无论操作系统如何调度这些线程， 无论这些线程的执行顺序如何交织（interleaving） 。
* (3)调用端代码无须额外的同步或其他协调动作。
依据这个定义， C++标准库里的大多数class都不是线程安全的， 包括`std:: string`、`std::vector`、`std::map`等， 因为这些`class`通常需要在外部加锁才能供多个线程同时访问。
&emsp;&emsp; 从本质上来说，“线程安全”不是指线程的安全，而是指内存的安全。为什么如此说呢？这和操作系统有关。
&emsp;&emsp; 目前主流操作系统都是多任务的，即多个进程同时运行。为了保证安全，每个进程只能访问分配给自己的内存空间，而不能访问别的进程的，这是由操作系统保障的。
&emsp;&emsp; 在每个进程的内存空间中都会有一块特殊的公共区域，通常称为堆（内存）。进程内的所有线程都可以访问到该区域，这就是造成问题的潜在原因。
&emsp;&emsp; 假设某个线程把数据处理到一半，觉得很累，就去休息了一会，回来准备接着处理，却发现数据已经被修改了，不是自己离开时的样子了。可能被其它线程修改了。
&emsp;&emsp; 比如把你住的小区看作一个进程，小区里的道路/绿化等就属于公共区域。你拿1万块钱往地上一扔，就回家睡觉去了。睡醒后你打算去把它捡回来，发现钱已经不见了。可能被别人拿走了。因为公共区域人来人往，你放的东西在没有看管措施时，一定是不安全的。内存中的情况亦然如此。
&emsp;&emsp; 所以线程安全指的是，在堆内存中的数据由于可以被任何线程访问到，在没有限制的情况下存在被意外修改的风险。
&emsp;&emsp; 也就是说，堆内存空间在没有保护机制的情况下，对多线程来说是不安全的地方，因为你放进去的数据，可能被别的线程“破坏”。

### 2.2 如何保证 线程安全？
&emsp;&emsp; 用同步原语来协调对共享资源的访问。 

### 2.3 有哪些同步原语可以用在线程上？它们有何特点？
&emsp;&emsp; 线程提供的强大共享是有代价的。多线程应用程序必须使用互斥量和条件变量等同步原语来协调对共享变量的访问：
* **互斥量(mutex,即mutual exclusion)** 可以帮助线程同步对共享资源的使用，以防如下情况发生：线程某甲试图访问一共享变量时，线程某乙正在对其进行修改。
* **条件变量(condition variable)** 则是在此之外的拾遗补缺，允许线程相互通知共享变量（或其他共享资源）的状态发生了变化。

### 2.4 如何使用 同步原语 来保证线程安全？
见 《Linux/UNIX系统编程手册》 第30章 线程同步

### 2.4 用互斥锁等同步原语实现线程安全有何不足？
* (1) 由于互斥量的加、解锁开销，故而也带来了性能的下降；
* (2) 造成并发性能的下降，因为同一时点只能有一个线程运行该函数，仅在函数中操作共享变量（临界区）的代码前后加入互斥锁可以提升并发性能，除非出现多个线程需要同时执行同一临界区的情况。






&emsp;
&emsp; 
## 
## 3. 可重入函数 和 线程安全函数 有何异同？
&emsp;&emsp; 两者不是等价的概念，可重入更严格。
&emsp;&emsp; 如果一个函数的实现 使用了全局或者静态变量，那么这个函数既不是可重入的，也不是线程安全的。
&emsp;&emsp; 如果放宽条件，这个函数仍然用到了全局或者静态变量，但是在访问这些变量时，通过加锁来保证互斥访问，那么这个函数就可以变成线程安全的函数。但它此时仍然是不可重入的，因为通常加锁是针对不同线程的访问，对同一线程可能出现问题（发生信号软中断，signal handler中恰巧也执行了该函数）。
&emsp;&emsp; 那么如果把函数中的全局和静态变量都干掉，并保证在该函数中也不调用不可重入的函数，那么这个函数可以做到既是线程安全的，也是可重入的。
&emsp;&emsp; 综上，可重入函数一般都是线程安全的，线程安全的不一定是可重入的。
<div align="center"> <img src="./pic/reentrant_threadSafe.png"> </div>
<center> <font color=black> <b> 图2 WSGI中的角色 </b> </font> </center>






&emsp;
&emsp; 
## 
## 4. 异步信号安全函数
&emsp;&emsp; 异步信号安全的函数是指当从信号处理器函数调用时，可以保证其实现是安全的。如果某一函数是可重入的，又或者信号处理器函数无法将其中断时，就称该函数是异步信号安全的。
详见 《Linux/UNIX系统编程手册》 第21章 信号：信号处理器函数（pdf第380页）





&emsp;
&emsp; 
## 参考文献
1. [《Linux/UNIX系统编程手册》](https://book.douban.com/subject/25809330/)
2. [可重入和线程安全](https://www.cnblogs.com/lenomirei/p/5666154.html)
3. [什么是线程安全](https://zhuanlan.zhihu.com/p/67905621)
4. [异步可重入函数与线程安全函数等价吗？](https://www.zhihu.com/question/21526405/answer/37330407)