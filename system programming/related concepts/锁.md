# 1 综述
在介绍各种锁之前，先说一下 **进程调用**：
> 进程调度会把“缺乏资源”的进程置于休眠队列、又要把休眠队列中资源要求可以满足的进程置于等待队列——然后时间片一到就会调度运行。
> 
一般学到这里，我们都会觉得“资源”嘛，就是磁盘访问、网络通信之类东西：它们忙不忙，操作系统自然是知道的。但其实不然。操作系统在这里做了“归一化”处理，它压根懒得知道你在等什么（不然进程调度就实现的过于复杂了）。所谓的“资源”，在进程调度逻辑看来，就是一个个“锁”——请求锁得不到满足，就是“缺乏资源”；锁被释放了，请求它的进程显然就有“资源”可用了。。
**那么，我们可以用一些分析工具看出，多少进程阻塞在磁盘访问上了，这个是从何而来的呢？**
&emsp;&emsp; 答案是，操作系统会维护一个“锁”的列表；找到这个锁的对应项，读它的相关信息，再找到申请它的进程队列，自然就知道哪些进程试图访问磁盘、但暂时得不到满足了——注意这类锁并不需要进程显式申请，相关逻辑已经包含在对应的系统调用里了）





&emsp;
&emsp;
# 2 分类
按是否通知OS，自己需要的资源得不到满足 分类：
不通知：自旋锁
会通知：其它锁都会通知OS，于是OS暂停当前进程（线程）并将其置于等待/休眠队列，腾出它的CPU给其它 进/线程 使用；直到另外一个 进/线程 释放锁、它才可以再次得到执行机会。





&emsp;
&emsp; 
# 3 自旋锁（spinlock）
## 3.1 何为自旋锁？
&emsp;&emsp; 自旋锁”是一种“申请不到也不知会操作系统”的锁。对自旋锁加锁的操作，可以认为是类似这样的：
```cpp
while (acquired(lock)/*不停的尝试加锁*/ == false) {

}
```
只要没有锁上，就不断重试。显然，如果别的线程长期持有该锁，那么你这个线程就一直在 while while while 地检查是否能够加锁，浪费 CPU 做无用功。
## 3.2  优点：
&emsp;&emsp;这可以避免进程因被识别为“资源不足”而被操作系统置入休眠队列，从而避免不必要的上下文切换开销；
## 3.3 缺点：
&emsp;&emsp;它会导致“申请不到锁时执行死循环”，使得CPU核心占用100%
## 3.4 使用建议：
&emsp;&emsp;只有在多CPU和/或多核和/或多线程硬件平台上、且这个锁一定会在远短于一个时间片的时间内被请求到，它才可能真正提高效率（否则又是白白浪费时间、电力让CPU发热了）。总之，使用自旋锁必须非常慎重，须先模拟各种不同场景做好profile、然后根据数据决定是否使用它。





&emsp;
&emsp; 
# 4 互斥器（mutex）
## 4.1 何为互斥器？
&emsp;&emsp; 其实仔细想想，我们没必要像自旋锁那样一直去尝试加锁，因为只要锁的持有状态没有改变，加锁操作就肯定是失败的。所以，抢锁失败后只要锁的持有状态一直没有改变，那就让出 CPU 给别的线程先执行好了。
对互斥器加锁的操作你可以认为是类似这样的：
```cpp
while (抢锁(lock) == 没抢到) {
    本线程先去睡了请在这把锁的状态发生改变时再唤醒(lock);
}
```
操作系统负责线程调度，为了实现「锁的状态发生改变时再唤醒」就需要把锁也交给操作系统管理。所以互斥器的加锁操作通常都需要涉及到上下文切换，操作花销也就会比自旋锁要大。以上两者的作用是加锁互斥，保证能够排它地访问被锁保护的资源。不过并不是所有场景下我们都希望能够独占某个资源，很快你可能就会不得不写出这样的代码：

## 4.2 优点
&emsp;&emsp; 在资源就位时才会唤醒线程/进程，因此CPU占用率低。

## 4.3 缺点
&emsp;&emsp; 需要涉及到上下文切换，因此开销要大一些

## 4.4 如何使用？

互斥量既可以像静态变量那样分配，也可以在运行时动态创建：
> 静态初始值 `PTHREAD_MUTEX_INITIALIZER`，只能用于对 经由静态分配 且携带默认属性 的互斥量进行初始化。
> 其他情况下，必须调用 `pthread_mutex_init()`对互斥量进行动态初始化。
> 
静态初始化：
```cpp
#include <pthread.h>

static int glob = 0;
// ① 静态分配互斥量，并使用 PTHREAD_MUTEX_INITIALIZER 对其 初始化
static pthread_mutex_t mtx = PTHREAD_MUTEX_INITIALIZER;

static void * /* Loop 'arg' times incrementing 'glob' */
threadFunc(void *arg)
{
    int loops = *((int *) arg);
    int loc, j, s;
    for (j = 0; j < loops; j++) {
        // ② 加锁
        s = pthread_mutex_lock(&mtx);
        if (s != 0)
            errExitEN(s, "pthread_mutex_lock");
        loc = glob;
        loc++;
        glob = loc;
        // ③ 解锁
        s = pthread_mutex_unlock(&mtx);
        if (s != 0)
            errExitEN(s, "pthread_mutex_unlock");
    }
    return NULL;
}
```
动态初始化：
```cpp
// 声明一个互斥量
pthread_mutex_t mtx;
// 声明一个互斥量的属性变量
pthread_mutexattr_t mtx_attr;

// 初始化互斥量的属性变量
pthread_mutexattr_init(&mtx_attr);
// 设置递归互斥量的属性
pthread_mutexattr_settype(&mtx_attr, PTHREAD_MUTEX_RECURSIVE);

// 把属性赋值给互斥量
pthread_mutext_init(&mtx, &mutext_attr);
```
互斥器的使用，具体见 [TLPI 30.1小节]()





&emsp;
&emsp; 
# 5 条件变量（condition variable）
## 5.1 条件变量的作用
&emsp;&emsp; 条件变量不是锁，它是一种线程间的通讯机制，并且几乎总是和互斥量一起使用的。条件变量就共享变量的状态改变发出通知，而互斥量则提供对该共享变量访问的互斥（mutual exclusion）。这里使用的术语“信号”（signal），与linux信号（linux signal）无关，而是发出信号的意思。



&emsp;
&emsp; 
# 参考文献
1. [如何理解互斥锁、条件锁、读写锁以及自旋锁？](https://www.zhihu.com/question/66733477)