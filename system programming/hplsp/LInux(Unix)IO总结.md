# 1. I/O模型
## 1.1 Linux/Unix的I/O模型
### 1.1.1 IO模型的分类
#### 分类依据
UNIX有5种I/O模型,阻塞会发生在两个阶段上：
> ① 等待数据时
> ② 将数据从内核复制到用户空间时)上，
> 
#### 具体分类
在unix环境下，一般有这几种IO模型：
(1) **阻塞式I/O** 
&emsp;&emsp; 阻塞IO是最传统的一种IO模型，即在读写数据过程中会发生阻塞现象。它等待数据时阻塞 数据从内核复制到用户空间时阻塞：
> &emsp;&emsp; 比如，当从一个管道中读取数据时，如果管道中恰好没有数据，那么通常 read()会阻塞。而如果管道中没有足够的空间保存待写入的数据时， write()也会阻塞。
> 

(2) **非阻塞式I/O** 
&emsp;&emsp; 等待数据不阻塞,但是轮询会占用cpu资源 数据从内核复制到用户空间时阻塞。通过`fcntl`系统调用的`F_SETFL`命令， 将其设置为非阻塞的。 阻塞和非阻塞的概念能应用于所有文件描述符。
&emsp;&emsp; 针对阻塞I/O执行的系统调用可能因为无法立即完成而被操作系统挂起， 直到等待的事件发生为止。 比如， 客户端通过connect向服务器发起连接时， connect将首先发送同步报文段给服务器， 然后等待服务器返回确认报文段。 如果服务器的确认报文段没有立即到达客户端， 则connect调用将被挂起， 直到客户端收到确认报文段并唤醒connect调用。 socket的基础API中， 可能被阻塞的系统调用包括accept、 send、 recv和connect。
&emsp;&emsp; 针对非阻塞I/O执行的系统调用则总是立即返回， 而不管事件是否已经发生。 如果事件没有立即发生，这些系统调用就返回-1， 和出错的情况一样。 此时我们必须根据errno来区分这两种情况。 对accept、 send和recv而言， 事件未发生时errno通常被设置成EAGAIN（意为“再来一次”） 或者EWOULDBLOCK（意为“期望阻塞”） ； 对connect而言， errno则被设置成EINPROGRESS（意为“在处理中”） 。
&emsp;&emsp; 很显然， 我们只有在事件已经发生的情况下操作非阻塞I/O（读、 写等） ， 才能提高程序的效率。 因此， 非阻塞I/O通常要和其他I/O通知机制一起使用， 比如I/O复用和SIGIO信号。

(3) **I/O复用** 
&emsp;&emsp; 考虑到轮询占用cpu资源的问题,阻塞在选择器上,减轻处理器负担 将数据从内核复制到用户空间时阻塞。
&emsp;&emsp; I/O复用是最常使用的I/O通知机制。 它指的是， 应用程序通过I/O复用函数向内核注册一组事件， 内核通过I/O复用函数把其中就绪的事件通知给应用程序。

(4) **信号驱动式I/O**
&emsp;&emsp; 等待数据不阻塞,数据准备好时通知接收数据,将数据从内核复制到用户空间时阻塞。

<span style="color:red; font-size:20px"> &emsp;&emsp; 以上四种或多或少均有阻塞现象存在，因此它们都是同步I/O模型。</span> 

(5) **异步I/O** 
等待数据时不阻塞 将数据从内核复制到用户空间时也不阻塞。

(6) 总结
| IO模型        | 读写操作和阻塞阶段                                                                       |
| ------------- | ---------------------------------------------------------------------------------------- |
| 阻塞式I/O     | 程序阻塞于读、写两个阶段                                                                 |
| 非阻塞式I/O   |                                                                                          |
| I/O复用       | 程序阻塞于IO复用系统调用(epoll等) ，但可以同时监听多个IO时间，但对IO的读写操作是非阻塞的 |
| 信号驱动式I/O | 信号触发读写就绪事件，用户程序执行读写操作，程序没有阻塞阶段                             |
| 异步I/O       | 由内核来执行读写操作并触发读写完成事件，程序没有阻塞阶段                                 |

### 1.1.2 一个网上购物的小例子
&emsp;&emsp; 数据到了用户空间以后才发信号,就像你在网上下了订单,快递员拿着你的快件站在你家门口才通知你开门签收的样子。而在网上下了订单,货物到了离你家最近的自提点,商城通知你去自提点取提货.你专门抽出时间去提货.这是 4.信号驱动式I/O，因为在来回自提点的路上你其实是阻塞的。


&emsp;
## 1.2 同步IO(SIO, Synchronous IO) 和 异步IO(AIO, Asynchronous IO)
asynchronous /eɪˈsɪŋkrənəs/adj. 异步的；不同时的；不同期的
synchronous  /ˈsɪŋkrənəs/ adj. 同步的；同时的 
### 1.2.1 定义
&emsp;&emsp; 从理论上说，阻塞I/O、I/O复用和信号驱动I/O都是同步I/O。因为在这三种I/O模型中，I/O的读写操作，都是在I/O事件发生之后，由应用程序来完成的。 
&emsp;&emsp; 而`POSIX`规范所定义的异步I/O模型则不同。 对异步I/O而言， 用户可以直接对I/O执行读写操作， 这些操作告诉内核用户读写缓冲区的位置， 以及I/O操作完成之后内核通知应用程序的方式。 异步I/O的读写操作总是立即返回， 而不论I/O是否是阻塞的， 因为真正的读写操作已经由内核接管。 也就是说:
> 同步I/O模型要求用户代码自行执行I/O操作（将数据从内核缓冲区读入用户缓冲区，或将数据从用户缓冲区写入内核缓冲区）;
> 而异步I/O机制则由内核来执行I/O操作（ 数据在内核缓冲区和用户缓冲区之间的移动是由内核在“后台”完成的） 。 
> 
我们可以这样认为：
> 同步I/O向应用程序通知的是I/O就绪事件;
> 而异步I/O向应用程序通知的是I/O完成事件。
> 
在Linux环境下，`aio.h`头文件中定义的函数提供了对异步I/O的支持。
### 1.2.2 现实中的使用
&emsp;&emsp; 在实际应用中，还是使用IO多路复用，异步IO还不够成熟。



&emsp;
&emsp;
# 2. IO多路复用
## 2.1 什么是IO多路复用？
&emsp;&emsp; IO多路复用是一种同步IO模型，实现一个线程可以监视多个文件句柄；一旦某个文件句柄就绪，就能够通知应用程序进行相应的读写操作；没有文件句柄就绪时会阻塞应用程序，交出cpu。

## 2.2 IO多路复用的”多路”和”复用”分别指的是什么？
&emsp;&emsp; 多路是指多个网络连接，复用指的是复用同一个线程，连起来就是：
> 使用一个线程来检查多个文件描述符(Socket网络连接)的就绪状态；
> 

## 2.3 

## 几种IO多路复用系统调用的区别




# 参考文献
1.