[toc]



&emsp;
&emsp; 
# 1. C 和 C++ 的区别和联系






&emsp;
&emsp; 
# 2. new 和 malloc 有何区别？
**① 最大的区别**
> &emsp;&emsp; `new`在申请空间的时候会调用构造函数，`malloc`不会调用
>
**② 申请成功时的返回类型**
> &emsp;&emsp; `new`操作符申请内存成功时，返回的是对象类型的指针，类型严格与对象匹配，无需进行类型转换，因此new是类型安全性操作符。
> &emsp;&emsp; `malloc`申请内存成功则返回`void*`，需要手动进行强制类型转换为我们所需的类型；
> 
**③ 申请失败的返回类型**
> &emsp;&emsp;` new`在申请空间失败后返回的是错误码`bad_alloc`，`malloc`在申请空间失败后会返回`NULL`
>
**④ 属性上的区别**
> &emsp;&emsp; `new/delete`是C++关键字需要编译器支持，`maollc`是库函数，需要添加头文件
>
**⑤ 调用时所需参数**
> &emsp;&emsp; `new`在申请内存分配时不需要指定内存块大小，编译器会更具类型计算出大小；而`malloc`需要显示的指定所需内存的大小
>
**⑥ 自定义类型**
> &emsp;&emsp; `new`会先调`operator new`函数，申请足够的内存（底层也是`malloc`实现），然后调用类的构造函数，初始化成员变量，最后返回自定义类型指针。`delete`先调用析构函数，然后调用`operator delete`函数来释放内存（底层是通过`free`实现）。
> &emsp;&emsp; `malloc/free`是库函数，只能动态的申请和释放内存，无法强制要求其做自定义类型对象构造和析构函数
> 
**⑦ 重载**
> &emsp;&emsp; C++允许重载`new/delete`操作符，特别的，布局`new`的就不需要为对象分配内存，而是指定了一个地址作为内存起始区域，`new`在这段内存上为对象调用构造函数完成初始化工作，并返回地址。`malloc`不允许重载。
> 
