- [1. 综合](#1-综合)
  - [1.1 什么是协议？](#11-什么是协议)
  - [1.2 协议是强制性的吗？](#12-协议是强制性的吗)
  - [有哪些协议？](#有哪些协议)
- [2. 序列协议(sequence protocol)](#2-序列协议sequence-protocol)
  - [2.1 序列协议的作用是？](#21-序列协议的作用是)
  - [2.2 序列协议需要实现哪几个方法？](#22-序列协议需要实现哪几个方法)
  - [2.3 如何正确的实现序列协议？](#23-如何正确的实现序列协议)
  - [可切片的序列(A Sliceable Sequence)](#可切片的序列a-sliceable-sequence)






&emsp;
&emsp;
&emsp;
# 1. 综合
## 1.1 什么是协议？
&emsp;&emsp; 在面向对象编程中， 协议是非正式的接口， 只在文档中定义， 在代码中不定义。 例如， Python 的序列协议只需要 `__len__` 和 `__getitem__` 两个方法。 任何类（如 Spam） ， 只要使用标准的签名和语义实现了这两个方法， 就能用在任何期待序列的地方。 Spam 是不是哪个类的子类无关紧要， 只要提供了所需的方法即可。 

## 1.2 协议是强制性的吗？
&emsp;&emsp; 协议是非正式的， 没有强制力， 因此如果你知道类的具体使用场景， 通常只需要实现一个协议的部分。 例如， 为了支持迭代， 只需实现 __getitem__ 方法， 没必要提供 __len__ 方法。

## 有哪些协议？
序列协议
迭代协议
映射协议
散列协议
上下文管理协议
缓冲协议
描述符协议






&emsp;
&emsp;
&emsp;
# 2. 序列协议(sequence protocol)
## 2.1 序列协议的作用是？
实现序列协议有两个作用：
> (1) 可以像序列一样顺序读取，如`seq[3]`;
> (2) 可以切片，如`seq[:3]`
> 

## 2.2 序列协议需要实现哪几个方法？
Python 的序列协议只需要两个方法：
> (1) `__len__()` : 
> (2) `__getitem__()`
> 

## 2.3 如何正确的实现序列协议？
> (1) `__len__()` : 返回对象的长度(一个`int`)
> (2) `__getitem__()` ： 根据索引返回对应的元素
> 
```python
import collections

Card = collections.namedtuple('Card', ['rank', 'suit'])

class FrenchDeck:
    ranks = [str(n) for n in range(2, 11)] + list('JQKA')
    suits = 'spades diamonds clubs hearts'.split()

    def __init__(self):
        self._cards = [Card(rank, suit) for suit in self.suits
                                        for rank in self.ranks]

    def __len__(self):
        return len(self._cards)

    def __getitem__(self, position):
        return self._cards[position]

fd = FrenchDeck()
print(f'索引： {fd[3]}') 
print(f'切片： {fd[:3]}')
```
运行结果：
```
索引： Card(rank='5', suit='spades')
切片： [Card(rank='2', suit='spades'), Card(rank='3', suit='spades'), Card(rank='4', suit='spades')]
```

## 可切片的序列(A Sliceable Sequence)

