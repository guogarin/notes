- [1. 综合](#1-综合)
  - [1.1 什么是协议？](#11-什么是协议)
  - [1.2 协议是强制性的吗？](#12-协议是强制性的吗)
  - [有哪些协议？](#有哪些协议)
- [2. 序列协议(sequence protocol)](#2-序列协议sequence-protocol)
  - [2.1 序列协议的作用是？](#21-序列协议的作用是)
  - [2.2 序列协议需要实现哪几个方法？](#22-序列协议需要实现哪几个方法)
  - [2.3 如何正确的实现序列协议？](#23-如何正确的实现序列协议)
  - [2.4 可切片的序列(A Sliceable Sequence)](#24-可切片的序列a-sliceable-sequence)
    - [2.4.1 把切片委托给对象中的序列属性的做法不够完美](#241-把切片委托给对象中的序列属性的做法不够完美)
    - [2.4.2 切片的原理：切片对象`slice`](#242-切片的原理切片对象slice)
      - [(1) 代码探索切片原理](#1-代码探索切片原理)
      - [(2) 总结](#2-总结)
    - [2.4.3 为`Vector`类实现更完美的切片](#243-为vector类实现更完美的切片)
    - [2.4.4 切片总结](#244-切片总结)






&emsp;
&emsp;
&emsp;
# 1. 综合
## 1.1 什么是协议？
&emsp;&emsp; 在面向对象编程中， 协议是非正式的接口， 只在文档中定义， 在代码中不定义。 例如， Python 的序列协议只需要 `__len__` 和 `__getitem__` 两个方法。 任何类（如 Spam） ， 只要使用标准的签名和语义实现了这两个方法， 就能用在任何期待序列的地方。 Spam 是不是哪个类的子类无关紧要， 只要提供了所需的方法即可。 

## 1.2 协议是强制性的吗？
&emsp;&emsp; 协议是非正式的， 没有强制力， 因此如果你知道类的具体使用场景， 通常只需要实现一个协议的部分。 例如， 为了支持迭代， 只需实现 __getitem__ 方法， 没必要提供 __len__ 方法。

## 有哪些协议？
序列协议
迭代协议
映射协议
散列协议
上下文管理协议
缓冲协议
描述符协议






&emsp;
&emsp;
&emsp;
# 2. 序列协议(sequence protocol)
## 2.1 序列协议的作用是？
实现序列协议有两个作用：
> (1) 可以像序列一样顺序读取，如`seq[3]`;
> (2) 可以切片，如`seq[:3]`
> 

## 2.2 序列协议需要实现哪几个方法？
Python 的序列协议只需要两个方法：
> (1) `__len__()` : 
> (2) `__getitem__()`
> (3) `__setitem__()`(非必须)
> 

## 2.3 如何正确的实现序列协议？
> (1) `__len__()` : 返回对象的长度(一个`int`)
> (2) `__getitem__()` ： 根据索引返回对应的元素
> (3) `__setitem__()`(非必须) ： 修改指定位置的序列元素，这个不是必须的，如果想提供修改功能的话才要实现。
> 
```python
import collections

Card = collections.namedtuple('Card', ['rank', 'suit'])

class FrenchDeck:
    ranks = [str(n) for n in range(2, 11)] + list('JQKA')
    suits = 'spades diamonds clubs hearts'.split()

    def __init__(self):
        self._cards = [Card(rank, suit) for suit in self.suits
                                        for rank in self.ranks]

    def __len__(self):
        return len(self._cards)

    def __getitem__(self, position):
        return self._cards[position]

fd = FrenchDeck()
print(f'索引： {fd[3]}') 
print(f'切片： {fd[:3]}')
```
运行结果：
```
索引： Card(rank='5', suit='spades')
切片： [Card(rank='2', suit='spades'), Card(rank='3', suit='spades'), Card(rank='4', suit='spades')]
```

## 2.4 可切片的序列(A Sliceable Sequence)
### 2.4.1 把切片委托给对象中的序列属性的做法不够完美
&emsp;&emsp; 如 `FrenchDeck` 类所示，如果能委托给对象中的序列属性，支持序列协议特别简单，对于向量类`Vector`，我可以这样写：
```python
class Vector:
    typecode = 'd'

    def __init__(self, components):
        self._components = array(self.typecode, components)

    def __len__(self):
        return len(self._components)

    def __getitem__(self, index):
        return self._components[index]
```
添加这两个方法之后， 就能执行下述操作了：
```python
>>> v1 = Vector([3, 4, 5])

>>> len(v1)
# 3

>>> v1[0], v1[-1]
# (3.0, 5.0)

>>> v7 = Vector(range(7))
>>> v7[1:4]
# array('d', [1.0, 2.0, 3.0])
```
&emsp;&emsp; 可以看到， 现在连切片都支持了，不过尚不完美，如果 `Vector` 实例的切片也是 `Vector` 实例，而不是数组，那就更好了。 前面那个 `FrenchDeck` 类也有类似的问题： 切片得到的是列表。 对 `Vector` 来说， 如果切片生成普通的数组， 将会缺失大量功能。
&emsp;&emsp; 想想内置的序列类型，切片得到的都是各自类型的新实例，而不是其他类型。
&emsp;&emsp; 因此，为了把 Vector 实例的切片也变成 Vector 实例， 我们不能简单地委托给数组切片。 我们要分析传给`__getitem__` 方法的参数， 做适当的处理。
下面来看 Python 如何把 my_seq[1:3] 句法变成传给 `my_seq.__getitem__(...)` 的参数。

### 2.4.2 切片的原理：切片对象`slice`
#### (1) 代码探索切片原理
&emsp;&emsp; 当我们对一个支持切片的变量`obj`进行切片时(如`obj[1:6`])，系统就能返回位置`1 - 6`之间的元素呢？它里面是怎么实现的呢？我们先来看看一段简单的代码，`MySeq.__getitem__()`直接将收到参数返回：
```python
class MySeq:
    def __getitem__(self, index):
        return index  # 直接将收到参数返回  

s = MySeq()

# ① 
print(f"① s[1] : {s[1]}\n")

# ② 
print(f"② type(s[1:4])  : {type(s[1:4])}" )
print(f"  s[1:4])       : {s[1:4]}\n" )
# ③ 
print(f"③ s[1:4:2]      : {s[1:4:2]}\n")
# ④ 
print(f"④ s[1:4:2, 9]   : {s[1:4:2, 9]}\n")
# ⑤
print(f"⑤ s[1:4:2, 7:9] : {s[1:4:2, 7:9]}")
```
运行结果：
```
① s[1] : 1

② type(s[1:4])  : <class 'slice'>
  s[1:4])       : slice(1, 4, None)

③ s[1:4:2]      : slice(1, 4, 2)

④ s[1:4:2, 9]   : (slice(1, 4, 2), 9)

⑤ s[1:4:2, 7:9] : (slice(1, 4, 2), slice(7, 9, None))
```
**结果分析：**
&emsp;&emsp; ① 直接返回传给它的值(即`100`)；
&emsp;&emsp; ②  `1:4` 表示法变成了 `slice(1, 4, None)`，而且`slice`是一个类；
&emsp;&emsp; ③ `slice(1, 4, 2)` 的意思是从 `1` 开始， 到 `4` 结束， 步幅为 `2`
&emsp;&emsp; ④ 神奇的事发生了： 如果 `[]` 中有逗号， 那么 `__getitem__`收到的是元组
&emsp;&emsp; ⑤  元组中甚至可以有多个切片对象，结果为多个`slice()`组成的元组。
通过查看`slice`类的源码，发现它有 `start`、 `stop` 和 `step` 数据属性，分别对应着切片的起点、终点和步长。

#### (2) 总结
&emsp;&emsp; 通过前面的代码，我们可以得到下面的结论，切片也是通过`__getitem__()`来实现的，并且，对于切片`s[1:4:2]`，解释器在后台做了如下几个工作：
> ① 先把`1:4:2`转换为`slice(1,4,2)`，即 `s[1:4:2]` --> `s[slice(1,4,2)]`
> ② 然后`__getitem__()`收到参数`slice(1,4,2)`
> 

### 2.4.3 为`Vector`类实现更完美的切片
刚刚已经验证过切片的原理了，现在我们可以把`Vector`的序列协议改成如下：
```python
class Vector:
    typecode = 'd'

    def __init__(self, components):
        self._components = array(self.typecode, components)

    def __len__(self):
        return len(self._components)
    def __getitem__(self, index):
        cls = type(self) 
        # 情况1：index参数是一个切片类型(即slice)
        if isinstance(index, slice): 
            # 转换为Vector 后再返回
            return cls(self._components[index]) 
        # 情况二：index参数是整形，说明是顺序访问
        elif isinstance(index, numbers.Integral): 
            return self._components[index] 
        #  情况三：抛异常
        else:
            msg = '{cls.__name__} indices must be integers'
            raise TypeError(msg.format(cls=cls))
```

### 2.4.4 切片总结
&emsp;&emsp; (1) 切片其实也是通过调用`__getitem__()`来实现的，只不过 序列访问传过去的是`int`，切片传过去的是一个切片对象`slice(start, end, stride)`。
&emsp;&emsp; (2) 如果想实现更完美的切片，可以在`__getitem__()`函数里面用 `isinstance()`来判断参数的类型，如果实参是`int`，那就是访问序列，如果是`slice()`对象，那就是切片



