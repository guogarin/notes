# 1. 类基础
## 1.1 `__init__()`
### (1) `__init__()`的作用是？
&emsp;&emsp; 不是，`__init__()`负责的是初始化数据成员。
### (2) `__init__()`的第一个参数`self`代表的是什么？
&emsp;&emsp; `self`，表示创建的实例本身，而不是类。因此，在`__init__`方法内部，就可以把各种属性绑定到`self`，因为`self`就指向创建的实例本身。
### (3) `__init__()`是构造函数吗？
&emsp;&emsp; 不是，`__init__()`只负责初始化成员，不负责构造对象。具体谁是python类的构造函数，可以看本文后面的笔记。

&emsp;
## 1.2 类的方法
&emsp;&emsp; 在类的内部，使用 def 关键字来定义一个方法，与一般函数定义不同，**类方法必须包含参数 `self`, 且为第一个**参数，self 代表的是类的实例。

&emsp;
## 1.3 类变量
### (1) 什么是类变量？
&emsp;&emsp; 类变量在整个实例化的对象中是公用的。类变量定义在类中且在函数，和C++类的静态成员变量作用一样。
### (2) 如何定义、使用类变量？
&emsp;&emsp; 如果希望一个变量被 所有该类的实例 共享，就将其定义成一个**类变量**，类变量定义在类中且在函数体的外面，使用的时候的语法为`class_name.member`，来看一个例子：
```python
class Employee(object):
    count = 0
    def __init__(self, name, salary):
        self.name = name
        self.salary = salary
        Employee.count += 1 # 使用的时候要加通过类名

print(Employee.count)
emp_1 = Employee('jack', '8000')
print(Employee.count)
emp_2 = Employee('jack', '10000')
print(Employee.count)
```
运行结果：
```
0
1
2
```
可以看到的是，`Employee.count`是在所有`Employee`对象之间共享的。

&emsp;
## 1.4 





&emsp;
&emsp; 
# 2. 访问控制
&emsp;&emsp; 对于公有成员，外面可以随意访问，还能对公有成员变量进行修改，但是一些变量和方法我们可能并不希望用户可以从外部访问，此时就需要进行访问控制。
## 2.1 python有几种访问级别？
&emsp;&emsp; python类的属性只有两种访问级别，也就是`public`和`private`。

## 2.2 私有成员(private)
### 2.2.1 如何声明私有成员？
在变量名前面加上双下划线`__`即可，如`__name`就是一个私有变量。
```python
class MyClass(object):
    def __init__(self):
        # public
        self.name = "MyClass" # public变量
        self.__age = 10       # private变量

    def method_publicted(self): # 一般类方法 public
        print("call public function")

    def __method_private(self): # 私有类方法 private
        print("call private function")

    def call_method_inClass(self):#类内访问public，protected，private方法
        self.method_publicted()
        self.__method_private()
        return

obj.method_publicted()  # 类外直接访问public方法，ok

obj.__method_private() # 类外不允许直接访问private方法，会抛异常
```
运行结果：
```
call public function
Traceback (most recent call last):
  File "d:\code_practice\practice.py", line 27, in <module>
    obj.__method_private() # 类外不允许直接访问private方法，会抛异常
AttributeError: 'MyClass' object has no attribute '__method_private'
```
再来访问一下类成员：
```python
print(obj.name) 
print(obj.__age)
```
运行结果：
```
MyClass
Traceback (most recent call last):
  File "d:\code_practice\practice.py", line 34, in <module>
    print(obj.__age)
AttributeError: 'MyClass' object has no attribute '__age'
```
**结果分析：**
&emsp;&emsp; 可以看到的是，不论是成员变量还是成员函数，只要带有`__`就是私有的，不能直接访问，想要访问只能在类的内部。

### 2.2.2 为什么说python中没有真正意义上的私有成员？
&emsp;&emsp; 因为python的private属性是通过变换属性名称实现的，如果知道了python类的名称变换规则，那用户就可以在任何一个类实例中对其进行访问，而这个类的变换规则是统一的，这个规则被称为 **名称转写(name mangling)**：
> 以双下划线开头，并以最多一个下划线结尾的标识符，例如`__mem`，会被转写为`_classname__mem`，其中`classname`为类名。
> 
这个机制实现起来非常简单，而且很大程度避免了调用者的误访问，但并不能像Java和C++的private限定符那样完全杜绝外部的访问。我们以代码直观展示：
```python
# MyClass类的定义同上
obj = MyClass()
print(obj._MyClass__age)
```
运行结果：
```
10
```
**结果分析：**
&emsp;&emsp; 可以看到，通过这个规则确实可以访问到python类的私有变量。

&emsp;
## 2.3 python的访问控制和C++的访问控制有何区别和联系？
&emsp;&emsp; C++是通过访问控制符`public、protected、private`来进行访问控制的，但在python中是通过在成员(方法)前面加下划线来进行访问控制的：
| C++         | python                                                    | 何处可见             |
| ----------- | --------------------------------------------------------- | -------------------- |
| `public`    | **没有**以下划线开头的变量或者方法，如：`value、func()`   | 本类内、子类内、类外 |
| `protected` | python没有`protected`                                     | 本类内、子类内       |
| `private`   | 以**双**下划线开头的变量或者方法，如：`__value、__func()` | 本类内               |

&emsp;
## 2.4 那些以双下划线开头，并以双下划线结尾的方法是什么？
&emsp;&emsp; Python中存在一些特殊的方法，有些方法以双下划线 `__`开头和结尾，它们是Python的魔法函数，比如`__init__()`和`__str__`等等。不用要这种方式命名自己的变量或者函数。

&emsp;
## 2.5 单下划线`_` 和 python类 
### 2.5.1 类名 以单下划线`_` 开头
当类名以单下划线`_` 开头时，它和普通的类**只有一个区别**：
> 不能用`from module import *` 导入，只能被显式导入。
> 
现有两个文件`test.py`和`main.py`：
`test.py`定义了两个类，代码如下：
```python
class A:
    def __init__(self):
        self.name = 'A'

# 类 _B 是以单下划线开头
class _B:
    def __init__(self):
        self.name = 'B'
```
`main.py`使用`import *`导入：
```python
from test import *

a = A()
print(a.name)
b = _B()
print(b.name)
```
运行`main.py`，报错如下：
```
A
Traceback (most recent call last):
  File "d:\code_practice\practice.py", line 5, in <module>
    b = B()
NameError: name 'B' is not defined
```
**结果分析：**
&emsp;&emsp; 显然，类`A`成功的被导入，而以下划线开头的类`_B`却导入失败，我们修改一下`main.py`的代码：
```python
from test import A, _B

a = A()
print(a.name)
b = _B()
print(b.name)
```
再次运行`main.py`，结果如下：
```
A
B
```
运行结果证明，以单下划线`_`开头的类，不能用`from module import *` 导入，只能被显式导入。

### 2.5.2 类的方法、变量 以 单下划线`_`开头
&emsp;&emsp; 当涉及到 类的变量和方法名称时，单个下划线前缀`_`有一个约定俗成的含义。 单下划线前缀的含义是告知其他程序员：以单个下划线开头的变量或方法仅供内部使用。 该约定在PEP 8中有定义，但这不是Python强制规定的，而更像一个 君子协议。
&emsp;&emsp; 既然是君子协议，那就意味着 全靠自觉，但是你要是强行访问的话，编译器也不会拦着，来看代码：
```python
class test:
    def __init__(self):
        self.name = 'Maria'
        self._age = '28'

    def _get_age(self):
        return self._age


obj = test()
print(obj._get_age())
print(f'{obj.name} is {obj._age}')
```
运行结果：
```
28
Maria is 28
```
**结果分析：**
&emsp;&emsp; 显然，用户可以对以 单下划线`_`开头的 变量和方法 自由的访问。




&emsp;
&emsp; 
# 3. 继承


https://blog.csdn.net/qq_27828675/article/details/79358893


## `super`

&emsp;
&emsp; 
# 4.高级
## 4.1 python的构造函数

&emsp;&emsp; `__init__()`不是构造函数，因为构造函数需要完成两项工作：
> ① 创建对象；
> ② 对新对象进行初始化；
> 
而`__init__`只负责初始化，不负责创建对象。
**那么哪个才是python中类的构造函数呢？**
&emsp;&emsp; 在python中，负责分配对象的方法是`__new__()`，但`__new__`是构造函数吗？答案是否定的，因为`__new__`只负责分配，不负责初始化。**准确的说，`__new__()` + `__init__` 才是 python的构造函数**，它们的各自的工作是：
> **`__new__()`**：分配对象并将其返回；
> **`__init__`** ：初始化`__new__()`返回的对象
> 

#### (2) `__new__()` 和 `__init__` 什么时候被调用？

```python
class Employee:
    def __new__(cls, *args, **kwargs):
        print("In __new__.")
        instance = object.__new__(cls, *args, **kwargs)
        return instance

    def __init__(self, name, salary):
        print("In __init__().")
        self.name = name
        self.salary = salary


emp = Employee('jack', '8000')
```
输出为：
```

```

## 析构函数

## python的魔术方法

### 自己定义魔术方法