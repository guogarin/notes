# 1. 如何实现三元表达式？
```python
args = [0, 1, 2]

reslut_0 = args[0] if (args[0] == 0) else 100
reslut_1 = args[1] if (args[1] == 0) else 99

print(f'reslut_0:{reslut_0}')
print(f'reslut_1:{reslut_1}')
```
运行结果：
```
reslut_0:0
reslut_1:99
```
`reslut_0 = args[0] if (args[0] == 0) else 100`其实相当于：
```python
if args[0] == 0:
    reslut_0 = args[0]
else:
    reslut_0 = 100
```



&emsp;
&emsp;
# 2. python中如何交换两个变量的值？
直接用**解包(unpacking)**就能做到，不需要用临时变量：
```python
def bubble_sort_by_tmp(a):
    for _ in range(len(a)):
        for i in range(1, len(a)):
            if a[i] < a[i-1]:
                temp = a[i]
                a[i] = a[i-1]
                a[i-1] = temp


def bubble_sort_by_unpacking(a):
    for _ in range(len(a)):
        for i in range(1, len(a)):
            if a[i] < a[i-1]:
                a[i-1], a[i] = a[i], a[i-1] # 不需要像        


names = ['pretzels', 'carrots', 'arugula', 'bacon']
bubble_sort_by_unpacking(names)
print(names)         
```
**用 解包(unpacking) 交换两个变量的值的原理是？**
&emsp;&emsp; Python在处理赋值操作时，首先处理的是`=`右侧的值，于是它会新建一个临时元组，例如在上面的`bubble_sort_by_unpacking()`中，第一次进入内部的`for`循环时，这`a[i-1], a[i]`分别是`'pretzels', 'carrots'`，于是，系统会创建出`('pretzels', 'carrots')`这样的元组，，然后Python会对这个临时元组进行`unpacking`操作。



&emsp;
&emsp;
# 3. 介绍一下python的`解包(unpacking)`机制
## 3.1 什么是`解包(unpacking)`？
&emsp;&emsp; 解包在英文里叫做 Unpacking，就是将容器里面的元素逐个取出来，然后赋给新变量，元组、列表、字典，甚至字符串都支持解包操作：
**① 元组解包**
```python
tp = ("Jack", 26)
name, age = tp
print(f'{name} is {age} years old.')
```
运行结果：
```
Jack is 26 years old.
```

**② 列表解包**
```python
>>> a, b, c = [1,2,3]
>>> a
# 1
>>> b
# 2
>>> c
# 3
```

**③ 字典解包**
```python
>>> a,b,c = {"a":1, "b":2, "c":3}
>>> a
# 'a'
>>> b
# 'b'
>>> c
# 'c'
```
字典解包后，只会把字典的 key 取出来，value 则丢掉了

**④ 字符串解包**
```python
>>> a,b,c = "abc"
>>> a
# 'a'
>>> b
# 'b'
>>> c
# 'c'
```

## 3.2 将容器解包后赋予新的变量，这个新的变量被修改后，容器里面的元素会被修改吗？
不会，它们是独立的：
```python
tp = ("Jack", 26)
name, age = tp
print(f'{name} is {age} years old.')

age = 100
print(tp)
```
运行结果：
```
Jack is 26 years old.
('Jack', 26)
```

## 3.3 如何理解`a, *b, c = [1,2,3,4]` ？
```python
a, *b, c = [1,2,3,4,5]
print(f'a: {a}')
print(f'b: {b}')
print(f'c: {c}')
```
运行结果：
```
a: 1
b: [2, 3, 4]
c: 5
```
这个其实就是在某个变量面前加一个星号`*`，而且这个星号可以放在任意变量，每个变量都分配一个元素后，**剩下的元素都分配给这个带星号`*`的变量**。
如果你想取 **前两个变量**：
```python
a, b, *c = [1,2,3,4,5] # 星号给了 变量c
print(f'a: {a}')
print(f'b: {b}')
print(f'c: {c}')
```
运行结果：
```
a: 1
b: 2
c: [3, 4, 5]
```

## 3.4 应用
.TODO: item 6、13、19、22、23、27



&emsp;
&emsp;
# 4. 介绍下`enumerate`函数
## 4.1 `enumerate`函数 的作用是？
`enumerate`函数 能把任何一种迭代器封装成 惰性迭代器(lazy iterator)，这样在每次循环的时候，只需从iterator中取下一个值即可，而且还会给出本轮循环的序号(从0开始计数)：
```python
snacks = [('bacon', 350), ('donut', 240), ('muffin', 190)]

for i  in enumerate(snacks):
    print(i)
```
输出结果为：
```
(0, ('bacon', 350))
(1, ('donut', 240))
(2, ('muffin', 190))
```
可以看到的是，`enumerate`函数 返回了一个元组，元组里面包含的是(`序号`, `snacks的元素`)；

## 4.2 `enumerate`函数返回的循环序号 可以自定义吗？
可以的，通过指定`start`参数可以做到，即`enumerate(snacks, start=1)`：
```python
snacks = [('bacon', 350), ('donut', 240), ('muffin', 190)]

for i  in enumerate(snacks, 1): # 指定 start参数为1
    print(i)
```
输出结果为：
```
(1, ('bacon', 350))
(2, ('donut', 240))
(3, ('muffin', 190))
```
可以看到的是，编号从`1`开始了。

## 4.3 `enumerate`函数 的应用
`enumerate`函数 需要配合 `解包(unpacking)`机制 来使用：
```python
snacks = [('bacon', 350), ('donut', 240), ('muffin', 190)]

for rank, (name, calories) in enumerate(snacks, 1):
    print(f'#{rank} : {name.title()} has {calories} calories.')
```
输出结果为：
```
#1 : Bacon has 350 calories.
#2 : Donut has 240 calories.
#3 : Muffin has 190 calories.
```



&emsp;
&emsp;
# 5. `zip()`函数
## 5.1 `zip()`函数 的作用是？工作原理是？
### 5.1.1 (1) 作用
&emsp;&emsp; `zip()` 函数是 Python 内置函数，它可以将多个序列（包括：列表、元组、字典、集合、字符串以及 range() 区间构成的列表）“压缩”成一个 zip 对象。
### 5.1.2 工作原理
&emsp;&emsp; **所谓“压缩”**，其实就是将这些序列中对应位置的元素重新组合，生成一个个新的**元组**。我们来看下面的例子：
```python
my_list = [11,12,13]
my_tuple = (21,22,23)
print([x for x in zip(my_list,my_tuple)])
```
输出为：
```
[(11, 21), (12, 22), (13, 23)]
```
`zip()`在每次循环的时候，会分别从`my_list`、`my_tuple`中取一个元素，然后将这两个元素封装成一个元组，因为这两个容器都是有3个元素，这三次循环产生的元组为：
> 第一次循环：(11, 21)
> 第二次循环：(12, 22)
> 第三次循环：(13, 23)
> 

## 5.2 如何使用？
```python
my_list = [11,12,13]
my_tuple = (21,22,23)
print([x for x in zip(my_list,my_tuple)])

my_dic = {31:2,32:4,33:5}
my_set = {41,42,43,44}
print([x for x in zip(my_dic,my_set)])
```
运行结果：
```
[(11, 21), (12, 22), (13, 23)]
[(31, 41), (32, 42), (33, 43)]
```
**分析以上的程序和相应的输出结果不难发现**：
> 在使用 zip() 函数“压缩”多个序列时，它会分别取各序列中第 1 个元素、第 2 个元素、... 第 n 个元素，各自组成新的元组。
> 

## 5.3 对字典使用zip()会发生什么？
只会取`key`的值，`value`被忽略了：
```python
my_dic = {31 : 2,32 : 4,33 : 5}
my_set = {41,42,43,44}
print([x for x in zip(my_dic,my_set)])
```
运行结果：
```
[(31, 41), (32, 42), (33, 43)]
```

## 5.4 如果传给zip()的两个序列长度不一样会发生什么？
&emsp;&emsp; 先说结论：**当多个序列中元素个数不一致时，会以最短的序列为准进行压缩。** 我们来实验一下：
```python
list_1 = {1, 2, 3}
list_2 = {1, 2, 3, 4} # 这个要长一点
print([x for x in zip(list_1, list_2)])
```
运行结果：
```
[(1, 1), (2, 2), (3, 3)]
```
我们发现，`list_2`的第四个元素被忽略了，也验证了`zip()`在压缩的时候会以 最短的序列为准的结论。

## 5.5 如果希望在 压缩(zip) 的时候，以最长的序列为准，应该怎么做？
应该使用`zip_longest()`，它位于 `itertools`模块中：
```python
import itertools

list_1 = {1, 2, 3}
list_2 = {1, 2, 3, 4} # 这个要长一点
print([x for x in itertools.zip_longest(list_1, list_2)])
```
运行结果：
```
[(1, 1), (2, 2), (3, 3), (None, 4)]
```

## 5.6 如果列表很长，zip()会因为 内存占用过多 而崩溃？
不会的，因为`zip()`每次只会从它封装的迭代器中取一个元素，所以占用内存很少。



&emsp;
&emsp;
# 6. `while`和`for`循环 后面的`else`语句块什么时候会运行？
&emsp;&emsp; 无论是`for … else` 还是 `while … else`，`else`中的语句 会在循环 **正常执行完**（即 `for(while)` 不是通过 `break` 跳出而中断的）的情况下执行：
&emsp;&emsp; 换句话说，如果  `while … else`，`else`中的语句 **不是正常执行完**，如通过`break`跳出了循环，则`else`中的语句不会被执行
```python
# 1. 正常执行
for i in range(3):
    print(i)
else:
    print("else block!")

print("*"*30)

# 通过break让循环体 不正常执行完
for i in range(3):
    if(i >= 2):
        break
    print(i)
else:
    print("else block!")
```
运行结果：
```
0
1
2
else block!
******************************
0
1
```

## 结论
&emsp;&emsp; 如果  `while … else`，`else`中的语句 **不是正常执行完**，如通过`break`跳出了循环，则`else`中的语句不会被执行。



&emsp;
&emsp;
# 7. 赋值表达式(assignment expression)
## 7.1 什么是 赋值表达式？语法特点是
&emsp;&emsp; **赋值表达式** 是在 python3.8中加入的新特性，它会用到 **海象操作符(walrus operator)** 。
赋值表达式的语法是 `NAME := expr`，顾名思义，它完成了两个操作：
> ① 计算表达式 `expr` 的结果，然后把结果赋值给名为 `NAME` 的变量
> ② 返回`NAME`变量
> 
```python
walrus = False
print(tmp := walrus)
```
输出结果：
```
False
```
可见 `print(walrus := True)` 一句话，做了两句话的工作：
> ① 赋值：`walrus = True`
> ② 将`walrus`返回给`print`：`print(walrus)`
> 

## 7.2 赋值表达式 和 赋值语句 有何区别？
&emsp;&emsp; 赋值表达式 和 赋值语句的区别在于：**赋值表达式 在完成赋值之后，还会将`:=`左边的变量作为一个返回值返回。**

```python
walrus = False
print(tmp := walrus)

print(tmp = walrus)
```
运行结果：
```
False
Traceback (most recent call last):
  File "d:\code_practice\practice.py", line 4, in <module>
    print(tmp = walrus)
TypeError: 'tmp' is an invalid keyword argument for print()
```

## 7.3 应用
&emsp;&emsp; 有了赋值表达式，可以节省代码量，还可以 清晰的模拟出`switch`和`do ... while`语句。
### (1) 在`if/else`中
#### ① 
```python
fresh_fruit = {
    'apple': 10,
    'banana': 8,
    'lemon': 5,
}

def make_lemonade(count):
    print("make_lemonade()")

def out_of_stock():
    print("out_of_stock()")

# 以前的写法：    
count = fresh_fruit.get('lemon', 0)
if count:
    make_lemonade(count)
else:
    out_of_stock()

# 有了 赋值表达式后的写法
if count := fresh_fruit.get('lemon', 0) :
    make_lemonade(count)
else:
    out_of_stock()
```
用赋值表达式写的代码虽然只是少了一行，但是读起来却清晰了不少，因为这种写法明确的表示了`count`变量只和`if/else`有关。
#### ② 用来实现`switch`
```python
fresh_fruit = {
    'apple': 10,
    'banana': 8,
    'lemon': 5,
}

def slice_bananas(count):
    print("slice_bananas")


def make_lemonade(count):
    print("make_lemonade()")

def make_smoothies(count):
    print("make_smoothies()")

def make_cider(count):
    print("make_cider()")

count = fresh_fruit.get('banana', 0)
if count >= 2:
    pieces = slice_bananas(count)
    to_enjoy = make_smoothies(pieces)
else:
    count = fresh_fruit.get('apple', 0)
    if count >= 4:
        to_enjoy = make_cider(count)
    else:
        count = fresh_fruit.get('lemon', 0)
        if count:
            to_enjoy = make_lemonade(count)
        else:
            to_enjoy = 'Nothing'

if (count := fresh_fruit.get('banana', 0)) >= 2:
    pieces = slice_bananas(count)
    to_enjoy = make_smoothies(pieces)
elif (count := fresh_fruit.get('apple', 0)) >= 4:
    to_enjoy = make_cider(count)
elif count := fresh_fruit.get('lemon', 0):
    to_enjoy = make_lemonade(count)
else:
    to_enjoy = 'Nothing'
```
上面的代码虽然实现了`switch`的功能，但是可读性太差了，来看看 赋值表达式 模拟`switch`语句：
```python
if (count := fresh_fruit.get('banana', 0)) >= 2:
    pieces = slice_bananas(count)
    to_enjoy = make_smoothies(pieces)
elif (count := fresh_fruit.get('apple', 0)) >= 4:
    to_enjoy = make_cider(count)
elif count := fresh_fruit.get('lemon', 0):
    to_enjoy = make_lemonade(count)
else:
    to_enjoy = 'Nothing'
```
很显然，不论是代码量还是可读性，用 赋值表达式 来实现都更完美。

### (2) 实现`do while`语句
&emsp;&emsp; python里面是没有`do ... while`语句的。如果我们希望把新引入的水果做成果汁并存到瓶子里，直到水果用完为止：
**① 普通循环：**
```python
def pick_fruit():
    print("pick_fruit()")

def make_juice(fruit, count):
    print("make_juice")

bottles = []
while True: # Loop
    fresh_fruit = pick_fruit()
    if not fresh_fruit: # And a half
        break
    for fruit, count in fresh_fruit.items():
        batch = make_juice(fruit, count)
        bottles.extend(batch)
```
上面的代码写成了无限循环，需要依靠`break`才能退出循环。
**② 赋值表达式实现：**
&emsp;&emsp; 用海象操作符，我们可以在每一次`while`循环的开始给`fresh_fruit`变量赋值，并根据返回值决定是否进行下一轮赋值，这样写可读性显然更好：
```python
bottles = []
while fresh_fruit := pick_fruit():
    for fruit, count in fresh_fruit.items():
        batch = make_juice(fruit, count)
        bottles.extend(batch)
```

### (3) 用在 推导式 中
```python
members = [
    {"name": "小五", "age": 23, "height": 1.75, "weight": 72},
    {"name": "小李", "age": 17, "height": 1.72, "weight": 63},
    {"name": "小陈", "age": 20, "height": 1.78, "weight": 82},
]

count = 0

def get_bmi(info):
    global count
    count += 1

    print(f"执行了 {count} 次")

    height = info["height"]
    weight = info["weight"]

    return weight / (height**2)

print([get_bmi(x) for x in members if get_bmi(x) > 25])
```
运行结果：
```
执行了 1 次
执行了 2 次        
执行了 3 次        
执行了 4 次        
[25.88057063502083]
```
使用 赋值表达式 修改上述列表推导：
```python
print([bmi for x in members if (bmi:=get_bmi(x)) > 25])
```
运行结果：
```
执行了 1 次
执行了 2 次        
执行了 3 次        
[25.88057063502083]
```
可以明显看到，代码简洁了，`get_bmi()`也调用少了一次。



&emsp;
&emsp;
# 7. 切片(slice sequences)
## 7.1  什么样的类可以进行切片操作？
&emsp;&emsp; 实现了 `__getitem__ `and `__setitem__` 的类都可以进行切片操作。

## 7.2 如何为自定义的类提供 切片操作？
item 43 TODO:

## 7.3 进行切片操作时应该秉承什么样的原则？
