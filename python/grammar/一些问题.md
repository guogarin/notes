# 1. 如何实现三元表达式？
```python
args = [0, 1, 2]

reslut_0 = args[0] if (args[0] == 0) else 100
reslut_1 = args[1] if (args[1] == 0) else 99

print(f'reslut_0:{reslut_0}')
print(f'reslut_1:{reslut_1}')
```
运行结果：
```
reslut_0:0
reslut_1:99
```
`reslut_0 = args[0] if (args[0] == 0) else 100`其实相当于：
```python
if args[0] == 0:
    reslut_0 = args[0]
else:
    reslut_0 = 100
```



&emsp;
&emsp;
# 2. python中如何交换两个变量的值？
直接用**解包(unpacking)**就能做到，不需要用临时变量：
```python
def bubble_sort_by_tmp(a):
    for _ in range(len(a)):
        for i in range(1, len(a)):
            if a[i] < a[i-1]:
                temp = a[i]
                a[i] = a[i-1]
                a[i-1] = temp


def bubble_sort_by_unpacking(a):
    for _ in range(len(a)):
        for i in range(1, len(a)):
            if a[i] < a[i-1]:
                a[i-1], a[i] = a[i], a[i-1] # 不需要像        


names = ['pretzels', 'carrots', 'arugula', 'bacon']
bubble_sort_by_unpacking(names)
print(names)         
```
**用 解包(unpacking) 交换两个变量的值的原理是？**
&emsp;&emsp; Python在处理赋值操作时，首先处理的是`=`右侧的值，于是它会新建一个临时元组，例如在上面的`bubble_sort_by_unpacking()`中，第一次进入内部的`for`循环时，这`a[i-1], a[i]`分别是`'pretzels', 'carrots'`，于是，系统会创建出`('pretzels', 'carrots')`这样的元组，，然后Python会对这个临时元组进行`unpacking`操作。



&emsp;
&emsp;
# 3. 介绍一下python的`解包(unpacking)`机制
## 3.1 什么是`解包(unpacking)`？
&emsp;&emsp; 解包在英文里叫做 Unpacking，就是将容器里面的元素逐个取出来，然后赋给新变量，元组、列表、字典，甚至字符串都支持解包操作：
**① 元组解包**
```python
tp = ("Jack", 26)
name, age = tp
print(f'{name} is {age} years old.')
```
运行结果：
```
Jack is 26 years old.
```

**② 列表解包**
```python
>>> a, b, c = [1,2,3]
>>> a
# 1
>>> b
# 2
>>> c
# 3
```

**③ 字典解包**
```python
>>> a,b,c = {"a":1, "b":2, "c":3}
>>> a
# 'a'
>>> b
# 'b'
>>> c
# 'c'
```
字典解包后，只会把字典的 key 取出来，value 则丢掉了

**④ 字符串解包**
```python
>>> a,b,c = "abc"
>>> a
# 'a'
>>> b
# 'b'
>>> c
# 'c'
```

## 3.2 将容器解包后赋予新的变量，这个新的变量被修改后，容器里面的元素会被修改吗？
不会，它们是独立的：
```python
tp = ("Jack", 26)
name, age = tp
print(f'{name} is {age} years old.')

age = 100
print(tp)
```
运行结果：
```
Jack is 26 years old.
('Jack', 26)
```

## 3.3 如何理解`a, *b, c = [1,2,3,4]` ？
```python
a, *b, c = [1,2,3,4,5]
print(f'a: {a}')
print(f'b: {b}')
print(f'c: {c}')
```
运行结果：
```
a: 1
b: [2, 3, 4]
c: 5
```
这个其实就是在某个变量面前加一个星号`*`，而且这个星号可以放在任意变量，每个变量都分配一个元素后，**剩下的元素都分配给这个带星号`*`的变量**。
如果你想取 **前两个变量**：
```python
a, b, *c = [1,2,3,4,5] # 星号给了 变量c
print(f'a: {a}')
print(f'b: {b}')
print(f'c: {c}')
```
运行结果：
```
a: 1
b: 2
c: [3, 4, 5]
```

## 3.4 带星号的表达式(starred expression)
### 3.4.1 什么是  带星号的表达式
下面的`*others`就属于带星号的表达式
```python
car_ages = [0, 9, 4, 8, 7, 20, 19, 1, 6, 15]
frist, *others = car_ages
```
### 3.4.2 使用带星号表达式时需要注意什么？
必须搭配一个普通变量使用：
```python
car_ages = [0, 9, 4, 8, 7, 20, 19, 1, 6, 15]
*all = car_ages
```
运行结果：
```
  File "d:\code_practice\practice.py", line 2
    *all = car_ages
    ^^^^
SyntaxError: starred assignment target must be in a list or tuple
```
### 3.4.3 当要拆分的序列里已经没有元素留给 带星号表达式 时 会发生什么？
带星号表达式 会得到一个空列表：
```python
car_ages = [0, 1]
first, second, *others = car_ages
print(first, second, others)
```
运行结果：
```
0 1 []
```

## 应用
.TODO: item 6、13、19、22、23、27



&emsp;
&emsp;
# 4. 介绍下`enumerate`函数
## 4.1 `enumerate`函数 的作用是？
`enumerate`函数 能把任何一种迭代器封装成 惰性迭代器(lazy iterator)，这样在每次循环的时候，只需从iterator中取下一个值即可，而且还会给出本轮循环的序号(从0开始计数)：
```python
snacks = [('bacon', 350), ('donut', 240), ('muffin', 190)]

for i  in enumerate(snacks):
    print(i)
```
输出结果为：
```
(0, ('bacon', 350))
(1, ('donut', 240))
(2, ('muffin', 190))
```
可以看到的是，`enumerate`函数 返回了一个元组，元组里面包含的是(`序号`, `snacks的元素`)；

## 4.2 `enumerate`函数返回的循环序号 可以自定义吗？
可以的，通过指定`start`参数可以做到，即`enumerate(snacks, start=1)`：
```python
snacks = [('bacon', 350), ('donut', 240), ('muffin', 190)]

for i  in enumerate(snacks, 1): # 指定 start参数为1
    print(i)
```
输出结果为：
```
(1, ('bacon', 350))
(2, ('donut', 240))
(3, ('muffin', 190))
```
可以看到的是，编号从`1`开始了。

## 4.3 `enumerate`函数 的应用
`enumerate`函数 需要配合 `解包(unpacking)`机制 来使用：
```python
snacks = [('bacon', 350), ('donut', 240), ('muffin', 190)]

for rank, (name, calories) in enumerate(snacks, 1):
    print(f'#{rank} : {name.title()} has {calories} calories.')
```
输出结果为：
```
#1 : Bacon has 350 calories.
#2 : Donut has 240 calories.
#3 : Muffin has 190 calories.
```





&emsp;
&emsp;
&emsp;
# 5. `zip()`函数
## 5.1 `zip()`函数 的作用是？工作原理是？
### 5.1.1 (1) 作用
&emsp;&emsp; `zip()` 函数是 Python 内置函数，它可以将多个序列（包括：列表、元组、字典、集合、字符串以及 range() 区间构成的列表）“压缩”成一个 zip 对象。
### 5.1.2 工作原理
&emsp;&emsp; **所谓“压缩”**，其实就是将这些序列中对应位置的元素重新组合，生成一个个新的**元组**。我们来看下面的例子：
```python
my_list = [11,12,13]
my_tuple = (21,22,23)
print([x for x in zip(my_list,my_tuple)])
```
输出为：
```
[(11, 21), (12, 22), (13, 23)]
```
`zip()`在每次循环的时候，会分别从`my_list`、`my_tuple`中取一个元素，然后将这两个元素封装成一个元组，因为这两个容器都是有3个元素，这三次循环产生的元组为：
> 第一次循环：(11, 21)
> 第二次循环：(12, 22)
> 第三次循环：(13, 23)
> 

## 5.2 如何使用？
```python
my_list = [11,12,13]
my_tuple = (21,22,23)
print([x for x in zip(my_list,my_tuple)])

my_dic = {31:2,32:4,33:5}
my_set = {41,42,43,44}
print([x for x in zip(my_dic,my_set)])
```
运行结果：
```
[(11, 21), (12, 22), (13, 23)]
[(31, 41), (32, 42), (33, 43)]
```
**分析以上的程序和相应的输出结果不难发现**：
> 在使用 zip() 函数“压缩”多个序列时，它会分别取各序列中第 1 个元素、第 2 个元素、... 第 n 个元素，各自组成新的元组。
> 

## 5.3 对字典使用zip()会发生什么？
只会取`key`的值，`value`被忽略了：
```python
my_dic = {31 : 2,32 : 4,33 : 5}
my_set = {41,42,43,44}
print([x for x in zip(my_dic,my_set)])
```
运行结果：
```
[(31, 41), (32, 42), (33, 43)]
```

## 5.4 如果传给zip()的两个序列长度不一样会发生什么？
&emsp;&emsp; 先说结论：**当多个序列中元素个数不一致时，会以最短的序列为准进行压缩。** 我们来实验一下：
```python
list_1 = {1, 2, 3}
list_2 = {1, 2, 3, 4} # 这个要长一点
print([x for x in zip(list_1, list_2)])
```
运行结果：
```
[(1, 1), (2, 2), (3, 3)]
```
我们发现，`list_2`的第四个元素被忽略了，也验证了`zip()`在压缩的时候会以 最短的序列为准的结论。

## 5.5 如果希望在 压缩(zip) 的时候，以最长的序列为准，应该怎么做？
应该使用`zip_longest()`，它位于 `itertools`模块中：
```python
import itertools

list_1 = {1, 2, 3}
list_2 = {1, 2, 3, 4} # 这个要长一点
print([x for x in itertools.zip_longest(list_1, list_2)])
```
运行结果：
```
[(1, 1), (2, 2), (3, 3), (None, 4)]
```

## 5.6 如果列表很长，zip()会因为 内存占用过多 而崩溃？
不会的，因为`zip()`每次只会从它封装的迭代器中取一个元素，所以占用内存很少。



&emsp;
&emsp;
# 6. `while`和`for`循环 后面的`else`语句块什么时候会运行？
&emsp;&emsp; 无论是`for … else` 还是 `while … else`，`else`中的语句 会在循环 **正常执行完**（即 `for(while)` 不是通过 `break` 跳出而中断的）的情况下执行：
&emsp;&emsp; 换句话说，如果  `while … else`，`else`中的语句 **不是正常执行完**，如通过`break`跳出了循环，则`else`中的语句不会被执行
```python
# 1. 正常执行
for i in range(3):
    print(i)
else:
    print("else block!")

print("*"*30)

# 通过break让循环体 不正常执行完
for i in range(3):
    if(i >= 2):
        break
    print(i)
else:
    print("else block!")
```
运行结果：
```
0
1
2
else block!
******************************
0
1
```

## 结论
&emsp;&emsp; 如果  `while … else`，`else`中的语句 **不是正常执行完**，如通过`break`跳出了循环，则`else`中的语句不会被执行。



&emsp;
&emsp;
# 7. 赋值表达式(assignment expression)
## 7.1 什么是 赋值表达式？语法特点是
&emsp;&emsp; **赋值表达式** 是在 python3.8中加入的新特性，它会用到 **海象操作符(walrus operator)** 。
赋值表达式的语法是 `NAME := expr`，顾名思义，它完成了两个操作：
> ① 计算表达式 `expr` 的结果，然后把结果赋值给名为 `NAME` 的变量
> ② 返回`NAME`变量
> 
```python
walrus = False
print(tmp := walrus)
```
输出结果：
```
False
```
可见 `print(walrus := True)` 一句话，做了两句话的工作：
> ① 赋值：`walrus = True`
> ② 将`walrus`返回给`print`：`print(walrus)`
> 

## 7.2 赋值表达式 和 赋值语句 有何区别？
&emsp;&emsp; 赋值表达式 和 赋值语句的区别在于：**赋值表达式 在完成赋值之后，还会将`:=`左边的变量作为一个返回值返回。**

```python
walrus = False
print(tmp := walrus)

print(tmp = walrus)
```
运行结果：
```
False
Traceback (most recent call last):
  File "d:\code_practice\practice.py", line 4, in <module>
    print(tmp = walrus)
TypeError: 'tmp' is an invalid keyword argument for print()
```

## 7.3 应用
&emsp;&emsp; 有了赋值表达式，可以节省代码量，还可以 清晰的模拟出`switch`和`do ... while`语句。
### (1) 在`if/else`中
#### ① 
```python
fresh_fruit = {
    'apple': 10,
    'banana': 8,
    'lemon': 5,
}

def make_lemonade(count):
    print("make_lemonade()")

def out_of_stock():
    print("out_of_stock()")

# 以前的写法：    
count = fresh_fruit.get('lemon', 0)
if count:
    make_lemonade(count)
else:
    out_of_stock()

# 有了 赋值表达式后的写法
if count := fresh_fruit.get('lemon', 0) :
    make_lemonade(count)
else:
    out_of_stock()
```
用赋值表达式写的代码虽然只是少了一行，但是读起来却清晰了不少，因为这种写法明确的表示了`count`变量只和`if/else`有关。
#### ② 用来实现`switch`
```python
fresh_fruit = {
    'apple': 10,
    'banana': 8,
    'lemon': 5,
}

def slice_bananas(count):
    print("slice_bananas")


def make_lemonade(count):
    print("make_lemonade()")

def make_smoothies(count):
    print("make_smoothies()")

def make_cider(count):
    print("make_cider()")

count = fresh_fruit.get('banana', 0)
if count >= 2:
    pieces = slice_bananas(count)
    to_enjoy = make_smoothies(pieces)
else:
    count = fresh_fruit.get('apple', 0)
    if count >= 4:
        to_enjoy = make_cider(count)
    else:
        count = fresh_fruit.get('lemon', 0)
        if count:
            to_enjoy = make_lemonade(count)
        else:
            to_enjoy = 'Nothing'

if (count := fresh_fruit.get('banana', 0)) >= 2:
    pieces = slice_bananas(count)
    to_enjoy = make_smoothies(pieces)
elif (count := fresh_fruit.get('apple', 0)) >= 4:
    to_enjoy = make_cider(count)
elif count := fresh_fruit.get('lemon', 0):
    to_enjoy = make_lemonade(count)
else:
    to_enjoy = 'Nothing'
```
上面的代码虽然实现了`switch`的功能，但是可读性太差了，来看看 赋值表达式 模拟`switch`语句：
```python
if (count := fresh_fruit.get('banana', 0)) >= 2:
    pieces = slice_bananas(count)
    to_enjoy = make_smoothies(pieces)
elif (count := fresh_fruit.get('apple', 0)) >= 4:
    to_enjoy = make_cider(count)
elif count := fresh_fruit.get('lemon', 0):
    to_enjoy = make_lemonade(count)
else:
    to_enjoy = 'Nothing'
```
很显然，不论是代码量还是可读性，用 赋值表达式 来实现都更完美。

### (2) 实现`do while`语句
&emsp;&emsp; python里面是没有`do ... while`语句的。如果我们希望把新引入的水果做成果汁并存到瓶子里，直到水果用完为止：
**① 普通循环：**
```python
def pick_fruit():
    print("pick_fruit()")

def make_juice(fruit, count):
    print("make_juice")

bottles = []
while True: # Loop
    fresh_fruit = pick_fruit()
    if not fresh_fruit: # And a half
        break
    for fruit, count in fresh_fruit.items():
        batch = make_juice(fruit, count)
        bottles.extend(batch)
```
上面的代码写成了无限循环，需要依靠`break`才能退出循环。
**② 赋值表达式实现：**
&emsp;&emsp; 用海象操作符，我们可以在每一次`while`循环的开始给`fresh_fruit`变量赋值，并根据返回值决定是否进行下一轮赋值，这样写可读性显然更好：
```python
bottles = []
while fresh_fruit := pick_fruit():
    for fruit, count in fresh_fruit.items():
        batch = make_juice(fruit, count)
        bottles.extend(batch)
```

### (3) 用在 推导式 中
```python
members = [
    {"name": "小五", "age": 23, "height": 1.75, "weight": 72},
    {"name": "小李", "age": 17, "height": 1.72, "weight": 63},
    {"name": "小陈", "age": 20, "height": 1.78, "weight": 82},
]

count = 0

def get_bmi(info):
    global count
    count += 1

    print(f"执行了 {count} 次")

    height = info["height"]
    weight = info["weight"]

    return weight / (height**2)

print([get_bmi(x) for x in members if get_bmi(x) > 25])
```
运行结果：
```
执行了 1 次
执行了 2 次        
执行了 3 次        
执行了 4 次        
[25.88057063502083]
```
使用 赋值表达式 修改上述列表推导：
```python
print([bmi for x in members if (bmi:=get_bmi(x)) > 25])
```
运行结果：
```
执行了 1 次
执行了 2 次        
执行了 3 次        
[25.88057063502083]
```
可以明显看到，代码简洁了，`get_bmi()`也调用少了一次。



&emsp;
&emsp;
# 7. 切片(slice sequences)
## 7.1  什么样的类可以进行切片操作？
&emsp;&emsp; 实现了 `__getitem__ `and `__setitem__` 的类都可以进行切片操作。

## 7.2 切片 的时候如果下标越界会发生什么？
&emsp;&emsp; 切片 可以允许越界，如果起点和终点 超过了列表的边界，那么系统会自动忽略不存在的元素。

## 7.3 切割出来的列表 和 原列表 有何联系？
**切片 是 浅拷贝：**
```python
a = [0, 1, 2, ['a', 'b', 'c'], 4]
b = a[:]

if a == b :
    print("a == b")

a[0] = 'A' 		# 修改列表
a[3][0] = 100	# 修改子序列

print("a = ", a)
print("b = ", b)
```
运行结果：
```
a == b
a =  ['A', 1, 2, [100, 'b', 'c'], 4]
b =  [0, 1, 2, [100, 'b', 'c'], 4]
```
**结果分析：**
&emsp;&emsp; 运行结果显示，列表`a`的直接修改没有影响到列表`b`，但是对列表`a`的子序列的修改却影响到了`b`，这显然验证了 切片 是浅拷贝的结论。

## 7.4 进行切片操作时应该秉承什么样的原则？
&emsp;&emsp; 切片要尽可能写的简答，如果是从头开始切割，则应该省略左侧的下标`0`；如果是一直取到末尾，那就应该省略冒号右侧的下标
```python
numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

from_start = numbers[:4]
print(from_start)

print(to_end:=numbers[1:])
```
输出的结果：
```
[0, 1, 2, 3]
[1, 2, 3, 4, 5, 6, 7, 8, 9]
```

## 7.5 切片 出现在 赋值符号的左侧
&emsp;&emsp; 切片 可以出现在赋值符号的左侧，表示用 右侧那些元素 把原列表中位于这个范围之内的元素换掉。
&emsp;&emsp; 和`unpacking`机制不一样的是，切片 位于赋值符号左侧时不要求两边个数相等：
```python
numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

# 左侧 = 右侧
numbers[:2]=[9, 9]
print('左侧 = 右侧: ', numbers)

# 左侧 > 右侧
numbers[2:4]=[9]
print('左侧 > 右侧: ', numbers)

# 左侧 < 右侧
numbers[4:5]=[9, 9, 9]
print('左侧 < 右侧: ', numbers)
```
输出结果：
```
左侧 = 右侧:  [9, 9, 2, 3, 4, 5, 6, 7, 8, 9]
左侧 > 右侧:  [9, 9, 9, 4, 5, 6, 7, 8, 9]
左侧 < 右侧:  [9, 9, 9, 4, 9, 9, 9, 6, 7, 8, 9]
```
根据输出结果可以知道：
> 如果 左侧提供的长度 **>** 右侧提供的长度，则目标列表会变**短**
> 如果 左侧提供的长度 **<** 右侧提供的长度，则目标列表会变**长**
> 
其实这很好记，只要记住的是：
> 切片 可以出现在赋值符号的左侧，表示用 右侧那些元素 把 **原列表中位于这个范围之内** 的元素换掉。
> 
换句话说，就是我不管你左侧是有多少个元素，反正我就用右侧的元素将你替换掉。

## 7.6 指定 步长(stride)
&emsp;&emsp; 通过`somelist[start:end:stride]`的`stride`可以指定步长。
### 7.6.1 指定步长有哪些应用？
**① 取一个列表的奇数位 或 偶数位 的元素**
```python
numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
odd = numbers[1::2]
even = numbers[::2]
print(f"odd:  {odd}")
print(f"even: {even}")
```
输出：
```
odd:  [1, 3, 5, 7, 9]
even: [0, 2, 4, 6, 8]
```

**② 翻转列表**
```python
numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
reverse = [::-1]
print(f"reverse: {reverse}")
```
输出：
```
reverse: [9, 8, 7, 6, 5, 4, 3, 2, 1, 0]
```

## 如何为自定义的类提供 切片操作？
item 43 TODO:





&emsp;
&emsp;
# 8. Python中对象
## 8.1 Python的对象有哪几个属性？
Python中，对象具有三要素：
> ① 标识(identity)
> ② 类型(type)
> ③ 值(value)
> 

## 8.2 这些属性分别表示什么？如何获取这几个属性？
**① 标识(identity)：**
&emsp;&emsp; 用于唯一标识对象，通常对应对象在计算机内存中的地址。使用内置函数`id(obj)`返回对象唯一标识。

**② 类型(type)：**
&emsp;&emsp; 对象中含有标准的头部信息：类型标识符。标识对象类型，表示对象存储的数据的类型。
&emsp;&emsp; 类型可以限制对象的取值范围和可执行的操作。使用内置函数`type(obj)`返回对象所属类型。
每一个对象都有两个标准的头部信息：
>  类型标识符，去标识对象的（数据）类型；
>  引用计数器，记录当前对象的引用的数目。
> （回收机制：变量的引用计数器为0，自动清理。 ※ 较小整数型对象有缓存机制。）
> 
**③ 值(value)：**
&emsp;&emsp; 表示对象存储的数据的信息。使用内置函数`print(obj)`可以直接打印值。




&emsp;
&emsp;
# 9. `is` 和 `==` 的区别
它俩判断的依据不一样：
> **`is`** 
> &emsp;&emsp; 判断两个变量是否指向同一个对象，比较两个引用是否代表了内存中同一个地址，是否指向同一块内存空间。通过`id(obj)`返回值判断。
> **`==`** 
> &emsp;&emsp; 比较对象的本身内容`类型(type)`和`值(value`)是否一致(默认会调用对象的`__eq__`方法)，当type与value相同时，`==` 为`True`。
> 
换句话说：
> 我们在检查 `a is b` 的时候，其实相当于检查 `id(a) == id(b)`。
> 而检查 `a == b` 的时候，实际是调用了对象`a` 的 `__eq()__` 方法，即相当于 `a.__eq__(b)`。
> 





&emsp;
&emsp;
# 10. python的 可变和不可变数据类型
&emsp;&emsp; python中主要有6种标准数据类型，分为可变和不可变两类。
## 10.1 不可变数据类型
### 10.1.1 什么是不可变数据类型？
&emsp;&emsp; python中不可变数据类型的定义为：
> 当该数据类型的对应变量的值发生了改变，那么它对应的内存地址也会发生改变，就称不可变数据类型，包括：`int`（整型）、`string`（字符串）、`tuple`（元组）。
> 也就是说，在修改 不可变数据类型对象的值 时，由于其内存中的值不可以被改变，所以会把原来的值复制一份再进行改变，这样就会计算机会开辟一段新的内存空间来存储新的值。
> 

### 10.1.2 哪些是不可变数据类型？
**① 整型**
&emsp;&emsp; 首先我们来看一下整型为什么是不可变数据类型。给一个变量x赋值，然后改变这个x的值，输出前后两次的内存地址id和数据类型type
```python
# 赋值
x = 1
# 打印x的内存地址和数据类型
print(id(x), type(x))
# 输出：8791164511056 <class 'int'>

# 改变x的值
x = 2
# 打印改变后的x的内存地址和数据类型
print(id(x), type(x))
# 输出：8791164511088 <class 'int'>
```
从上面的代码我们可以得出，变量x为整型，且当x的值发生改变的时候，变量的内存地址也发生了改变。所以整型是不可变的数据类型。

**② 字符串**
&emsp;&emsp; 根据上面的实例，我们把变量x的值换成字符串试试：
```python
# 赋值
x = 'abcdefg'
# 打印x的内存地址和数据类型
print(id(x), type(x))
# 输出：30828000 <class 'str'>

# 改变x的值
x = 'higklmn'
# 打印改变后的x的内存地址和数据类型
print(id(x), type(x))
# 输出：30828168 <class 'str'>
```
代码中当变量改变时，变量的内存地址由30828000 变为了30828168 。所以字符串是不可变数据类型。

**③ 元组**
元组被称为只读列表，即数据可以被查询，但不能被修改。如果我们强行修改元组中的数据，会报错。
```python
t = (1, 2, 3, 4, 5)
# 修改元组的值
t[1] = 100

#直接报错：TypeError: 'tuple' object does not support item assignment
```

## 10.2 可变数据类型
### 10.2.1 什么是 可变数据类型？
python中对可变数据类型的定义为：
> 当该数据类型的对应变量的值发生了改变，那么它对应的内存地址不发生改变，就称可变数据类型。包括：set（集合）、list（列表）、dict（字典）
> 也就是说，可变类型的变量 被改变后，其所指向的内存地址上面的值 直接被改变，没有发生复制行为，也没有发生开辟新的内存地址行为，不会重新开辟空间。
> 
### 10.2.2 哪些是 可变数据类型？
**① 集合**
我们先来看一下集合，先定义一个集合set1，改变set1的值，且输出两次的内存地址
```python
set1 = {1, 2, 3, '123'}
print("集合:", set1, "内存地址：", id(set1), "\t", "数据类型：", type(set1), "\t")
# 输出：集合: {1, 2, 3, '123'} 内存地址： 41388296     数据类型： <class 'set'>    

# 给set1添加一个元素
set1.add(100)
print("集合:", set1, "内存地址：", id(set1), "\t", "数据类型：", type(set1), "\t")
# 输出：集合: {1, 2, 3, 100, '123'} 内存地址： 41388296    数据类型： <class 'set'>    
```
从上面代码我们可以看出，即使一个集合发生了改变，这个集合的内存地址是不变的。所以集合是可变数据类型。

**② 列表**
```python
list1 = [1, 2, 3, 4, 5]
print("列表:", list1, "内存地址：", id(list1), "\t", "数据类型：", type(list1), "\t")
# 输出：列表: [1, 2, 3, 4, 5] 内存地址： 1860168   数据类型： <class 'list'> 

list1[0] = 100
print("列表:", list1, "内存地址：", id(list1), "\t", "数据类型：", type(list1), "\t")
# 输出：列表: [100, 2, 3, 4, 5] 内存地址： 1860168     数据类型： <class 'list'>   
```
当列表中的值发生了改变时，内存地址依旧不变，所以列表是可变数据类型。

**③ 字典**
字典是python中唯一的映射类型，采用键值对（key-value）的形式存储数据。字典中的key值必须是可哈希的数据类型，也就是整型，字符串，元组等。
```python
dict1 = {'name': 'kkk', 'age': 18}
print("字典:", dict1, "内存地址：", id(dict1), "\t", "数据类型：", type(dict1), "\t")
# 字典: {'name': 'kkk', 'age': 18} 内存地址： 31033960      数据类型： <class 'dict'> 

dict1['sex'] = 'man'
print("字典:", dict1, "内存地址：", id(dict1), "\t", "数据类型：", type(dict1), "\t")
# 字典: {'name': 'kkk', 'age': 18, 'sex': 'man'} 内存地址： 31033960    数据类型： <class 'dict'>   
```
从上面代码可以看出，当字典中的元素发生改变时，内存地址不变，都是31033960。所以字典是可变数据类型。






&emsp;
&emsp;
&emsp;
# 10. 直接赋值、浅拷贝 和 深拷贝
&emsp;&emsp; 首先，需要明确一点是：
> &emsp;&emsp; 浅拷贝和深拷贝之间的区别只适用于 可变对象。对于非可变对象没有区别，都是对象拷贝，相当于重新赋值，生成一个新的对象
> 

## 10.1 不可变对象 的直接赋值、浅拷贝 和 深拷贝
对于不可变对象，直接赋值、浅拷贝、深拷贝效果都一样：
```python
str2 = str1

str1 = "Good bye!"

print("str1: ", str1)
print("str2: ", str2)
```
运行结果：
```
str1:  Good bye!
str2:  Hello World!
```
**结果分析：**
&emsp;&emsp; 可以看到的是，`str1`的改变并不会影响`str2`的值，验证了前面的结论。

## 10.2 可变对象 的直接赋值、浅拷贝 和 深拷贝
### 10.2.1 原理
**(1) 直接赋值**： 其实就是对象的引用（别名）。
`b = a`: 赋值引用，`a` 和 `b` 都指向同一个对象。
<div align="center"> <img src="./pic/assignment.png"> </div>
<center> <font color=black> <b> 直接赋值 </b> </font> </center>

&emsp;
**(2) 浅拷贝(copy)**： 拷贝父对象，不会拷贝对象的内部的子对象。
`b = a.copy()`: 浅拷贝, `a` 和 `b` 是一个独立的对象，但他们的子对象还是指向统一对象（是引用）
<div align="center"> <img src="./pic/copy.png"> </div>
<center> <font color=black> <b> 浅拷贝 </b> </font> </center>

&emsp;
**(3) 深拷贝(deepcopy)**： copy模块 的 deepcopy方法，完全拷贝了父对象及其子对象。
`b = copy.deepcopy(a)`: 深度拷贝, `a` 和 `b` 完全拷贝了父对象及其子对象，两者是完全独立的。
<div align="center"> <img src="./pic/deepcopy.png"> </div>
<center> <font color=black> <b> 深拷贝 </b> </font> </center>

### 10.2.2 实例验证
```python
import copy

a = [1, 2, 3, 4, ['a', 'b']] #原始对象

b = a                # 直接拷贝
c = copy.copy(a)     # 浅拷贝
d = copy.deepcopy(a) # 深拷贝

a.append(5)         # 修改对象a
a[4].append('c')    # 修改对象a的子对象 ['a', 'b']

print( 'a = ', a )
print( 'b = ', b )
print( 'c = ', c )
print( 'd = ', d )
```
运行结果：
```
a =  [1, 2, 3, 4, ['a', 'b', 'c'], 5]
b =  [1, 2, 3, 4, ['a', 'b', 'c'], 5]
c =  [1, 2, 3, 4, ['a', 'b', 'c']]   
d =  [1, 2, 3, 4, ['a', 'b']]  
```
&emsp;&emsp; 在原始对象被改变后，只有进行直接赋值的`b`受到了影响，这证实了`b`其实和 原始对象`a` 指向了同一对象；
&emsp;&emsp; 在对 原始对象`a`的子对象 进行修改后，进行浅拷贝的`c`也受到了影响，这证实了浅拷贝后，它们的子对象还是指向统一对象。


## 10.3 下面这段代码的输出是什么？为什么？
```python
a = (1, 2)
b = a
a = (3, 4)

print(a, b)
```
**输出结果：**
```
(3, 4) (1, 2)
```
**为什么：**
&emsp;&emsp; 因为元组是不可变类型，因此 `a = (3, 4)`相当于新建了一个元组`(3, 4)`然后让`a`指向它，因此不会影响元组`b`。






&emsp;
&emsp;
&emsp;
# 11. `lambda`表达式
## 11.1 什么是 `lambda`表达式
&emsp;&emsp; lambda 表达式（lambda expression）是一个**匿名函数**，通俗的说就是没有名字的函数，是一种快速定义单行的最小函数，可以用来简化代码。

## 11.2 语法特点
lambda的语法形式如下：
```python
lambda argument_list: expression
```
① `argument_list` 是参数列表。它的结构与Python中函数(function)的参数列表是一样的，可以有非常多的形式。例如：
> a, b
> a=1, b=2
> *args
> **kwargs
> a, b=1, *args
> 空
> 
② `expression`是一个关于参数的表达式。表达式中出现的参数需要在argument_list中有定义，并且表达式只能是单行的。以下都是合法的表达式：
> 1
> None
> a + b
> sum(a)
> 1 if a >10 else 0
> 

## 11.3 lambda函数的输入输出
用一个例子来说明把：
```python
lambda x, y: x*y
```
① 输入：参数列表里的就是输入，如上面的`x`
② 输出：`x*y`的结果就是输出

## 11.4 `lambda`表达式 的应用
**① 将lambda函数赋值给一个变量，通过这个变量间接调用该`lambda`函数。**
```python
add = lambda x, y : x + y

print(add) # 输出lambda函数的地址

print(add(1, 1))
```
输出结果：
```
<function <lambda> at 0x00000213238289D0>
2
```

**② 将lambda函数赋值给其他函数，从而将其他函数用该lambda函数替换。**
&emsp;&emsp; 例如，为了把标准库`time`中的函数`sleep`的功能屏蔽(Mock)，我们可以在程序初始化时调用：`time.sleep=lambda x:None`。这样，在后续代码中调用`time`库的`sleep`函数将不会执行原有的功能。例如，执行`time.sleep(3)`时，程序不会休眠3秒钟，而是什么都不做。

**③ 将lambda函数作为其他函数的返回值，返回给调用者。**
&emsp;&emsp; 函数的返回值也可以是函数。例如return lambda x, y: x+y返回一个加法函数。这时，lambda函数实际上是定义在某个函数内部的函数，称之为嵌套函数，或者内部函数。对应的，将包含嵌套函数的函数称之为外部函数。内部函数能够访问外部函数的局部变量，这个特性是闭包(Closure)编程的基础，在这里我们不展开。

**④ 将lambda函数作为参数传递给其他函数。**
就拿`sort()`来举例吧，如果想实现以 绝对值排序，用`lambda`可以这么写：
```python
numbers = [2, -4, 9, 5, -6, 1, 7, -3, 8]
numbers.sort( key=lambda x : abs(x))
print(numbers)
```
运行结果：
```
[1, 2, -3, -4, 5, -6, 7, 8, 9]
```






&emsp;
&emsp;
&emsp;
# 12. 如何多标准排序？








&emsp;
&emsp;
&emsp;
# 13. 内置字典类型 的`get()`和`setdefault`的区别
## 13.1 先介绍一下这两个方法：
**(1) `setdefault()`方法**
&emsp;&emsp; `dict.setdefault(key, default=None)` ---有`key`则返回对应的值、没`key`则插入，`value`设为`default`的值：
> 如果 key 在 字典中，返回对应的值。
> 如果 key 不在字典中，则插入 key 及设置的默认值 default，并返回 default(default 默认值为 None)
> 
 
**(2) `get()`方法**
&emsp;&emsp; `dict.get(key, default=None)` ---有key获取值、没key返回default：
> 返回指定键的值，如果值不在字典中返回默认值 None。
> 
## 13.2 区别
&emsp; 当目标`key`**不在字典里时**：
> &emsp;&emsp; `setdefault()`方法会将目标可以插入到字典里，`value`设为`default`的值(默认为`None`)，然后返回`default`的值；
> &emsp;&emsp; 直接返回`default`的值(默认为`None`)，不会进行插入操作。
> 

## 13.3 代码验证
```python
car = {
  "brand": "Porsche",
  "model": "911",
  "year": 1963
}

x = car.get("weight", 2000)
y = car.setdefault("color", "White")

print(car)
```
输出：
```
{'brand': 'Porsche', 'model': '911', 'year': 1963, 'color': 'White'}
```
**结果分析：**
&emsp;&emsp; ① `weight`原来不在字典`car`里面的，调用`get`方法后还是不再，说明`get`确实不会对字典进行插入操作。
&emsp;&emsp; ② `color`原来不在字典`car`里面的，但调用`setdefault`方法后，`color`已经插入到`car`了，说明`setdefault`方法确实会进行插入操作。。






&emsp;
&emsp;
&emsp;
# 14. 当函数返回多个值时，解释器做了什么？
&emsp;&emsp; 当函数返回多个值时，解释器会将它们打包成一个元组，所以我们可以对函数的返回值做 unpacking操作。






&emsp;
&emsp;
&emsp;
# 15. 变量注解
## 15.1 参数注解是什么时候引入的？
&emsp;&emsp; python3.6开始引入的。

## 15.2 怎么使用？
语法：`tmp:int = 2`

## 15.3 进行了变量注解后，解释器会做类型检查吗？
不会，来看代码：
```python
tmp:int = 2

tmp = "Hello World"
print(tmp)
```
运行结果：
```
Hello World
```






&emsp;
&emsp;
&emsp;
# 16. `__closure__`属性 表示的是什么？
&emsp;&emsp; `__closure__`属性 中保存的是 闭包中绑定的自由变量。






&emsp;
&emsp;
&emsp;
# 17. 

