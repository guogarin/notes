# 1. 如何实现三元表达式？
```python
args = [0, 1, 2]

reslut_0 = args[0] if (args[0] == 0) else 100
reslut_1 = args[1] if (args[1] == 0) else 99

print(f'reslut_0:{reslut_0}')
print(f'reslut_1:{reslut_1}')
```
运行结果：
```
reslut_0:0
reslut_1:99
```
`reslut_0 = args[0] if (args[0] == 0) else 100`其实相当于：
```python
if args[0] == 0:
    reslut_0 = args[0]
else:
    reslut_0 = 100
```



&emsp;
&emsp;
# 2. python中如何交换两个变量的值？
直接用**解包(unpacking)**就能做到，不需要用临时变量：
```python
def bubble_sort_by_tmp(a):
    for _ in range(len(a)):
        for i in range(1, len(a)):
            if a[i] < a[i-1]:
                temp = a[i]
                a[i] = a[i-1]
                a[i-1] = temp


def bubble_sort_by_unpacking(a):
    for _ in range(len(a)):
        for i in range(1, len(a)):
            if a[i] < a[i-1]:
                a[i-1], a[i] = a[i], a[i-1] # 不需要像        


names = ['pretzels', 'carrots', 'arugula', 'bacon']
bubble_sort_by_unpacking(names)
print(names)         
```
**用 解包(unpacking) 交换两个变量的值的原理是？**
&emsp;&emsp; Python在处理赋值操作时，首先处理的是`=`右侧的值，于是它会新建一个临时元组，例如在上面的`bubble_sort_by_unpacking()`中，第一次进入内部的`for`循环时，这`a[i-1], a[i]`分别是`'pretzels', 'carrots'`，于是，系统会创建出`('pretzels', 'carrots')`这样的元组，，然后Python会对这个临时元组进行`unpacking`操作。



&emsp;
&emsp;
# 3. 介绍一下python的`解包(unpacking)`机制
## 3.1 什么是`解包(unpacking)`？
&emsp;&emsp; 解包在英文里叫做 Unpacking，就是将容器里面的元素逐个取出来，然后赋给新变量，元组、列表、字典，甚至字符串都支持解包操作：
**① 元组解包**
```python
tp = ("Jack", 26)
name, age = tp
print(f'{name} is {age} years old.')
```
运行结果：
```
Jack is 26 years old.
```

**② 列表解包**
```python
>>> a, b, c = [1,2,3]
>>> a
# 1
>>> b
# 2
>>> c
# 3
```

**③ 字典解包**
```python
>>> a,b,c = {"a":1, "b":2, "c":3}
>>> a
# 'a'
>>> b
# 'b'
>>> c
# 'c'
```
字典解包后，只会把字典的 key 取出来，value 则丢掉了

**④ 字符串解包**
```python
>>> a,b,c = "abc"
>>> a
# 'a'
>>> b
# 'b'
>>> c
# 'c'
```

## 3.2 将容器解包后赋予新的变量，这个新的变量被修改后，容器里面的元素会被修改吗？
不会，它们是独立的：
```python
tp = ("Jack", 26)
name, age = tp
print(f'{name} is {age} years old.')

age = 100
print(tp)
```
运行结果：
```
Jack is 26 years old.
('Jack', 26)
```

## 3.3 如何理解`a, *b, c = [1,2,3,4]` ？
```python
a, *b, c = [1,2,3,4,5]
print(f'a: {a}')
print(f'b: {b}')
print(f'c: {c}')
```
运行结果：
```
a: 1
b: [2, 3, 4]
c: 5
```
这个其实就是在某个变量面前加一个星号`*`，而且这个星号可以放在任意变量，每个变量都分配一个元素后，**剩下的元素都分配给这个带星号`*`的变量**。
如果你想取 **前两个变量**：
```python
a, b, *c = [1,2,3,4,5] # 星号给了 变量c
print(f'a: {a}')
print(f'b: {b}')
print(f'c: {c}')
```
运行结果：
```
a: 1
b: 2
c: [3, 4, 5]
```

## 3.4 应用
.TODO: item 6、13、19、22、23、27



&emsp;
&emsp;
# 4. 介绍下`enumerate`函数
## 4.1 `enumerate`函数 的作用是？
`enumerate`函数 能把任何一种迭代器封装成 惰性迭代器(lazy iterator)，这样在每次循环的时候，只需从iterator中取下一个值即可，而且还会给出本轮循环的序号(从0开始计数)：
```python
snacks = [('bacon', 350), ('donut', 240), ('muffin', 190)]

for i  in enumerate(snacks):
    print(i)
```
输出结果为：
```
(0, ('bacon', 350))
(1, ('donut', 240))
(2, ('muffin', 190))
```
可以看到的是，`enumerate`函数 返回了一个元组，元组里面包含的是(`序号`, `snacks的元素`)；

## 4.2 `enumerate`函数返回的循环序号 可以自定义吗？
可以的，通过指定`start`参数可以做到，即`enumerate(snacks, start=1)`：
```python
snacks = [('bacon', 350), ('donut', 240), ('muffin', 190)]

for i  in enumerate(snacks, 1): # 指定 start参数为1
    print(i)
```
输出结果为：
```
(1, ('bacon', 350))
(2, ('donut', 240))
(3, ('muffin', 190))
```
可以看到的是，编号从`1`开始了。

## 4.3 `enumerate`函数 的应用
`enumerate`函数 需要配合 `解包(unpacking)`机制 来使用：
```python
snacks = [('bacon', 350), ('donut', 240), ('muffin', 190)]

for rank, (name, calories) in enumerate(snacks, 1):
    print(f'#{rank} : {name.title()} has {calories} calories.')
```
输出结果为：
```
#1 : Bacon has 350 calories.
#2 : Donut has 240 calories.
#3 : Muffin has 190 calories.
```



&emsp;
&emsp;
# 5. `zip()`函数
## 5.1 `zip()`函数 的作用是？工作原理是？
### 5.1.1 (1) 作用
&emsp;&emsp; `zip()` 函数是 Python 内置函数，它可以将多个序列（包括：列表、元组、字典、集合、字符串以及 range() 区间构成的列表）“压缩”成一个 zip 对象。
### 5.1.2 工作原理
&emsp;&emsp; **所谓“压缩”**，其实就是将这些序列中对应位置的元素重新组合，生成一个个新的**元组**。我们来看下面的例子：
```python
my_list = [11,12,13]
my_tuple = (21,22,23)
print([x for x in zip(my_list,my_tuple)])
```
输出为：
```
[(11, 21), (12, 22), (13, 23)]
```
`zip()`在每次循环的时候，会分别从`my_list`、`my_tuple`中取一个元素，然后将这两个元素封装成一个元组，因为这两个容器都是有3个元素，这三次循环产生的元组为：
> 第一次循环：(11, 21)
> 第二次循环：(12, 22)
> 第三次循环：(13, 23)
> 

## 5.2 如何使用？
```python
my_list = [11,12,13]
my_tuple = (21,22,23)
print([x for x in zip(my_list,my_tuple)])

my_dic = {31:2,32:4,33:5}
my_set = {41,42,43,44}
print([x for x in zip(my_dic,my_set)])
```
运行结果：
```
[(11, 21), (12, 22), (13, 23)]
[(31, 41), (32, 42), (33, 43)]
```
**分析以上的程序和相应的输出结果不难发现**：
> 在使用 zip() 函数“压缩”多个序列时，它会分别取各序列中第 1 个元素、第 2 个元素、... 第 n 个元素，各自组成新的元组。
> 

## 5.3 对字典使用zip()会发生什么？
只会取`key`的值，`value`被忽略了：
```python
my_dic = {31 : 2,32 : 4,33 : 5}
my_set = {41,42,43,44}
print([x for x in zip(my_dic,my_set)])
```
运行结果：
```
[(31, 41), (32, 42), (33, 43)]
```

## 5.4 如果传给zip()的两个序列长度不一样会发生什么？
&emsp;&emsp; 先说结论：**当多个序列中元素个数不一致时，会以最短的序列为准进行压缩。** 我们来实验一下：
```python
list_1 = {1, 2, 3}
list_2 = {1, 2, 3, 4} # 这个要长一点
print([x for x in zip(list_1, list_2)])
```
运行结果：
```
[(1, 1), (2, 2), (3, 3)]
```
我们发现，`list_2`的第四个元素被忽略了，也验证了`zip()`在压缩的时候会以 最短的序列为准的结论。

## 5.5 如果希望在 压缩(zip) 的时候，以最长的序列为准，应该怎么做？
应该使用`zip_longest()`，它位于 `itertools`模块中：
```python
import itertools

list_1 = {1, 2, 3}
list_2 = {1, 2, 3, 4} # 这个要长一点
print([x for x in itertools.zip_longest(list_1, list_2)])
```
运行结果：
```
[(1, 1), (2, 2), (3, 3), (None, 4)]
```

## 5.6 如果列表很长，zip()会因为 内存占用过多 而崩溃？
不会的，因为`zip()`每次只会从它封装的迭代器中取一个元素，所以占用内存很少。



```python

```