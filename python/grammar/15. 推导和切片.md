- [一、推导(comprehension)](#一推导comprehension)
  - [1. 列表推导(list comprehension)](#1-列表推导list-comprehension)
    - [1.1 列表推导式中使用`if/else`](#11-列表推导式中使用ifelse)
      - [1.1.1 语法介绍](#111-语法介绍)
      - [1.1.2 总结：](#112-总结)
    - [1.2 几个列表推导的问题](#12-几个列表推导的问题)
      - [1.2.1 生成两个新列表，一个只包含奇数，一个只包含偶数](#121-生成两个新列表一个只包含奇数一个只包含偶数)
    - [1.2.2 生成两个个列表，一个只留下可以被`2`或`3`整除的数，另一个只留下能同时被`2`和`3`整除的数](#122-生成两个个列表一个只留下可以被2或3整除的数另一个只留下能同时被2和3整除的数)
    - [1.2.3 生成一个列表，其中 小于5取倒数，其余的取平方](#123-生成一个列表其中-小于5取倒数其余的取平方)
  - [2. 字典推导(dictionary comprehension)](#2-字典推导dictionary-comprehension)
    - [2.1 在上面的`dict1`的基础上生成一个新的dic，要求过滤`key`为偶数(奇数)的元素，并将`value`加10](#21-在上面的dict1的基础上生成一个新的dic要求过滤key为偶数奇数的元素并将value加10)
    - [2.2 以dict1为基础创建一个新的字典,如果value大于25,则减去10,反之加10](#22-以dict1为基础创建一个新的字典如果value大于25则减去10反之加10)
  - [3. 推导式的多个`if`语句之间默认是`and`还是`or`？](#3-推导式的多个if语句之间默认是and还是or)
  - [4. 包含多个`for`循环的推导式](#4-包含多个for循环的推导式)
- [二、切片(slice sequences)](#二切片slice-sequences)
  - [1  什么样的类可以进行切片操作？](#1--什么样的类可以进行切片操作)
  - [2 切片 的时候如果下标越界会发生什么？](#2-切片-的时候如果下标越界会发生什么)
  - [3 切割出来的列表 和 原列表 有何联系？](#3-切割出来的列表-和-原列表-有何联系)
  - [4 进行切片操作时应该秉承什么样的原则？](#4-进行切片操作时应该秉承什么样的原则)
  - [5 切片 出现在 赋值符号的左侧](#5-切片-出现在-赋值符号的左侧)
  - [6 指定 步长(stride)](#6-指定-步长stride)
    - [6.1 如果指定的步长为负数，意味着什么呢？](#61-如果指定的步长为负数意味着什么呢)
    - [6.2 指定步长有哪些应用？](#62-指定步长有哪些应用)
      - [① 取一个列表的奇数位 或 偶数位 的元素](#-取一个列表的奇数位-或-偶数位-的元素)
      - [② 翻转列表](#-翻转列表)
  - [如何为自定义的类提供 切片操作？](#如何为自定义的类提供-切片操作)






&emsp;
&emsp;
# 一、推导(comprehension)
## 1. 列表推导(list comprehension)
### 1.1 列表推导式中使用`if/else`
#### 1.1.1 语法介绍
列表推导式总共有两种形式：
```python
# 形式1：
[x for x in data if condition]
```
&emsp;&emsp; 此处`if`主要起条件判断作用，`data`数据中只有满足`if`条件的才会被留下，最后统一生成为一个数据列表
```python
# 形式2：
[exp1 if condition else exp2 for x in data]
```
&emsp;&emsp; 此处`if...else`主要起赋值作用，当`data`中的数据满足`if`条件时将其做exp1处理，否则按照`exp2`处理，最后统一生成为一个数据列表
#### 1.1.2 总结：
&emsp;&emsp; 如果只是想过滤，`if`写在后面；
&emsp;&emsp; 如果想对满足特定条件的值做一些处理，`if`得写在前面。

### 1.2 几个列表推导的问题
&emsp;&emsp; 现有一个只包含数字`0` 到 `9`的`list`，利用列表推导在这个`list`的基础上完成下面的问题。
#### 1.2.1 生成两个新列表，一个只包含奇数，一个只包含偶数
```python
a = [x for x in range(10)]

print([x for x in a if x%2])
print([x for x in a if not x%2])
```
运行结果：
```
[1, 3, 5, 7, 9]
[0, 2, 4, 6, 8]
```
### 1.2.2 生成两个个列表，一个只留下可以被`2`或`3`整除的数，另一个只留下能同时被`2`和`3`整除的数
```python
a = [x for x in range(10)]

print([x for x in a if x%2==0 or x%3==0])
print([x for x in a if x%2==0 and x%3==0])
```
运行结果：
```
[0, 2, 3, 4, 6, 8, 9]
[0, 6]
```

### 1.2.3 生成一个列表，其中 小于5取倒数，其余的取平方
```python
a = [x for x in range(10)]

print([-x if x<5 else x**2 for x in a ])
```
运行结果：
```
[0, -1, -2, -3, -4, 25, 36, 49, 64, 81]
```


&emsp; 
## 2. 字典推导(dictionary comprehension)
`dict1 = {'1': 10, '2': 20, '3': 30, '4' : 40}`
### 2.1 在上面的`dict1`的基础上生成一个新的dic，要求过滤`key`为偶数(奇数)的元素，并将`value`加10
```python
dict1 = {'1': 10, '2': 20, '3': 30, '4' : 40}

print({k:v+10 for k,v in dict1.items() if int(k)%2})
print({k:v+10 for k,v in dict1.items() if not int(k)%2})
```
运行结果：
```
{'1': 20, '3': 40}
{'2': 30, '4': 50}
```

### 2.2 以dict1为基础创建一个新的字典,如果value大于25,则减去10,反之加10
```python
dict1 = {'1': 10, '2': 20, '3': 30, '4' : 40}

print({k:v+10 if v<25 else v-10 for k,v in dict1.items()})
```
运行结果：
```
{'1': 20, '2': 30, '3': 20, '4': 30}
```


&emsp; 
## 3. 推导式的多个`if`语句之间默认是`and`还是`or`？
&emsp;&emsp; 默认是`and`关系，也就是多个`if`条件必须同时成立。


&emsp; 
## 4. 包含多个`for`循环的推导式
```python
colors = ['black', 'white']
sizes = ['S', 'M', 'L', 'XL', 'XXL']

# 注意，这里有两个for循环
tshirts = [(color, size) for color in colors for size in sizes]
print(tshirts)
```
运行结果：
```
[('black', 'S'), ('black', 'M'), ('black', 'L'), ('black', 'XL'), ('black', 'XXL'), ('white', 'S'), ('white', 'M'), ('white', 'L'), ('white', 'XL'), ('white', 'XXL')]
```
上面其实可以看做是一个**笛卡尔集**，至于什么是笛卡尔集呢？来看下面的例子：
> 例 A={1，2}，B={0，1}，则：
> &emsp;&emsp; A×B = {(1，0),(1，1)，(2，0)，(2，1)}，
> &emsp;&emsp; B×A = {(0，1)，(0，2)，(1，1)，(1，2)}，
> 
上面的列表推导其实等价于**两个嵌套的for循环**：
```python
colors = ['black', 'white']
sizes = ['S', 'M', 'L', 'XL', 'XXL']

tshirts = []
for i in colors:
    for j in sizes:
        tshirts.append((i, j))
print(tshirts)
```
运行结果：
```
[('black', 'S'), ('black', 'M'), ('black', 'L'), ('black', 'XL'), ('black', 'XXL'), ('white', 'S'), ('white', 'M'), ('white', 'L'), ('white', 'XL'), ('white', 'XXL')]
```
可以看到的是，这两种写法的输出结果是一样的。






&emsp;
&emsp; 
# 二、切片(slice sequences)
## 1  什么样的类可以进行切片操作？
&emsp;&emsp; 实现了 `__getitem__()`and `__setitem__()` 的类都可以进行切片操作。

## 2 切片 的时候如果下标越界会发生什么？
&emsp;&emsp; 切片 可以允许越界，如果起点和终点 超过了列表的边界，那么系统会自动忽略不存在的元素。

## 3 切割出来的列表 和 原列表 有何联系？
**切片 是 浅拷贝：**
```python
a = [0, 1, 2, ['a', 'b', 'c'], 4]
b = a[:]

if a == b :
    print("a == b")

a[0] = 'A' 		# 修改列表
a[3][0] = 100	# 修改子序列

print("a = ", a)
print("b = ", b)
```
运行结果：
```
a == b
a =  ['A', 1, 2, [100, 'b', 'c'], 4]
b =  [0, 1, 2, [100, 'b', 'c'], 4]
```
**结果分析：**
&emsp;&emsp; 运行结果显示，列表`a`的直接修改没有影响到列表`b`，但是对列表`a`的子序列的修改却影响到了`b`，这显然验证了 切片 是浅拷贝的结论。

## 4 进行切片操作时应该秉承什么样的原则？
&emsp; 切片要尽可能写的简单：
> &emsp;&emsp; 如果是从头开始切割，则应该省略左侧的下标`0`；
> &emsp;&emsp; 如果是一直取到末尾，那就应该省略冒号右侧的下标
> 
```python
numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

from_start = numbers[:4]
print(from_start)

print(to_end:=numbers[1:])
```
输出的结果：
```
[0, 1, 2, 3]
[1, 2, 3, 4, 5, 6, 7, 8, 9]
```

## 5 切片 出现在 赋值符号的左侧
&emsp;&emsp; 切片 可以出现在赋值符号的左侧，表示用 右侧那些元素 把原列表中位于这个范围之内的元素换掉。
&emsp;&emsp; 和`unpacking`机制不一样的是，切片 位于赋值符号左侧时**不要求**两边个数相等：
```python
numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

# 左侧 = 右侧
numbers[:2]=[9, 9]
print('左侧 = 右侧: ', numbers)

# 左侧 > 右侧
numbers[2:4]=[9]
print('左侧 > 右侧: ', numbers)

# 左侧 < 右侧
numbers[4:5]=[9, 9, 9]
print('左侧 < 右侧: ', numbers)
```
输出结果：
```
左侧 = 右侧:  [9, 9, 2, 3, 4, 5, 6, 7, 8, 9]
左侧 > 右侧:  [9, 9, 9, 4, 5, 6, 7, 8, 9]
左侧 < 右侧:  [9, 9, 9, 4, 9, 9, 9, 6, 7, 8, 9]
```
根据输出结果可以知道：
> 如果 左侧提供的长度 **>** 右侧提供的长度，则目标列表会变**短**
> 如果 左侧提供的长度 **<** 右侧提供的长度，则目标列表会变**长**
> 
其实这很好记，只要记住的是：
> 切片 可以出现在赋值符号的左侧，表示用 右侧那些元素 把 **原列表中位于这个范围之内** 的元素换掉。
> 
换句话说，就是我不管你左侧是有多少个元素，反正我就用右侧的元素将你替换掉。

## 6 指定 步长(stride)
&emsp;&emsp; 通过`somelist[start:end:stride]`的`stride`可以指定步长。
### 6.1 如果指定的步长为负数，意味着什么呢？
步长为负值意味着反向取值：
```python
s = 'bicycle'

print(s[::-1])
```
**运行结果：**
```
'elcycib'
```

### 6.2 指定步长有哪些应用？
#### ① 取一个列表的奇数位 或 偶数位 的元素
```python
numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
odd = numbers[1::2]
even = numbers[::2]
print(f"odd:  {odd}")
print(f"even: {even}")
```
输出：
```
odd:  [1, 3, 5, 7, 9]
even: [0, 2, 4, 6, 8]
```

#### ② 翻转列表
```python
numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
reverse = [::-1]
print(f"reverse: {reverse}")
```
输出：
```
reverse: [9, 8, 7, 6, 5, 4, 3, 2, 1, 0]
```


##  如何为自定义的类提供 切片操作？
为该类提供  `__getitem__()`和 `__setitem__()` 即可。

