- [1.  `global` 和 `nonlocal`](#1--global-和-nonlocal)
  - [1.1 为什么需要 `global` 和 `nonlocal` 关键字？他俩是用来解决什么问题的？](#11-为什么需要-global-和-nonlocal-关键字他俩是用来解决什么问题的)
    - [1.1.1 总结](#111-总结)
  - [1.2 `global` 和 `nonlocal`的作用分别是什么？](#12-global-和-nonlocal的作用分别是什么)
  - [1.3 `global` 可以作用于哪些变量？](#13-global-可以作用于哪些变量)
  - [1.4 `nonlocal`可以作用于哪些变量？](#14-nonlocal可以作用于哪些变量)
  - [1.5 `nonlocal` 和 `global` 的区别](#15-nonlocal-和-global-的区别)
- [2. `in`操作](#2-in操作)
  - [2.1 如何让自定义的类支持`in`操作？](#21-如何让自定义的类支持in操作)
  - [2.2 既然有多种方法可以让自定义的类支持`in`操作，那当一个类采用了不止一种方法来实现`in`操作时，编译器会优先使用哪种方法？](#22-既然有多种方法可以让自定义的类支持in操作那当一个类采用了不止一种方法来实现in操作时编译器会优先使用哪种方法)



&emsp;
&emsp; 
# 1.  `global` 和 `nonlocal`
## 1.1 为什么需要 `global` 和 `nonlocal` 关键字？他俩是用来解决什么问题的？
```python
def func():
    count = '我是func()里的局部变量count'
    def func_1():
        print(count)
    def func_2():
        count = 1
        print(count)
    func_1()
    func_2()
    print("-"*20)
    print(count)

if __name__ == "__main__":
    func()
```
输出：
```
我是func()里的局部变量count
1
--------------------
我是func()里的局部变量count
```
**结果分析：** 
&emsp;&emsp; `func_1()`的输出结果说明我们可以访问到外层的`count`变量；
&emsp;&emsp; `func_2()`和`func()`的最后那句`print`的输出结果说明我们不能修改外部作用域的变量。
### 1.1.1 总结
**而`global` 和 `nonlocal`使我们修改 全局变量(`global`)、外层局部变量(`nonlocal`) 成为了可能。**

## 1.2 `global` 和 `nonlocal`的作用分别是什么？
| 关键字     | 作用                                                 |
| ---------- | ---------------------------------------------------- |
| `global`   | 用来在 函数或其它局部作用域中 使用 **全局变量**      |
| `nonlocal` | 用来在 函数或其它作用域中 使用上层的 **非全局变量**) |
```python
count = "我是全局变量count"

def func():
    count = '我是func()里的局部变量count'
    def func_1():
        global count 
        print("global count  : ", count)
    def func_2():
        nonlocal count 
        print("nonlocal count: ", count)
    func_1()
    func_2()

if __name__ == "__main__":
    func()
```
运行结果：
```
global count  :  我是全局变量count
nonlocal count:  我是func()里的局部变量count
```
**结果分析：**
&emsp;&emsp; 使用`global`修饰的`count` 引用到的是 全局变量`count`；
&emsp;&emsp; 使用`nonlocal`修饰的`count` 引用到的是 局部变量`count`；
这两个关键字的作用一目了然。

## 1.3 `global` 可以作用于哪些变量？
`global`只能作用于全局变量
```python
def func():
    count = '我是func()里的局部变量count'
    def func_1():
        global count
        print(count)  
    func_1()

if __name__ == "__main__":
    func()
```
运行结果：
```
Traceback (most recent call last):
  File "d:/code_practice/practice.py", line 9, in <module>
    func()
  File "d:/code_practice/practice.py", line 6, in func
    func_1()
  File "d:/code_practice/practice.py", line 5, in func_1
    print(count)
NameError: name 'count' is not defined
```
**结果分析：**
&emsp;&emsp; 在上面的代码中，我们没有定义全局的`count`变量，虽然`global count`没有报错，但是我们在访问`count`时(`print(count)`)报错了，也证实了 `global`只能作用于全局变量。

## 1.4 `nonlocal`可以作用于哪些变量？
`nonlocal`只能用来在 函数或其它作用域中 使用上层的 **非全局变量**)，而且外层必须定义了局部变量，要不然会报错：
```python
count = "我是全局变量count"

def func():
    # count = '我是func()里的局部变量count'
    def func_1():
        nonlocal count
        print(count)  
    func_1()

if __name__ == "__main__":
    func()
```
运行结果：
```
  File "d:/code_practice/practice.py", line 6
    nonlocal count
    ^
SyntaxError: no binding for nonlocal 'count' found
```
**结果分析：**
&emsp;&emsp; 因为 我们没有定义 局部变量`count`，只有一个全局变量`count`，所以会报错。

## 1.5 `nonlocal` 和 `global` 的区别
**① 两者的功能不同**
> &emsp;&emsp; global关键字修饰变量后标识该变量是全局变量，对该变量进行修改就是修改全局变量，而nonlocal关键字修饰变量后标识该变量是上一级函数中的局部变量，如果上一级函数中不存在该局部变量，nonlocal位置会发生错误（最上层的函数使用nonlocal修饰变量必定会报错）。
> 
**② 两者使用的范围不同**
> &emsp;&emsp; global关键字可以用在任何地方，包括最上层函数中和嵌套函数中，即使之前未定义该变量，global修饰后也可以直接使用，而nonlocal关键字**只能用于嵌套函数中**，并且外层函数中定义了相应的局部变量，否则会发生错误
> 


&emsp;
&emsp; 
# 2. `in`操作
## 2.1 如何让自定义的类支持`in`操作？
有三种方法让自定义的类支持`in`操作
> ① 实现`__contains__()`方法；
> ② 实现迭代协议：` __iter__()`和`__next__()`方法；
> ③ 实现序列协议的两个方法：` __getitem__` 和 `__len__`
> 

## 2.2 既然有多种方法可以让自定义的类支持`in`操作，那当一个类采用了不止一种方法来实现`in`操作时，编译器会优先使用哪种方法？
这几种方法是有优先级的：
> ① `__contains__()`方法 最优先；
> ② ` __iter__()`和`__next__()`方法 第二；
> ③ ` __getitem__` 和 `__len__` 第三
> 