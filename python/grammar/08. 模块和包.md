# 1. python中的模块、库、包有什么区别？
它们的英文分别为：
&emsp;&emsp; **模块**，英文为`module`，本质上是一个Python程序，以.py作为文件后缀。任何py文件都可以作为一个模块。
&emsp;&emsp; **包**，英文为`package`，含有` __init__.py`文件 的文件夹 就是一个包。
&emsp;&emsp; **库**是参考其他编程语言的说法，是指完成一定功能的代码集合，在python中的形式就是模块和包







&emsp;
&emsp;
&emsp;
# 2. `__all__`
## 2.1 `__all__`的作用
### 2.1.1 总结
&emsp;&emsp; 我们都知道，Python 没有原生的可见性控制，其可见性的维护是靠一套需要大家自觉遵守的”约定“，比如，下划线开头的变量对外部不可见，
&emsp;&emsp; `__all__` 是针对模块公开接口的一种约定，以提供了”白名单“的形式暴露接口：
> 如果一个文件中定义了`__all__`，其他文件中使用`from xxx import *`导入该文件时，只会导入` __all__` 列出的成员，可以其他成员都被排除在外。
> 

### 2.1.2 `__all__`的一个应用：使用 `__all__`控制 from xxx import * 的行为
&emsp;&emsp; 首先要明确的是，python不提倡用 `from xxx import *` 这种写法。如果一个模块 `xxx` 没有定义` __all__`，执行 `from spam import *` 时会将 `xxx` 中所有非下划线开头的成员（包括该模块import的其他模块成员）都会导入当前命名空间，这样就可能弄脏当前的命名空间。显式声明了 `__all__`，`import *` 就只会导入 `__all__` 列出的成员，如果 `__all__` 定义有误，还会明确地抛出异常，方便检查错误。

## 2.2 定义 all 需要注意的地方
* `__all__` 的形式都是 list类型。如果写成其他类型， pyflakes 等 lint 工具可能无法识别。
不能动态生成 `__all__`，如使用列表解析式。`__all__` 的作用是定义公开接口，需要以字面量的形式显式写出来。
* 即使定义了 `__all__`， 也不应该在非临时代码中使用 from xxx import * 语法，或用编程工具模拟 Ruby 的自动 import。Python 不像 Ruby，没有 Module 这类成员，模块就是命名空间隔离的执行者。如果打破了这一层，引入诸多动态因素，生产环境中跑的代码就可能充满不确定性，调试也会变得困难。
* 按照 PEP8 建议的风格，`__all__` 应该写在所有 import 语句下面，函数、常量等成员定义的上面。
* 如果一个模块需要暴露的接口改动频繁，`__all__` 可以这样定义：
```python
__all__ = [
"foo",
"bar",
"egg",
]
```
这样修改一个暴露的接口只修改一行，方便版本控制的时候看 diff。最后多出的逗号在 Python 中是允许的，符合 PEP8 风格。

## 2.3 实例验证
### 不带`__all__`
文件结构如下：
```powershell
   my_module.py
   practice.py

没有子文件夹
```
`my_module.py`中的代码如下：
```python
obj  = "I am obj."
_foo = "I am _foo."

def _func():
    print(_func.__name__)
```
`practice.py`中的代码如下：
```python
from my_module import *

_func()
print(_foo)
print(obj)
```
运行`practice.py`，结果如下：
```
I am obj.
Traceback (most recent call last):
  File "d:/code_practice/practice.py", line 4, in <module>
    _func()
NameError: name '_func' is not defined
```
**结果分析：**
&emsp;&emsp; 可以看到，通过`from my_module import *`没有将`my_module.py`中带下划线的函数及对象(`_foo`和`_func()`)导入，未带下划线的变量(`obj`被导入了。

### 带`__all__`
现在，我们给模块中(`my_module.py`)定义`__all__`变量：
`my_module.py`中的代码如下：
```python
obj  = "obj"
_foo = "I am _foo."

def _func():
    print(_func.__name__)

# 增加了__all__
__all__ = ['obj', '_foo', '_func']    
```
`practice.py`不变，运行结果如下：
```
obj
_func
I am _foo.
```
**结果分析：**
&emsp;&emsp; 可以看到的是，下划线开头的变量也被`from my_module import *`导入了。
**值得注意的是，如果不在`__all__`列表中，即使不带下划线，也不会被`from my_module import *`所导入：**
`my_module.py`中的代码如下：
```python
obj  = "I am obj."
_foo = "I am _foo."

def _func():
    print(_func.__name__)

# 注意，里面不包含 obj
__all__ = ['_foo', '_func']   
```
`practice.py`不变，运行结果如下：
```
_func
I am _foo.
Traceback (most recent call last):
  File "d:/code_practice/practice.py", line 6, in <module>
    print(obj)
NameError: name 'obj' is not defined
```
**结果分析：**
&emsp;&emsp; 可以看到的是，在`__all__`里面的变量都被导入了，没在里面的没有被导入。






&emsp;
&emsp;
&emsp;
# 3. `__init__.py`文件
## 3.1 `__init__.py`文件的作用是？
&emsp;`__init__.py`的主要作用是：
> &emsp;&emsp;① Python中`package`的标识，不能删除：如果一个目录里有`__init__.py`文件，那么系统会将其看成一个包；否则，Python就把这个目录当成普通目录。
> &emsp;&emsp;② 定义`__all__`用来模糊导入；
> &emsp;&emsp;③ 编写Python代码(不建议在__init__中写python模块，可以在包中在创建另外的模块来写，尽量保证__init__.py简单）
> 

## 3.2  实例说明`__init__.py`的作用：一个普通的四则运算模块
### 不使用`__init__.py`
此时我们的工程目录结构如下图所示：
```shell
│  main.py
│
└─arithmetic
        add.py
        division .py
        multiply.py
        subtract.py
```
`main.py`是程序入口，我们用了不同的方式来`import`四则运算的各个子模块。`arithmetic`模块 实现四则运算；为了展示需要，我们将加减乘除四种运算分别放在不同的代码中。

`add.py`的代码如下：
```python
def add(a, b):
    return a + b
```
`division .py`的代码如下：
```python
def dev(a, b):
    return a / b
```
`multiply.py`的代码如下：
```python
def mul(a, b):
    return a * b
```
`subtract.py`的代码如下：
```python
def sub(a, b):
    return a - b
```
`main.py`的代码如下：
```python
import arithmetic.add
import arithmetic.subtract as subtract

from arithmetic.multiply import mul
from arithmetic import division

def letscook(x, y, oper):
    r = 0
    if oper == "+":
        r = arithmetic.add.add(x, y)
    elif oper == "-":
        r = subtract.sub(x, y)
    elif oper == "*":
        r = mul(x, y)
    else:
        r = division.dev(x, y)

    print("{} {} {} = {}".format(x, oper, y, r))

x, y = 3, 8

letscook(x, y, "+")
letscook(x, y, "-")
letscook(x, y, "*")
letscook(x, y, "/")
```

### 使用`__init__.py`简化`import`操作 
&emsp;&emsp; 从上面的代码可以看到的是，`arithmetic`目录下的这些文件需要一个一个导入，4个函数我们写了4个`import`语句，有没有什么方法可以只写一个`import`就把这4个函数都导入呢？
&emsp;&emsp; 咱们前面提到，我们以`import xxx`的形式导入一个包时，实际上是导入的是`xxx.__init__.py`文件，没错，通过`__init__.py`文件就能做到一次性导入4个文件中的4个函数：
`__init__.py`的代码如下：
```python

```




## 参考文献
1. (__init__.py的神奇用法)[https://zhuanlan.zhihu.com/p/115350758]




# 当我们`import`一个包时，引入的是什么？
&emsp;&emsp; 我们在导入一个包时，实际上是导入了它的`__init__.py`文件。来看一个例子：
文件结构如下：
```powershell
│  test.py
│
└─my_package
    │  __init__.py
    │
    └─__pycache__
            __init__.cpython-310.pyc
```
`my_package.__init__.py`的内容如下：
```python
import re
import os
```
`test.py`的内容如下：
```python
import my_package

print(my_package.re,"\n", my_package.os)
```
运行结果：
```
<module 're' from 'C:\\Users\\Garin\\AppData\\Local\\Programs\\Python\\Python310\\lib\\re.py'> 
 <module 'os' from 'C:\\Users\\Garin\\AppData\\Local\\Programs\\Python\\Python310\\lib\\os.py'>
```
**结果分析：**
&emsp;&emsp; 显然，导入一个包的时候导入的是它最外层的`__init__.py`文件。


# Python中模块搜索路径





#  `import`模块时建议怎么做？
不要一行把所有的导入，因为一旦发生错误，很难知道具体是哪个包导入的时候报错了：
```python
import package1, package2, package3
```
而应该分开写:
```python
import package1
import package2
import package3
```

