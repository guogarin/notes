- [一、并发(Concurrency)和并行(Parallelism)](#一并发concurrency和并行parallelism)
  - [1. 并发和并行有何区别？](#1-并发和并行有何区别)
  - [2. 执行单元(Execution unit)](#2-执行单元execution-unit)
  - [python的并发模型](#python的并发模型)
- [二、 GIL锁](#二-gil锁)
  - [1 什么是GIL锁？](#1-什么是gil锁)
  - [2 GIL锁 是Python带来的吗？](#2-gil锁-是python带来的吗)
  - [3 为什么需要GIL？](#3-为什么需要gil)
    - [3.1 GIL 为Python解决了什么问题？](#31-gil-为python解决了什么问题)
    - [3.2 为什么选择 全局锁？而不是给每个对象的引用计数单独枷锁？](#32-为什么选择-全局锁而不是给每个对象的引用计数单独枷锁)
    - [3.3 其它原因](#33-其它原因)
    - [3.4 总结](#34-总结)
  - [4 GIL 是如何运作的？](#4-gil-是如何运作的)
  - [5 为什么不在 Python 3 中删除它？](#5-为什么不在-python-3-中删除它)
  - [6 GIL锁的影响](#6-gil锁的影响)
    - [6.1 GIL会带来什么影响？](#61-gil会带来什么影响)
    - [6.2 多线程编程中，如何最大程度的避免GIL锁带来的影响？](#62-多线程编程中如何最大程度的避免gil锁带来的影响)
  - [7 GIL是否意味着线程安全？](#7-gil是否意味着线程安全)
  - [8 GIL锁的存在是否意味着python多线程一点用也没有了？](#8-gil锁的存在是否意味着python多线程一点用也没有了)
  - [参考文献](#参考文献)
- [三、协程(Coroutines)](#三协程coroutines)
  - [1. 什么是协程？](#1-什么是协程)
  - [2. 协程和线程](#2-协程和线程)
    - [2.1 协程是多线程吗？](#21-协程是多线程吗)
    - [2.2 协程和线程的对比](#22-协程和线程的对比)
    - [2.3 协程的优势和应用场景](#23-协程的优势和应用场景)
  - [3. 协程的发展](#3-协程的发展)
    - [3.1 Python和协程相关的关键字和方法的引入过程](#31-python和协程相关的关键字和方法的引入过程)
  - [4 python的经典协程](#4-python的经典协程)
    - [4.1 用作协程的生成器的基本行为](#41-用作协程的生成器的基本行为)
    - [4.2 协程的四种状态](#42-协程的四种状态)
    - [4.3 预激协程(Coroutine Priming)](#43-预激协程coroutine-priming)
      - [4.3.1 预激协程](#431-预激协程)
      - [4.3.2 用装饰器来预激协程](#432-用装饰器来预激协程)
    - [4.5 图解运行流程](#45-图解运行流程)
    - [4.6 终止协程和异常处理(Coroutine Termination and Exception Handling)](#46-终止协程和异常处理coroutine-termination-and-exception-handling)
      - [4.6.1 若不处理协程内部发生的异常，会发生什么？](#461-若不处理协程内部发生的异常会发生什么)
      - [4.6.2 `throw()` 和 `close()`](#462-throw-和-close)
        - [(1)  `throw()` 和 `close()`简介](#1--throw-和-close简介)
        - [(2) `throw()` 和 `close()`的使用示例](#2-throw-和-close的使用示例)
    - [4.7 从协程返回值(Returning a Value from a Coroutine)](#47-从协程返回值returning-a-value-from-a-coroutine)
      - [4.7.1 如何从协程返回值](#471-如何从协程返回值)
      - [4.7.2 如何获取协程返回的值？](#472-如何获取协程返回的值)
    - [4.8 在协程中使用`yield from`](#48-在协程中使用yield-from)
      - [4.8.1 `yield from`在协程中的作用](#481-yield-from在协程中的作用)
      - [4.8.2 在协程中使用`yield from` 需要了解的几个概念](#482-在协程中使用yield-from-需要了解的几个概念)
        - [(1) 几个概念](#1-几个概念)
      - [(2) 委派生成器 的作用是？](#2-委派生成器-的作用是)
      - [(3) 子生成器 如何 终止？](#3-子生成器-如何-终止)
      - [4.8.3 `yield from`使用实例：用 `yield from` 计算平均值并输出统计报告](#483-yield-from使用实例用-yield-from-计算平均值并输出统计报告)
      - [4.8.4 调用方、委派生成器 和 子生成器是如何通信的？](#484-调用方委派生成器-和-子生成器是如何通信的)
      - [4.8.5 如果把`coroaverager3.py`中⓬处的`group.send(None)`会发生什么？](#485-如果把coroaverager3py中处的groupsendnone会发生什么)
        - [(1) `group.send(None)`这行代码的作用是什么？](#1-groupsendnone这行代码的作用是什么)
        - [(2) 注释掉`group.send(None)`会发生什么？](#2-注释掉groupsendnone会发生什么)
    - [4.8.6 用`yield from`连接多个 委派生成器](#486-用yield-from连接多个-委派生成器)
    - [4.8.7 `yield from`在协程中的现状](#487-yield-from在协程中的现状)
    - [4.9 使用`@asyncio.coroutine`来定义协程](#49-使用asynciocoroutine来定义协程)
      - [4.9.1 `@asyncio.coroutine`是什么？](#491-asynciocoroutine是什么)
      - [4.9.2 `@asyncio.coroutine`现状](#492-asynciocoroutine现状)
  - [5 原生协程(native coroutines)](#5-原生协程native-coroutines)
    - [5.1 什么是原生协程？什么是 非原生协程？](#51-什么是原生协程什么是-非原生协程)
    - [5.2 需要先了解的几个概念](#52-需要先了解的几个概念)
    - [5.3 原生协程的定义和使用](#53-原生协程的定义和使用)
      - [5.3.1 定义原生协程](#531-定义原生协程)
      - [5.3.2 使用原生协程](#532-使用原生协程)
    - [5.4 任务对象`task`](#54-任务对象task)
    - [5.4 绑定回调函数](#54-绑定回调函数)
    - [5.5 多任务](#55-多任务)
    - [5.7 `yield from` 转 `async/await`](#57-yield-from-转-asyncawait)
  - [6 原生协程 和  基于生成器的协程](#6-原生协程-和--基于生成器的协程)
  - [7 `asyncio`](#7-asyncio)
  - [实现协程的几种方式](#实现协程的几种方式)
  - [基于生成器的协程(generator based coroutines)](#基于生成器的协程generator-based-coroutines)
  - [Async I/O and the asyncio module （异步IO和asyncio模块）](#async-io-and-the-asyncio-module-异步io和asyncio模块)
  - [参考文献](#参考文献-1)






&emsp;
&emsp; 
# 一、并发(Concurrency)和并行(Parallelism)
## 1. 并发和并行有何区别？
并发(Concurrency)：
> &emsp;&emsp; The ability to handle multiple pending tasks, making progress one at a time or in parallel (if possible) so that each of them eventually succeeds or fails. A singlecore CPU is capable of concurrency if it runs an OS scheduler that interleaves the execution of the pending tasks. Also known as multitasking.
> &emsp;&emsp; 
> 
并行(Parallelism)
> &emsp;&emsp; The ability to execute multiple computations at the same time. This requires a multicore CPU, multiple CPUs, a GPU, or multiple computers in a cluster.
> &emsp;&emsp; 
> 
## 2. 执行单元(Execution unit)
> &emsp;&emsp; General term for objects that execute code concurrently, each with independent state and call stack. Python natively supports three kinds of execution units: processes, threads, and coroutines.
> &emsp;&emsp; 
> 

Effective Python 第七章的前言总结的很好。
TODO: 把内容复制过来

## python的并发模型




&emsp;
&emsp; 
# 二、 GIL锁
## 1 什么是GIL锁？
&emsp;&emsp; `GIL`全称`Global Interpreter Lock`(全局解释器锁)，缩写GIL）,是计算机程序设计语言解释器 **用于同步线程** 的一种机制，它使得任何时刻仅有一个线程在执行。
&emsp;&emsp; 简单来说，GIL 是一个互斥锁，它规定解释器同一时刻只允许一个线程运行。

&emsp;
## 2 GIL锁 是Python带来的吗？
&emsp;&emsp; 首先需要明确的一点是`GIL`并不是Python的特性，它是**在实现Python解析器(CPython)时**所引入的一个概念。
&emsp;&emsp; 我们知道python有`CPython`，`PyPy`和`JPython`。像其中的`JPython`就没有`GIL`。然而因为`CPython`是大部分环境下默认的Python执行环境。所以在很多人的概念里`CPython`就是Python，也就想当然的把`GIL`归结为Python语言的缺陷。所以这里要先明确一点：`GIL`并不是Python的特性，Python完全可以不依赖于`GIL`。

&emsp;
## 3 为什么需要GIL？
### 3.1 GIL 为Python解决了什么问题？
&emsp;&emsp; 我们知道，Python的内存管理是通过引用计数(reference counting)来完成的。当某对象的引用计数变量的值为 0 时，会将这个对象在内存中占用的资源释放。下面通过一个例子来看看引用计数如何工作：
```python
import sys

a = []
b = a 
print(sys.getrefcount(a))
```
运行结果：
```
3
```
**结果分析：**
&emsp;&emsp; 这`3`个分别是：`a`, `b`, `sys.getrefcount()`
问题是在多个线程试图修改这个 引用计数变量 时会引发竞态条件：
> &emsp;&emsp; 假设有两个线程A和B，它们共享了一个dict对象，在同一时刻，线程A增加了这个dict的引用计数，而线程B减少了这个dict的引用计数，此时就引发了竟态条件，这个dict的引用计数的值很可能就不准确了，这可能造成 内存泄漏 或 内存被提前释放，或者其它莫名其妙的bug。
> 
因此，为防止上述竟态条件的发生，必须给它加锁。

### 3.2 为什么选择 全局锁？而不是给每个对象的引用计数单独枷锁？
&emsp;&emsp; 如果我们给每个创建的对象都加上一把锁，那么很可能会出现一个问题 —— 死锁。
&emsp;&emsp; 另外，给每个对象的引用计数都加锁的话，会因为频繁的获取/释放锁而降低程序的性能。
因此，不能给每个对象的引用计数单独枷锁，只能用全局锁。

### 3.3 其它原因
&emsp;&emsp; 在 Python 刚诞生那会儿，操作系统甚至还没有线程这个概念。Python 的设计初衷：易学易用，加快开发者们工作的进度。
&emsp;&emsp; 另外GIL 比较容易实现，添加到 Python 中也很方便。因为只需要管理一个锁，提高了单线程程序的性能。

### 3.4 总结
&emsp;&emsp; Python的内存管理是通过引用计数来完成的，但问题是这个引用计数并不是线程安全的，多个线程在修改引用计数时可能会引发的竟态条件，所以必须加锁，此时我们有两种方案：
> ① 给每个对象的引用计数单独枷锁
> ② 加一个全局锁
> 
但问题是给每个对象的引用计数单独枷锁会导致死锁，而且频繁的加解锁也会降低程序性能，所以只能加一个全局锁(即GIL)来保护 引用计数。

&emsp;
## 4 GIL 是如何运作的？
TODO:

&emsp;
## 5 为什么不在 Python 3 中删除它？
**(1) 去掉GIL会降低单线程性能**
&emsp;&emsp; Python3 确实有机会从头开始，包括重写现存的一些 C 扩展。但 GIL并不是一无是处，它的存在使python的单线程的性能非常强大，曾经有人实现过不带GIL的解释器，但代价却是单线程性能却下降了好几倍。
**(2) 对于那些必须高效利用CPU核心的应用，可以寻求其它替代方案**
&emsp;&emsp; 对于IO密集型引用，GIL影响很小；而对于CPU密集型应用，可以使用其它替代方案(如多进程)。

&emsp;
## 6 GIL锁的影响
### 6.1 GIL会带来什么影响？
&emsp; GIL主要会影响多线程程序：
> &emsp;&emsp; 尽管Python完全支持多线程编程，但是解释器的C语言实现部分在完全并行执行时并不是线程安全的。 实际上，解释器被一个全局解释器锁保护着，它确保任何时候都只有一个Python线程执行。
> 
带来的问题是：
> &emsp;&emsp; Python的多线程程序并不能利用多核CPU的优势，对于一个使用了多个线程的程序，同一时间只能有一个线程被执行，即使其它几个CPU都是空闲状态。
> 

### 6.2 多线程编程中，如何最大程度的避免GIL锁带来的影响？
&emsp; 我们都知道，程序大概可以分成两类
> &emsp;&emsp; ① IO密集型
> &emsp;&emsp; ② CPU密集型
> 
对于**IO密集型**的多线程程序，`GIL` 对 的很友好，可以大大提高其性能。因为它们大部分时间都在等待，当一个线程等待 I/O 的时候，GIL让前者睡眠，然后启动另外的线程。
而对于**CPU密集型**的多线程程序，如果GIL 的存在给程序性能造成了影响，可以尝试一下的解决方案：
> &emsp;&emsp; ① 使用多进程；
> &emsp;&emsp; ② 换个解释器

&emsp;
## 7 GIL是否意味着线程安全？
&emsp;&emsp; 不是

&emsp;
## 8 GIL锁的存在是否意味着python多线程一点用也没有了？
&emsp;&emsp; 不是，GIL只对CPU密集型应用影响比较大，IO密集型应用影响有限。

&emsp;
## 参考文献
1. [翻译：什么是全局解释器锁GIL？](https://zhuanlan.zhihu.com/p/67349209)
2. [What Is the Python Global Interpreter Lock (GIL)?](https://realpython.com/python-gil/)
3. [CPython有GIL是因为当年设计CPython的人偷懒吗？](https://www.zhihu.com/question/439920631/answer/1685766305)
4. [为什么 Python的GIL问题一直让人诟病，Python社区却不解决？](https://www.zhihu.com/question/323812020/answer/2219586213)
5. [面试官：你如何破解 Python的 GIL 的？这才是完美的回答](https://zhuanlan.zhihu.com/p/407236410)
6. [深入理解Python中的GIL](https://zhuanlan.zhihu.com/p/75780308)
7. [python cookbook]()
8. [python的GIL锁](https://blog.csdn.net/qq_43517875/article/details/109131380)







&emsp;
&emsp; 
# 三、协程(Coroutines)
## 1. 什么是协程？
&emsp;&emsp; 协程，又称微线程，纤程，是一种用户态的轻量级线程。

## 2. 协程和线程
### 2.1 协程是多线程吗？
&emsp;&emsp; 协程本质上是单线程，拥有自己的寄存器上下文和栈。所以能保留上一次调用时的状态，每次过程重入时，就相当于进入上一次调用的状态。
TODO:
### 2.2 协程和线程的对比

### 2.3 协程的优势和应用场景

## 3. 协程的发展
### 3.1 Python和协程相关的关键字和方法的引入过程
(1) Python 2.2  `yield`

(2) Python 2.5  `send()` `throw()` `close()`，标志着python开始支持协程；

(3) Python 3.3  `yield from`，使python协程语法简化了；

(4) Python 3.5  `async` 和 `await`，标志着python支持 原生协程(native coroutine)

## 4 python的经典协程
&emsp;&emsp; 在Python2.5引入`send()` `throw()` `close()`后，标志着python支持协程了。最开始的协程是通过生成器（generator）实现的。
### 4.1 用作协程的生成器的基本行为
```python
>>> def simple_coroutine(): # ➊
...     print('-> coroutine started')
...     x = yield # ➋
...     print('-> coroutine received:', x)
...

>>> my_coro = simple_coroutine()
>>> my_coro # ➌
<generator object simple_coroutine at 0x100c2be10>

>>> next(my_coro) # ➍
-> coroutine started

>>> my_coro.send(42) # ➎
-> coroutine received: 42
Traceback (most recent call last): # ➏
  ...
StopIteration
```
> ❶ 协程使用生成器函数定义： 定义体中有 `yield` 关键字。
> ❷ `yield` 在表达式中使用； 如果协程只需从客户那里接收数据， 那么产出的值是 `None`——这个值是隐式指定的， 因为 `yield` 关键字右边没有表达式。
> ❸ 与创建生成器的方式一样， 调用函数得到生成器对象。
> ❹ 首先要调用 `next(...)` 函数， 因为生成器还没启动， 没在 `yield` 语句处暂停， 所以一开始无法发送数据。
> ❺ 调用这个方法后， 协程定义体中的 `yield` 表达式会计算出 `42`； 现在， 协程会恢复， 一直运行到下一个`yield` 表达式， 或者终止。
> ❻ 这里， 控制权流动到协程定义体的末尾， 导致生成器像往常一样抛出 `StopIteration` 异常。

### 4.2 协程的四种状态
&emsp;&emsp; 协程可以身处四个状态中的一个。当前状态可以使用 `inspect.getgeneratorstate(...)`函数确定， 该函数会返回下述字符串中的一个：
> ① `GEN_CREATED` 协程生成器创建完成，等待开始执行。
> ② `GEN_RUNNING` 解释器正在执行。
> ③ `GEN_SUSPENDED` 在`yield`表达式处暂停。
> ④ `GEN_CLOSED`  执行结束。
> 

### 4.3 预激协程(Coroutine Priming)
#### 4.3.1 预激协程
&emsp;&emsp; 如果不预激，那么协程没什么用。调用 `my_coro.send(x)` 之前，记住一定要调用 `next(my_coro)`。

#### 4.3.2 用装饰器来预激协程
为了简化协程的用法，有时会使用一个预激装饰器，比如：
```python
from functools import wraps
```
下面的代码在命令行运行：
```python
def coroutine(func):
    """Decorator: primes `func` by advancing to first `yield`"""
    @wraps(func)
    def primer(*args,**kwargs):
        gen = func(*args,**kwargs)
        next(gen)  #  预激生成器
        return gen # 返回预激的生成器
    return primer


@coroutine # ➎
def averager(): # ➏
    total = 0.0
    count = 0
    average = None
    while True:
        term = yield average
        total += term
        count += 1
        average = total/count
```
在命令行运行一下上面的代码：
```python
'''
    关于 @coroutine装饰器 和 averager()的定义省略...
'''

>>> coro_avg = averager()

>>> coro_avg.send(40) # ➊
40.0

>>> coro_avg.send(50)
45.0

>>> coro_avg.send('spam') # ➋  
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "<stdin>", line 8, in averager
TypeError: unsupported operand type(s) for +=: 'float' and 'str'

>>> coro_avg.send(60) # ➌
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
StopIteration
```
> ❶ 调用 `averager()` 函数创建一个生成器对象， 在 `coroutine` 装饰器的 `primer` 函数中已经预激了这个生成器。
> ❷ `getgeneratorstate` 函数指明， 处于 `GEN_SUSPENDED` 状态， 因此这个协程已经准备好， 可以接收值了。
> ❸ 可以立即开始把值发给 `coro_avg`——这正是 `coroutine` 装饰器的目的。
> 


### 4.5 图解运行流程
```python
>>> def simple_coro2(a):
...     print('-> Started: a =', a)
...     b = yield a
...     print('-> Received: b =', b)
...     c = yield a + b
...     print('-> Received: c =', c)
...
>>> my_coro2 = simple_coro2(14)
>>> from inspect import getgeneratorstate
>>> getgeneratorstate(my_coro2) # ➊ 
'GEN_CREATED'

>>> next(my_coro2) # ➋
-> Started: a = 14
14

>>> getgeneratorstate(my_coro2) # ➌
'GEN_SUSPENDED'

>>> my_coro2.send(28) # ➍
-> Received: b = 28
42

>>> my_coro2.send(99) # ➎
-> Received: c = 99
Traceback (most recent call last):
File "<stdin>", line 1, in <module>
StopIteration

>>> getgeneratorstate(my_coro2) # ➏
'GEN_CLOSED'
```
> ❶ `inspect.getgeneratorstate` 函数指明， 处于 `GEN_CREATED` 状态（即协程未启动） 。
> ❷ 向前执行协程到第一个 `yield` 表达式， 打印 `-> Started: a = 14` 消息， 然后产出 `a` 的值， 并且暂停， 等待为 `b` 赋值。
> ❸ `getgeneratorstate` 函数指明， 处于 `GEN_SUSPENDED` 状态（即协程在 `yield` 表达式处暂停） 。
> ❹ 把数字 `28` 发给暂停的协程； 计算 `yield` 表达式， 得到 `28`， 然后把那个数绑定给 `b`。 打印 `-> Received: b = 28` 消息， 产出 `a + b` 的值（42） ， 然后协程暂停， 等待为 `c` 赋值。
> ❺ 把数字 `99` 发给暂停的协程； 计算 `yield` 表达式， 得到 `99`， 然后把那个数绑定给 `c`。 打印 `-> Received: c = 99` 消息， 然后协程终止， 导致生成器对象抛出 `StopIteration` 异常。
> ❻ `getgeneratorstate` 函数指明， 处于 `GEN_CLOSED` 状态（即协程执行结束） 。
> 
&emsp;&emsp; 关键的一点是， 协程在 `yield` 关键字所在的位置暂停执行。 前面说过， 在赋值语句中， `=` 右边的代码在赋值之前执行。 因此， 对于 `b = yield a` 这行代码来说， 等到客户端代码再激活协程时才会设定 `b` 的值。这种行为要花点时间才能习惯， 不过一定要理解， 这样才能弄懂异步编程中 yield 的作用（后文探讨） `。simple_coro2` 协程的执行过程分为 `3` 个阶段， 如图下图所示：
> (1) 调用 `next(my_coro2)`， 打印第一个消息， 然后执行 yield a， 产出数字 14。
> (2) 调用 `my_coro2.send(28)`， 把 `28` 赋值给 `b`， 打印第二个消息， 然后执行 `yield a + b`， 产出数字`42`。
> (3) 调用 `my_coro2.send(99)`， 把 `99` 赋值给 `c`， 打印第三个消息， 协程终止。
> 
<div align="center"><img src="./pic/the execution of the simple_coro2 coroutine.png"></div>
&emsp;&emsp; 图：执行 simple_coro2 协程的 3 个阶段（注意， 各个阶段都在 yield 表达式中结束， 而且下一个阶段都从那一行代码开始， 然后再把 yield 表达式的值赋给变量）

**总结一下：每次遇到`yield`就返回到调用者这边**

### 4.6 终止协程和异常处理(Coroutine Termination and Exception Handling)
&emsp;&emsp; 协程中未处理的异常会向上冒泡，传给 `next()` 函数或 `send()` 方法的调用方（即触发协程的对象） 
#### 4.6.1 若不处理协程内部发生的异常，会发生什么？
未处理的异常 **会导致协程终止**：
```python
'''
    关于 @coroutine装饰器 和 averager()的定义省略...
'''

>>> coro_avg = averager()

>>> coro_avg.send(40) # ➊
40.0

>>> coro_avg.send(50)
45.0

>>> coro_avg.send('spam') # ➋
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "<stdin>", line 8, in averager
TypeError: unsupported operand type(s) for +=: 'float' and 'str'

>>> coro_avg.send(60) # ➌
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
StopIteration
```
> ❶ 使用 `@coroutine` 装饰器装饰的 `averager` 协程， 可以立即开始发送值。
> ❷ 发送的值不是数字， 导致协程内部有异常抛出。
> ❸ 由于在协程内没有处理异常， 协程会终止。 如果试图重新激活协程， 会抛出 StopIteration 异常。
> 

#### 4.6.2 `throw()` 和 `close()`
##### (1)  `throw()` 和 `close()`简介
```python
generator.throw(exc_type[, exc_value[, traceback]])
```
&emsp;&emsp; 致使生成器在暂停的 `yield` 表达式处抛出指定的异常：
> &emsp;&emsp; ① 如果生成器处理了抛出的异常，代码会向前执行到下一个 `yield` 表达式， 而产出的值会成为`generator.throw()`的返回值；
> &emsp;&emsp; ② 如果生成器没有处理抛出的异常，则异常会向上冒泡，传到调用方的上下文中。
> 
```python
generator.close()
```
&emsp;&emsp; 致使生成器在暂停的 yield 表达式处抛出 GeneratorExit 异常。 如果生成器没有处理这个异常， 或者抛出了 StopIteration 异常（通常是指运行到结尾） ， 调用方不会报错。 如果收到 GeneratorExit 异常， 生成器一定不能产出值， 否则解释器会抛出 RuntimeError 异常。 生成器抛出的其他异常会向上冒泡， 传给调用方。
##### (2) `throw()` 和 `close()`的使用示例
```python
class DemoException(Exception):
    """An exception type for the demonstration."""

def demo_exc_handling():
    print('-> coroutine started')
    while True:
        try:
            x = yield
        except DemoException: # 特别处理 DemoException 异常。
            print('*** DemoException handled. Continuing...')
        else: # 如果没有异常， 那么显示接收到的值。
            print('-> coroutine received: {!r}'.format(x))
    raise RuntimeError('This line should never run.')
```
**① 在不使用异常的情况下关闭协程**
```python
>>> exc_coro = demo_exc_handling()
>>> next(exc_coro)
-> coroutine started
>>> exc_coro.send(11)
-> coroutine received: 11
>>> exc_coro.send(22)
-> coroutine received: 22
>>> exc_coro.close()
>>> from inspect import getgeneratorstate
>>> getgeneratorstate(exc_coro)
'GEN_CLOSED'
```

**② 如果异常在协程内部被处理了，则不会导致该协程被中止**
```python
>>> exc_coro = demo_exc_handling()
>>>  next(exc_coro)
  File "<stdin>", line 1
    next(exc_coro)
IndentationError: unexpected indent
>>> next(exc_coro)
-> coroutine started
>>> exc_coro.send(11)
-> coroutine received: 11
>>> exc_coro.throw(DemoException)
*** DemoException handled. Continuing...
>>> getgeneratorstate(exc_coro)
'GEN_SUSPENDED'
```
**③ 如果无法处理传入的异常， 协程会终止**
```python
>>> exc_coro = demo_exc_handling()
>>> next(exc_coro)
-> coroutine started
>>> exc_coro.send(11)
-> coroutine received: 11
>>> exc_coro.throw(ZeroDivisionError)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "<stdin>", line 5, in demo_exc_handling
ZeroDivisionError
>>> getgeneratorstate(exc_coro)
'GEN_CLOSED'
```
**④ 使用 `try/finally` 块在协程终止时执行操作**
```python
class DemoException(Exception):
    """An exception type for the demonstration."""

def demo_finally():
    print('-> coroutine started')
    try:
        while True:
            try:
                x = yield
            except DemoException:
                print('*** DemoException handled. Continuing...')
            else:
                print('-> coroutine received: {!r}'.format(x))
    finally:
        print('-> coroutine ending')

exc_coro = demo_finally()
next(exc_coro)
exc_coro.send(11)

print("\n" + "*" * 30 + "\n")

exc_coro.throw(ZeroDivisionError)
```
运行结果：
```
-> coroutine started
-> coroutine received: 11

******************************

-> coroutine ending
Traceback (most recent call last):
  File "d:\code_practice\practice.py", line 23, in <module>
    exc_coro.throw(ZeroDivisionError)
  File "d:\code_practice\practice.py", line 9, in demo_finally
    x = yield
ZeroDivisionError
```
可以看到的是，在异常上冒的时候，`finnally`子句被运行了。

### 4.7 从协程返回值(Returning a Value from a Coroutine)
#### 4.7.1 如何从协程返回值
下面是协程`averager`的不同版本，此版会返回结果：
```python
from collections import namedtuple

Result = namedtuple('Result', 'count average')

def averager():
    total = 0.0
    count = 0
    average = None
    while True:
        term = yield
        if term is None:
            break # ➊
        total += term
        count += 1
        average = total/count
    return Result(count, average) # ➋

>>> coro_avg = averager()
>>> next(coro_avg)
>>> coro_avg.send(10)  # ❸
>>> coro_avg.send(30)
>>> coro_avg.send(6.5)
>>> coro_avg.send(None) # ❹
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
StopIteration: Result(count=3, average=15.5)
```
> ❶ 为了返回值， 协程必须正常终止； 因此， 这一版 `averager` 中有个条件判断， 以便退出累计循环。
> ❷ 返回一个 `namedtuple`， 包含 `count` 和 `average` 两个字段。 注意，在 Python3.3 之前， 如果生成器返回值， 解释器会报句法错误
> ❸ 这一版不产出值。
> ❹ 发送 `None` 会终止循环， 导致协程结束， 返回结果。 一如既往， 生成器对象会抛出 `StopIteration` 异常。 异常对象的 `value` 属性保存着返回的值。
> 
**总结：**
&emsp;&emsp; 从协程中返回值和普通函数一样，直接`return`就行，但是注意， `return` 表达式的值是偷偷传给调用方的：
> 返回值被赋值给 `StopIteration` 异常的一个属性。 
> 
这样做有点不合常理， 但是能保留生成器对象的常规行为——耗尽时抛出 `StopIteration` 异常。那应该怎么正常获取`return`的值呢？

#### 4.7.2 如何获取协程返回的值？
很简单，使用`try/catch`表达式：
```python
"以下代码在命令行执行："
>>> coro_avg = averager()
>>> next(coro_avg)
>>> coro_avg.send(10)  # 
>>> coro_avg.send(30)
>>> coro_avg.send(6.5) # 
>>> try:
...     coro_avg.send(None)
... except StopIteration as exc:
...     result = exc.value
...
>>> result
Result(count=3, average=15.5)
```
**在yield from**被引入前，我们只能使用这种方法获取协程的返回值，但`yield from`被引入后，就不需要这么麻烦了：
> `yield from`结构会在内部自动捕获 `StopIteration` 异常。 这种处理方式与 `for` 循环处理`StopIteration `异常的方式一样： 循环机制使用用户易于理解的方式处理异常。
> 对 `yield from` 结构来说， 解释器不仅会捕获 `StopIteration` 异常， 还会把 `value` 属性的值变成 `yield from` 表达式的值。
> 

&emsp;
### 4.8 在协程中使用`yield from`
####  4.8.1 `yield from`在协程中的作用
**作用一：打开双向通道：**
&emsp;&emsp; 在协程中，`yield from` 的主要功能是打开双向通道， 把最外层的调用方与最内层的子生成器连接起来， 这样二者可以直接发送和产出值， 还可以直接传入异常， 而不用在位于中间的协程中添加大量处理异常的样板代码。有了这个结构， 协程可以通过以前不可能的方式委托职责。
**作用二：以一种更简化的方式获取协程的返回值：**
&emsp;&emsp; 另外，当需要通过 协程返回值时，我们需要通过 异常处理（即使用`try/catch`表达式）来获取协程的返回值，但`yield from` 会捕获 `StopIteration` 异常， 而且还会把 `value` 属性的值变成 `yield from` 表达式的值，换句话说，用`yield from`可以简化代码（不用处理`StopIteration` 异常）。

#### 4.8.2 在协程中使用`yield from` 需要了解的几个概念
##### (1) 几个概念
① **委派生成器(delegating generator)**
> 包含 `yield from <iterable>` 表达式的生成器函数。
> 

② **子生成器(subgenerator)**
> `yield from <iterable>` 表达式中的 `<iterable>` 
> 

③ **调用方(caller)**

#### (2) 委派生成器 的作用是？
主要有两个作用：
> ① 作为“管道” **连接 调用方 和 子生成器**；
> ② 当子生成器结束后，**接收子生成器的返回值**
> 

#### (3) 子生成器 如何 终止？
&emsp;&emsp; 由 调用方 来控制，一般是由调用放`send(None)`，子生成器 收到`None`主动终止，然后返回。

#### 4.8.3 `yield from`使用实例：用 `yield from` 计算平均值并输出统计报告
```python
'coroaverager3.py'

from collections import namedtuple

Result = namedtuple('Result', 'count average')

# 子生成器
def averager(): # ➊
    total = 0.0
    count = 0
    average = None
    while True:
        term = yield # ➋
        if term is None: # ➌
            break
        total += term
        count += 1
        average = total/count
    return Result(count, average) # ➍


# 委派生成器
def grouper(results, key): # ➎
    while True: # ➏
        results[key] = yield from averager() # ➐


# 客户端代码， 即调用方
def main(data): # ➑
    results = {}
    for key, values in data.items():
        group = grouper(results, key) # ➒
        next(group) # ➓
        for value in values:
            group.send(value) # ⓫
        group.send(None) # 重要！ ⓬
    print(results) # 如果要调试， 去掉注释
    report(results)
    

# 输出报告
def report(results):
    for key, result in sorted(results.items()):
        group, unit = key.split(';')
        print('{:2} {:5} averaging {:.2f}{}'.format(
                result.count, group, result.average, unit))

data = {
    'girls;kg':
        [40.9, 38.5, 44.3, 42.2, 45.2, 41.7, 44.5, 38.0, 40.6, 44.5],
    'girls;m':
        [1.6, 1.51, 1.4, 1.3, 1.41, 1.39, 1.33, 1.46, 1.45, 1.43],
    'boys;kg':
        [39.0, 40.8, 43.2, 40.8, 43.1, 38.6, 41.4, 40.6, 36.3],
    'boys;m':
        [1.38, 1.5, 1.32, 1.25, 1.37, 1.48, 1.25, 1.49, 1.46],
} 

if __name__ == '__main__':
    main(data)
```
运行结果：
```
 9 boys  averaging 40.42kg
 9 boys  averaging 1.39m
10 girls averaging 42.04kg
10 girls averaging 1.43m
```
**代码解析：**
> ❶ 与示例 16-13 中的 averager 协程一样。 这里作为子生成器使用。
> ❷ main 函数中的客户代码发送的各个值绑定到这里的 term 变量上。
> ❸ 至关重要的终止条件。 如果不这么做， 使用 yield from 调用这个协程的生成器会永远阻塞。
> ❹ 返回的 Result 会成为 grouper 函数中 yield from 表达式的值。
> ❺ grouper 是委派生成器。
> ❻ 这个循环每次迭代时会新建一个 averager 实例； 每个实例都是作为协程使用的生成器对象。
> ❼ grouper 发送的每个值都会经由 yield from 处理， 通过管道传给 averager 实例。 grouper 会在`yield from` 表达式处暂停， 等待 averager 实例处理客户端发来的值。 averager 实例运行完毕后， 返回的值绑定到 results[key] 上。 while 循环会不断创建 averager 实例， 处理更多的值。
> ❽ main 函数是客户端代码， 用 PEP 380 定义的术语来说， 是“调用方”。 这是驱动一切的函数。
> ❾ group 是调用 grouper 函数得到的生成器对象， 传给 grouper 函数的第一个参数是 results， 用于收集结果； 第二个参数是某个键。 group 作为协程使用。
> ❿ 预激 group 协程。
> ⓫ 把各个 value 传给 grouper。 传入的值最终到达 averager 函数中 term = yield 那一行； grouper永远不知道传入的值是什么。
> ⓬ 把 None 传入 grouper， 导致当前的 averager 实例终止， 也让 grouper 继续运行， 再创建一个averager 实例， 处理下一组值。
> 
代码中最后一个标号前面有个注释——“重要！ ”， 强调这行代码（group.send(None)） 至关重要：终止当前的 averager 实例， 开始执行下一个。 如果注释掉那一行， 这个脚本不会输出任何报告。 此时，把 main 函数靠近末尾的 print(results) 那行的注释去掉， 你会发现， results 字典是空的。


#### 4.8.4 调用方、委派生成器 和 子生成器是如何通信的？
&emsp;&emsp; 在每次调用`send(value)`时，`value`不是传递给委派生成器，而是借助`yield from`将`value`传递给了子生成器的`yield`。
&emsp;&emsp; 对于上面用 `yield from` 计算平均值并输出统计报告的脚本`coroaverager3.py`，它的通信示意图如下所示：
<div align="center"><img src="./pic/yield from in coroutine.png"></div>

#### 4.8.5 如果把`coroaverager3.py`中⓬处的`group.send(None)`会发生什么？
##### (1) `group.send(None)`这行代码的作用是什么？
&emsp;&emsp; `group.send(None)`相当于一个终止器，它的作用是 让子生成器终止。
##### (2) 注释掉`group.send(None)`会发生什么？
&emsp;&emsp; 如果注释掉了这行，那子生成器就不会终止，委派生成器会在 `yield from` 表达式处永远暂停。 如果是这样 程序不会向前执行， 因为 `yield from`（与 `yield` 一样） 把控制权转交给客户代码（即， 委派生成器的调用方）了。显然， 肯定有任务无法完成。
让我们把`group.send(None)`注释掉，运行结果如下：
```
{}
```
可以看到的是，程序返回了一个空字典，让我们来分析一下代码的执行过程：
> &emsp;&emsp; 外层 `for` 循环每次迭代会新建一个 `grouper` 实例， 赋值给 `group` 变量； `group` 是委派生成器。
> &emsp;&emsp; 调用 `next(group)`， 预激委派生成器 `grouper`， 此时进入 `while True` 循环， 调用子生成器`averager` 后， 在 `yield from` 表达式处暂停。
> &emsp;&emsp; 内层 `for` 循环调用 `group.send(value)`， 直接把值传给子生成器 `averager`。 同时， 当前的 `grouper`实例（`group`） 在 `yield from` 表达式处暂停。
> &emsp;&emsp; 内层循环结束后， group 实例依旧在 `yield from` 表达式处暂停， 因此， `grouper` 函数定义体中为`results[key]` 赋值的语句还没有执行。
> &emsp;&emsp; 如果外层 `for` 循环的末尾没有 `group.send(None)`， 那么 `averager` 子生成器永远不会终止， 委派生成器 `group` 永远不会再次激活， 因此永远不会为 `results[key]` 赋值。
> &emsp;&emsp; 外层 `for` 循环重新迭代时会新建一个 `grouper` 实例， 然后绑定到 `group` 变量上。 前一个 `grouper` 实例（以及它创建的尚未终止的 `averager` 子生成器实例） 被垃圾回收程序回收。
> 

### 4.8.6 用`yield from`连接多个 委派生成器
&emsp;&emsp; `coroaverager3.py`展示了 `yield from` 结构最简单的用法，只有一个委派生成器和一个子生成器。因为委派生成器相当于管道， 所以可以把任意数量个委派生成器连接在一起： 一个委派生成器使用 `yield from` 调用一个子生成器，而那个子生成器本身也是委派生成器，使用 `yield from` 调用另一个子生成器， 以此类推。最终， 这个链条要以一个只使用 yield 表达式的简单生成器结束； 不过， 也能以任何可迭代的对象结束。
&emsp;&emsp; 另外，任何 `yield from` 链条都必须由客户驱动， 在最外层委派生成器上调用 `next(...)` 函数或 `.send(...)` 方法。 可以隐式调用， 例如使用 `for` 循环。

### 4.8.7 `yield from`在协程中的现状
来看看《Fluent python》第二版的原文：
> &emsp;&emsp; With the advent of native coroutines in Python 3.5, the Python core developers are gradually phasing out support for classic coroutines in asyncio. But the underlying mechanisms are very similar. The async def syntax makes native coroutines easier to spot in code, which is a great benefit. Inside, native coroutines use await instead of yield from to delegate to other coroutines.
> &emsp;&emsp; 随着原生协程(native coroutines)在python3.5的加入，python核心开发人员逐渐不再支持经典协程(classic coroutines)了，但原生协程和经典协程的底层原理其实是一样的。原生协程的语法使得协程更容易被区分出来(这里指的是容易和生成器函数区分开来)。在原生协程中，不再使用`yield from`来委派协程，取而代之的是`await`关键字。
> 
简而言之，在Python3.5后，已经很少使用`yield from`来委派协程了，取而代之的是`await`关键字。

&emsp;
### 4.9 使用`@asyncio.coroutine`来定义协程
#### 4.9.1 `@asyncio.coroutine`是什么？
&emsp;&emsp; `asyncio`是Python 3.4 试验性引入的异步`I/O`框架，`@asyncio.coroutine`是里面一个用来简化定义协程的一个装饰器。

#### 4.9.2 `@asyncio.coroutine`现状
现在已经不推荐使用`@asyncio.coroutine`来定义协程了，在python3.8以后，如果在代码中使用`@asyncio.coroutine`来定义协程，解释器会予以警告：
```python
import asyncio
import datetime
import random


@asyncio.coroutine
def display_date(num, loop):
    end_time = loop.time() + 50.0
    while True:
        print('Loop: {} Time: {}'.format(num, datetime.datetime.now()))
        if (loop.time() + 1.0) >= end_time:
            break
        yield from asyncio.sleep(random.randint(0, 5))


loop = asyncio.get_event_loop()
asyncio.ensure_future(display_date(1, loop))
asyncio.ensure_future(display_date(2, loop))
loop.run_forever()
```
运行结果：
```
d:\code_practice\practice.py:7: DeprecationWarning: "@coroutine" decorator is deprecated since Python 3.8, use "async def" instead
  def display_date(num, loop):
d:\code_practice\practice.py:16: DeprecationWarning: There is no current event loop
  loop = asyncio.get_event_loop()
d:\code_practice\practice.py:17: DeprecationWarning: There is no current event loop
  asyncio.ensure_future(display_date(1, loop))
d:\code_practice\practice.py:18: DeprecationWarning: There is no current event loop
  asyncio.ensure_future(display_date(2, loop))
Loop: 1 Time: 2022-08-15 16:51:52.090880
Loop: 2 Time: 2022-08-15 16:51:52.093877
Loop: 1 Time: 2022-08-15 16:51:52.097863
Loop: 1 Time: 2022-08-15 16:51:53.100349
Loop: 2 Time: 2022-08-15 16:51:54.108288
Loop: 1 Time: 2022-08-15 16:51:54.109292
Traceback (most recent call last): 
    # 此处是CTRL+c将程序中断，要不然就会一直运行
```
代码是在python3.10.0上运行的，可以看到的是，解释器给出了警告：
> DeprecationWarning: "@coroutine" decorator is deprecated since Python 3.8, use "async def" instead
> 自python3.8开始，"@asyncio.coroutine"装饰器就被抵制使用了，而应该使用 "async def"来定义(协程)。
> 

&emsp;
## 5 原生协程(native coroutines)
### 5.1 什么是原生协程？什么是 非原生协程？
&emsp;&emsp; 在python3.5之前，python的协程都是 基于生成器的协程(generator based coroutines)，换句话说就是 非原生协程。
&emsp;&emsp; 在python3.5中加入了`async`/`await`，使用这两个关键字定义的协程叫 原生协程(native coroutines)。

### 5.2 需要先了解的几个概念
① `coroutine` 
> &emsp;&emsp; 协程对象，指一个使用async关键字定义的函数，它的调用不会立即执行函数，而是会返回一个协程对象。协程对象需要注册到事件循环，由事件循环调用。
> 
② `event_loop` 
> &emsp;&emsp; 事件循环，程序开启一个无限的循环，程序员会把一些函数注册到事件循环上。当满足事件发生的时候，调用相应的协程函数。
> 
③ `task` 
> &emsp;&emsp; 任务，是对协程进一步封装，其中包含任务的各种状态。
> 
④ `future`
> &emsp;&emsp; 代表将来执行或没有执行的任务的结果。它和task上没有本质的区别
> 

### 5.3 原生协程的定义和使用
#### 5.3.1 定义原生协程
&emsp;&emsp; 在`def`前加上`async`的声明，就完成了一个协程函数的定义：
```python
async def fun(a): # 定义协程函数
    print(a)
```
#### 5.3.2 使用原生协程
&emsp;&emsp; 协程函数不能直接调用运行，需要将协程注册到事件循环，并启动事件循环才能使用。
```python
import asyncio


async def fun(a):    # 定义协程函数
    print("\nInside of async def fun()")
    print(a)


# 调用协程函数，生成一个协程对象，此时协程函数并未执行
coroutine = fun('hello world')

# 创建事件循环
loop = asyncio.get_event_loop()

# 将协程函数添加到事件循环，并启动
loop.run_until_complete(coroutine)
```
运行结果：
```
Inside of async def fun()
hello world
```

### 5.4 任务对象`task`
&emsp;&emsp; 协程对象不能直接运行，在注册事件循环的时候，其实是`run_until_complete()`方法将协程包装成为了一个任务（`task`）对象。我们也可以显式实现它，我们有两种方法可以创建`task`对象：
> ① `create_task()`
> ② `asyncio.ensure_future()`
> 
```python
import asyncio


async def fun(a):
    print("\nInside of async def fun()")
    print(a)
    return a


# 方法一： 使用create_task()创建task，并将coroutine对象转化成task对象
coroutine = fun('hello world')
loop = asyncio.get_event_loop()
task = loop.create_task(coroutine)
print(f'task: {task}\n')
loop.run_until_complete(task)
print(f'task: {task}\n')
print(f'result: {task.result()}\n')


# 方法二：使用asyncio.ensure_future() 创建task，并将coroutine对象转化成task对象
coroutine = fun('hello world')
task = asyncio.ensure_future(coroutine)
loop = asyncio.get_event_loop()
print(f'task: {task}\n')
loop.run_until_complete(task)
print(f'task: {task}\n')
```
运行结果：
```
task: <Task pending name='Task-1' coro=<fun() running at d:\code_practice\practice.py:4>>


Inside of async def fun()
hello world
task: <Task finished name='Task-1' coro=<fun() done, defined at d:\code_practice\practice.py:4> result='hello world'>

result: hello world

d:\code_practice\practice.py:22: DeprecationWarning: There is no current event loop
  task = asyncio.ensure_future(coroutine)
d:\code_practice\practice.py:23: DeprecationWarning: There is no current event loop
  loop = asyncio.get_event_loop()
task: <Task pending name='Task-2' coro=<fun() running at d:\code_practice\practice.py:4>>


Inside of async def fun()
hello world
task: <Task finished name='Task-2' coro=<fun() done, defined at d:\code_practice\practice.py:4> result='hello world'>
```

### 5.4 绑定回调函数
&emsp;&emsp; 如果需要在任务(`task`)执行完毕后对结果进行处理，可以通过给`task`对象绑定回调函数完成，回调的最后一个参数是`future`对象（如`task`对象）。
```python
import asyncio


async def fun(a):
    print("\nInside of async def fun()")
    print(a)
    return a


# 回调函数，打印task的返回值
def callback(task): 
    print("\nInside of callback()")
    print(f'result: {task.result()}\n')


coroutine = fun('hello world')
loop = asyncio.get_event_loop()
task = loop.create_task(coroutine)

#绑定回调函数
task.add_done_callback(callback)

print(f'task1: {task}\n')
loop.run_until_complete(task)
print(f'task2: {task}')
```
运行结果：
```
task1: <Task pending name='Task-1' coro=<fun() running at d:\code_practice\practice.py:4> cb=[callback() at d:\code_practice\practice.py:11]>


Inside of async def fun()
hello world

Inside of callback()
result: hello world

task2: <Task finished name='Task-1' coro=<fun() done, defined at d:\code_practice\practice.py:4> result='hello world'> 
```

### 5.5 多任务
&emsp;&emsp; 当需要执行多个任务时，可以定义一个任务列表，并将需要完成的协程任务都加进去，然后将原本的`loop.run_until_complete(tasks)`改为`loop.run_until_complete(asyncio.wait(tasks))`。
&emsp;&emsp; 如果执行的是多个耗时的任务，如网络请求、文件读取等。此时就`await`就派上用场了：
> &emsp;&emsp; `await`可以针对耗时的操作进行挂起，就像生成器里的`yield`一样，函数让出控制权。协程遇到`await`，事件循环将会挂起该协程，执行别的协程，直到其他的协程也挂起或者执行完毕，再进行下一个协程的执行。
> 
```python
import time
import asyncio


async def taskIO_1():   
    print('开始运行IO任务1...')
    await asyncio.sleep(2)  
    print('IO任务1已完成，耗时2s')
    return taskIO_1.__name__


async def taskIO_2():       
    print('开始运行IO任务2...')
    await asyncio.sleep(3)  
    print('IO任务2已完成，耗时3s')
    return taskIO_2.__name__


if __name__ == '__main__':
    start = time.time()
    loop = asyncio.get_event_loop() 
    
    # 建立任务列表
    tasks = [taskIO_1(), taskIO_2()]

    # 完成事件循环，直到最后一个任务结束
    loop.run_until_complete(asyncio.wait(tasks)) 

    
    print(f'所有IO任务总耗时{float(time.time()-start)}秒')
```
运行结果：
```
开始运行IO任务2...
开始运行IO任务1...
IO任务1已完成，耗时2s
IO任务2已完成，耗时3s
所有IO任务总耗时3.008939266204834秒
```
可以看出，原本需要`5`秒，现在执行只需要`3`秒多。

### 5.7 `yield from` 转 `async/await`
&emsp;&emsp; 由于async/await与yield from风格的协程底层实现方式相同。因此，从yield from风格改为async/await风格非常容易。只需：
> ① 把`@asyncio.coroutine`去掉，在协程函数的`def`前面加上`async`；
> ② 把`yield from`替换为`await`。
> 
`async/await`风格的代码隐藏了装饰器、`yield from`语法，方便了人们的理解，同时也让代码更加简洁。
&emsp;&emsp; 对于前面那个通过`@asyncio.coroutine`实现的协程`display_date()`，我们可以用`async`/`await`将其改为：
```python
import asyncio
import datetime
import random

# 差异1：没了装饰器
async def display_date(num, loop): # 差异二：def 前面多了 async
    end_time = loop.time() + 50.0
    while True:
        print('Loop: {} Time: {}'.format(num, datetime.datetime.now()))
        if (loop.time() + 1.0) >= end_time:
            break
        await asyncio.sleep(random.randint(0, 5)) # 差异三：await替代了 yield from 


loop = asyncio.get_event_loop()
asyncio.ensure_future(display_date(1, loop))
asyncio.ensure_future(display_date(2, loop))
loop.run_forever()
```
运行结果：
```
d:\code_practice\practice.py:15: DeprecationWarning: There is no current event loop
  loop = asyncio.get_event_loop()
d:\code_practice\practice.py:16: DeprecationWarning: There is no current event loop
  asyncio.ensure_future(display_date(1, loop))
d:\code_practice\practice.py:17: DeprecationWarning: There is no current event loop
  asyncio.ensure_future(display_date(2, loop))
Loop: 1 Time: 2022-08-15 16:57:13.514031
Loop: 2 Time: 2022-08-15 16:57:13.514031
Loop: 2 Time: 2022-08-15 16:57:15.517992
Loop: 1 Time: 2022-08-15 16:57:16.519159
Loop: 2 Time: 2022-08-15 16:57:16.520156
```
可以看到的是，除了不再提醒`DeprecationWarning`，其它的都一样。




&emsp;
## 6 原生协程 和  基于生成器的协程
&emsp;&emsp; 实际上，除了语法之外 原生协程(`async/await`)和基于生成器的协程(`@asyncio.coroutine/yield from`)并没有功能上的区别。但是注意，这两种写法不能混用，就是说你不能在`generator based coroutines`里使用`await`，或者在`naive coroutines`里头使用`yield`或者`yield from`。
&emsp;&emsp; 除此之外，两种写法是互通的，我们可以同时使用，比如我们可以在原生协程里`await`一个基于生成器的协程，也可以在基于生成器的协程里`yield from`一个使用`async`定义的原生协程。
比如我们同时在一个时间循环里使用两种协程:
```python
import asyncio
import datetime
import random
import types


@types.coroutine
def my_sleep_func():
    yield from asyncio.sleep(random.randint(0, 5))    # 注意这里就不能用 await


async def display_date(num, loop):
    end_time = loop.time() + 50.0
    while True:
        print('Loop: {} Time: {}'.format(num, datetime.datetime.now()))
        if (loop.time() + 1.0) >= end_time:
            break
        yield from my_sleep_func()    # 注意这里就不能用 yield from


loop = asyncio.get_event_loop()
asyncio.ensure_future(display_date(1, loop))
asyncio.ensure_future(display_date(2, loop))
loop.run_forever()
```


&emsp;
## 7 `asyncio`
&emsp;&emsp; `asyncio`是Python 3.4 试验性引入的异步`I/O`框架，提供了基于协程做异步I/O编写单线程并发代码的基础设施。其核心组件有
> 事件循环（Event Loop）
> 协程(Coroutine）
> 任务(Task)
> 未来对象(Future)
> 其他一些扩充和辅助性质的模块
> 





## 实现协程的几种方式
① greenlet。
② yield 关键字
③ asyncio 装饰器（py3.4之后引入）
④ async、await关键字（py3.5之后引入）【推荐】


## 基于生成器的协程(generator based coroutines)

## Async I/O and the asyncio module （异步IO和asyncio模块）


## 参考文献
1. [谈谈Python协程技术的演进](https://zhuanlan.zhihu.com/p/30275154)
2. [Python generators, coroutines, native coroutines and async/await](https://zhuanlan.zhihu.com/p/28334506)
3. [python协程是什么？](https://www.zhihu.com/question/35139020)
4. [出于什么样的原因，诞生了「协程」这一概念？](https://www.zhihu.com/question/50185085/answer/183463734)
5. [深入理解协程（三）：async/await实现异步协程](https://zhuanlan.zhihu.com/p/103315778)
6. [【asyncio专题】生成器(yield与yield from)](https://zhuanlan.zhihu.com/p/452223418)

