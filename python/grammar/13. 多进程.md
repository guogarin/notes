- [1. 背景](#1-背景)
  - [1.1 为什么要使用多进程？](#11-为什么要使用多进程)
  - [1.2 Python的多进程模块有哪些？它们各自有什么特点？](#12-python的多进程模块有哪些它们各自有什么特点)
- [2. `multiprocessing`模块](#2-multiprocessing模块)
  - [2.1 如何利用`multiprocessing` 编写多进程程序？](#21-如何利用multiprocessing-编写多进程程序)
    - [方法一：函数式](#方法一函数式)
    - [方法二：类继承式](#方法二类继承式)
  - [2.2 `multiprocessing.Process`](#22-multiprocessingprocess)
    - [2.2.1 `multiprocessing.Process`的类型是？](#221-multiprocessingprocess的类型是)
    - [2.2.2 `multiprocessing.Process`接收的参数是？](#222-multiprocessingprocess接收的参数是)
    - [2.2.3 `multiprocessing.Process` 有哪些方法？](#223-multiprocessingprocess-有哪些方法)
      - [(1) `run()`](#1-run)
      - [(2) `start()`](#2-start)
      - [(3) `join([timeout])`](#3-jointimeout)
      - [(4) `is_alive()`](#4-is_alive)
      - [(5) `terminate()`](#5-terminate)
      - [(6) `kill()`](#6-kill)
      - [(7) `close()`](#7-close)
    - [2.2.4 `multiprocessing.Process`中的`kill()`和`terminate()`](#224-multiprocessingprocess中的kill和terminate)
      - [(1) 它们方法有什么区别？](#1-它们方法有什么区别)
      - [(2) 平常用哪个比较好？](#2-平常用哪个比较好)
    - [2.2.5 `multiprocessing.Process` 有哪些属性？？](#225-multiprocessingprocess-有哪些属性)
      - [(1) `name`](#1-name)
      - [(2) `daemon`](#2-daemon)
      - [(3) `pid`](#3-pid)
      - [(4) `exitcode`](#4-exitcode)
      - [(5) `authkey`](#5-authkey)
      - [(6) `sentinel`](#6-sentinel)
    - [在`Process`中如何获取PID和PPID？](#在process中如何获取pid和ppid)
  - [2.3 `multiprocessing`模块中的 进程间通信](#23-multiprocessing模块中的-进程间通信)
    - [2.3.1 `multiprocessing`有哪些进程通信方法？](#231-multiprocessing有哪些进程通信方法)
    - [2.3.2](#232)
  - [3. `multiprocessing`模块中的 进程间同步](#3-multiprocessing模块中的-进程间同步)
  - [为什么`__name__ == '__main__'`是必须的？](#为什么__name__--__main__是必须的)
- [3.`subprocess`](#3subprocess)
  - [](#)
- [参考文献](#参考文献)

# 1. 背景
## 1.1 为什么要使用多进程？
&emsp;&emsp; 虽然线程更为轻量级，调度也更方便，但是python本身存在`GIL(Global Interpreter Lock)`，而且任何Python线程执行前，必须先获得`GIL`锁，然后，每执行一段时间后，解释器就自动释放GIL锁，让别的线程有机会执行。
&emsp;&emsp; 换句话说就是多线程的时候，同一时间只能有一个线程在CPU上运行，不管你的CPU有多少个核，同一时间都只能运行一个线程。
&emsp;&emsp; `GIL`的存在让python的多线程无法利用多核CPU的优势，所以想发挥多核CPU来实现并行，采用多进程是更好的方法。

## 1.2 Python的多进程模块有哪些？它们各自有什么特点？
Python多进程有内置模块 `multiprocessing` 和 `subprocess`：
`multiprocess`: 是同一个代码中通过多进程调用其他的模块（也是自己写的）
 `subprocess` : 直接调用外部的二进制程序，而非代码模块






&emsp;
&emsp; 
# 2. `multiprocessing`模块 
## 2.1 如何利用`multiprocessing` 编写多进程程序？
&emsp;&emsp; 我们可以通过函数、类两种方法来编写多进程程序，这两种方法都要用到`multiprocessing.Process`。
### 方法一：函数式
① 编写需要被子进程运行的函数`func()`；
② 创建`multiprocessing.Process`类的实例，然后通过这个实例来运行你需要运行的函数`func()`。

```python
from multiprocessing import Process
import os

def func(name, i):
    print(f"我是老{i}，我叫 {name}，我的PID是{os.getpid():>6}，PPID是 {os.getppid()}")


if __name__ == "__main__":
    process_list = []
    for i, name in enumerate("Python", 1):
        p = Process(target=func, args=(name, i))
        p.start()
        process_list.append(p)
    for i in process_list:
        i.join()       
```
运行结果：
```
我是老1，我叫 P，我的PID是  7616，PPID是 4152
我是老2，我叫 y，我的PID是 20280，PPID是 4152
我是老3，我叫 t，我的PID是 11840，PPID是 4152
我是老4，我叫 h，我的PID是 13708，PPID是 4152
我是老6，我叫 n，我的PID是 11356，PPID是 4152
我是老5，我叫 o，我的PID是 11068，PPID是 4152
```
**结果分析：**
&emsp;&emsp; 

### 方法二：类继承式
① 首先，新建一个类`Myprocess`，这个类要继承`multiprocessing.Process`类；
② 覆盖父类的`run()`方法，需要将其实现为需要多进程运行的函数（因为`start()`默认调用`run()`方法）。
③ 实例化类`Myprocess`，然后调用它的`start()`方法，解释器将自动调用`Myprocess.run()`
```python
from multiprocessing import Process
import os

class Myprocess(Process):
    def __init__(self, n, i):
        super().__init__()
        self.name = n
        self.seq = i

    def run(self):
        print(f"我是老{self.seq}，我叫 {self.name}，我的PID是{self.pid:>6}，PPID是 {os.getppid()}")


if __name__ == "__main__":
    process_list = []
    for i, name in enumerate("Python", 1):
        p = Myprocess(name, i)
        p.start()
        process_list.append(p)
    for i in process_list:
        i.join()    
```
运行结果：
```
我是老1，我叫 P，我的PID是  3324，PPID是 19504
我是老2，我叫 y，我的PID是 10780，PPID是 19504
我是老4，我叫 h，我的PID是  1932，PPID是 19504
我是老3，我叫 t，我的PID是 11564，PPID是 19504
我是老5，我叫 o，我的PID是 10180，PPID是 19504
我是老6，我叫 n，我的PID是  5108，PPID是 19504
```
**结果分析：**
&emsp;&emsp; 

&emsp;
## 2.2 `multiprocessing.Process`
### 2.2.1 `multiprocessing.Process`的类型是？
&emsp;&emsp; 它是一个类。

### 2.2.2 `multiprocessing.Process`接收的参数是？
`multiprocessing.Process`的构造函数接收的参数为：
```python
Process(group=None, target=None, name=None, args=(), kwargs={}, *, daemon=None)
```
**形参：**
> &emsp;&emsp; `group`: 它的值始终为None，此参数的存在只是为了和`threading.Thread`保持一致(`group` should always be None; it exists solely for compatibility with `threading.Thread`. )
> &emsp;&emsp; `target`: 表示调用对象，即子进程要执行的任务（ target is the callable object to be invoked by the `run()` method. It defaults to None, meaning nothing is called.）
> &emsp;&emsp; `name`: 子进程的名称(name is the process name)
> &emsp;&emsp; `args`: 调用对象的位置参数元组(args is the argument tuple for the target invocation. )
> &emsp;&emsp; `kwargs`: 调用对象的字典（kwargs is a dictionary of keyword arguments for the target invocation.）
> &emsp;&emsp; `daemon`：If provided, the keyword-only daemon argument sets the process daemon flag to True or False. If None (the default), this flag will be inherited from the creating process.（daemon参数是在python3.3加入的）
> 

### 2.2.3 `multiprocessing.Process` 有哪些方法？
#### (1) `run()`           
&emsp;&emsp; 进程启动时运行的方法，它会去调用`target`指定的函数。也可以在子类中重载此方法。`标准 run()` 方法调用传递给对象构造函数的可调用对象作为目标参数（如果有），分别从 args 和 kwargs 参数中获取顺序和关键字参数。

#### (2) `start()`         
&emsp;&emsp; 启动进程。这个方法每个进程对象最多只能调用一次。它会将对象的 run() 方法安排在一个单独的进程中调用。

#### (3) `join([timeout])`
&emsp;&emsp; 内部是通过`wait()`实现的。等待子进程退出，如果没有`join()`，则子进程会变成僵尸进程。
&emsp;&emsp; 如果可选参数 `timeout` 是 `None` （默认值），则该方法将阻塞，直到调用 join() 方法的进程终止。
&emsp;&emsp; 如果 timeout 是一个正数，它最多会阻塞 `timeout` 秒。请注意，如果进程终止或方法超时，则该方法返回 None 。通过检查进程的 `exitcode` 以确定它是否终止。
&emsp;&emsp; 一个进程可以被 join 多次。但进程无法`join`自身，因为这会导致死锁。尝试在启动进程之前`join`进程是错误的。

#### (4) `is_alive()`     
&emsp;&emsp; 判断当前进程是否活着。

#### (5) `terminate()`    
&emsp;&emsp; 通过给进程发送`SIGTERM`信号来终止进程。

#### (6) `kill()`         
&emsp;&emsp; 通过发送`SIGKILL`来终止进程。

#### (7) `close()`        
&emsp;&emsp; 这是python3.7加入的特性，用来关闭 `Process`对象，并释放与之关联的所有资源。如果底层进程仍在运行，则会引发 `ValueError` 。一旦 `close()` 成功返回，调用`Process`对象的大多数其他方法和属性将引发 `ValueError` 。

### 2.2.4 `multiprocessing.Process`中的`kill()`和`terminate()`
#### (1) 它们方法有什么区别？
它俩都是用来终止进程的。它们之间的差异在于给进程发送的信号：
> `terminate()`发送`SIGTERM`信号；
> `kill()` 发送`SIGKILL`；
> 
所以它俩的区别可以理解为`SIGTERM`和`SIGKILL`的区别：
> `SIGTERM`和`SIGKILL`都是用来终止进程的，但是它们之间的区别的主要是能不能被信号处理函数阻塞：
> &emsp;&emsp; `SIGTERM`是可以被信号处理器阻塞的，如果进程定义了自己的信号处理函数，那么完全可以不杀死自己；
> &emsp;&emsp; `SIGKILL`是必杀信号，信号处理器也不能将其阻塞。
> 
#### (2) 平常用哪个比较好？
&emsp;&emsp; 正常情况下建议使用`terminate()`，因为它会调用信号处理程序，而且在信号处理程序中可能有一些资源的清理工作，这样可以避免资源泄露的风险。
&emsp;&emsp; 如果实在杀不掉，再调用`kill()`

### 2.2.5 `multiprocessing.Process` 有哪些属性？？
#### (1) `name`
&emsp;&emsp; 进程的名称。该名称是一个字符串，仅用于识别目的。它没有语义。我们可以为多个进程指定相同的名称。
&emsp;&emsp; 初始名称由构造器设定。 如果没有为构造器提供显式名称，则会构造一个形式为 `'Process-N1:N2:...:Nk'` 的名称，其中每个 `Nk` 是其父亲的第 `N` 个孩子。
#### (2) `daemon`
&emsp;&emsp; 进程的守护标志，一个布尔值。这必须在 start() 被调用之前设置。
&emsp;&emsp; 它的初始值继承自创建进程。
&emsp;&emsp; 当进程退出时，它会尝试终止其所有守护进程子进程。
&emsp;&emsp; 请注意，不允许在守护进程中创建子进程。这是因为当守护进程由于父进程退出而中断时，其子进程会变成孤儿进程。 另外，这些 不是 Unix 守护进程或服务，它们是正常进程，如果非守护进程已经退出，它们将被终止（并且不被合并）。
#### (3) `pid`
&emsp;&emsp; 返回进程ID。在生成该进程之前，这将是 None 。如果要返回父进程的进程ID，只能通过`os.ppid()`
#### (4) `exitcode`
&emsp; 子进程的退出代码：
&emsp;&emsp; 如果进程尚未终止，这将是 `None` 。
&emsp;&emsp; 若为负值 `-N` 表示子进程被信号 `N` 终止。
#### (5) `authkey`
&emsp;&emsp; 这是进程的身份验证密钥（字节字符串）。当 `multiprocessing` 初始化时，主进程使用 `os.urandom()` 分配一个随机字符串。
&emsp;&emsp; 当创建 Process 对象时，它将继承其父进程的身份验证密钥，尽管`authkey` 肯被设置为另一个字节字符串来更改。
#### (6) `sentinel`
&emsp;&emsp; 系统对象的数字句柄，当进程结束时将变为 "ready" 。如果要使用 `multiprocessing.connection.wait()` 一次等待多个事件，可以使用此值。否则调用 `join()` 更简单。

### 在`Process`中如何获取PID和PPID？
&emsp;&emsp; `PID`可以直接通过类属性`Process.pid`；
&emsp;&emsp; `PPID`只能通过`os.ppid()`

&emsp;
## 2.3 `multiprocessing`模块中的 进程间通信
### 2.3.1 `multiprocessing`有哪些进程通信方法？
&emsp;&emsp; `multiprocessing`模块实现了 队列(Queue)和管道(Pipe)。

### 2.3.2 





&emsp;
&emsp; 
## 3. `multiprocessing`模块中的 进程间同步



## 为什么`__name__ == '__main__'`是必须的？
https://docs.python.org/3/library/multiprocessing.html


# 3.`subprocess`
## 





# 参考文献
1. [一篇文章搞定Python多进程(全)](https://zhuanlan.zhihu.com/p/64702600)
2. [Python程序入口 __name__ == '__main__' 有重要功能（多线程）而非编程习惯](https://zhuanlan.zhihu.com/p/340965963)