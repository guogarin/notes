# 1. 背景
## 1.1 为什么要使用多进程？
&emsp;&emsp; 虽然线程更为轻量级，调度也更方便，但是python本身存在`GIL(Global Interpreter Lock)`，而且任何Python线程执行前，必须先获得`GIL`锁，然后，每执行一段时间后，解释器就自动释放GIL锁，让别的线程有机会执行。
&emsp;&emsp; 换句话说就是多线程的时候，同一时间只能有一个线程在CPU上运行，不管你的CPU有多少个核，同一时间都只能运行一个线程。
&emsp;&emsp; `GIL`的存在让python的多线程无法利用多核CPU的优势，所以想发挥多核CPU来实现并行，采用多进程是更好的方法。

## 1.2 Python的多进程模块有哪些？它们各自有什么特点？
Python多进程有内置模块 `multiprocessing` 和 `subprocess`：
`multiprocess`: 是同一个代码中通过多进程调用其他的模块（也是自己写的）
 `subprocess` : 直接调用外部的二进制程序，而非代码模块



&emsp;
&emsp; 
# 2. `multiprocessing`模块 
## 2.1 如何利用`multiprocessing` 编写多进程程序？
&emsp;&emsp; 我们可以通过函数、类两种方法来编写多进程程序，这两种方法都要用到`multiprocessing.Process`。
### 方法一：函数式
① 编写需要被子进程运行的函数`func()`；
② 创建`multiprocessing.Process`类的实例，然后通过这个实例来运行你需要运行的函数`func()`。

```python
from multiprocessing import Process
import os

def func(name, i):
    print(f"我是老{i}，我叫 {name}，我的PID是{os.getpid():>6}，PPID是 {os.getppid()}")


if __name__ == "__main__":
    process_list = []
    for i, name in enumerate("Python", 1):
        p = Process(target=func, args=(name, i))
        p.start()
        process_list.append(p)
    for i in process_list:
        i.join()       
```
运行结果：
```
我是老1，我叫 P，我的PID是  7616，PPID是 4152
我是老2，我叫 y，我的PID是 20280，PPID是 4152
我是老3，我叫 t，我的PID是 11840，PPID是 4152
我是老4，我叫 h，我的PID是 13708，PPID是 4152
我是老6，我叫 n，我的PID是 11356，PPID是 4152
我是老5，我叫 o，我的PID是 11068，PPID是 4152
```
**结果分析：**
&emsp;&emsp; 

### 方法二：类继承式
① 首先，新建一个类`Myprocess`，这个类要继承`multiprocessing.Process`类；
② 覆盖父类的`run()`方法，需要将其实现为需要多进程运行的函数（因为`start()`默认调用`run()`方法）。
③ 实例化类`Myprocess`，然后调用它的`start()`方法，解释器将自动调用`Myprocess.run()`
```python
from multiprocessing import Process
import os

class Myprocess(Process):
    def __init__(self, n, i):
        super().__init__()
        self.name = n
        self.seq = i

    def run(self):
        print(f"我是老{self.seq}，我叫 {self.name}，我的PID是{self.pid:>6}，PPID是 {os.getppid()}")


if __name__ == "__main__":
    process_list = []
    for i, name in enumerate("Python", 1):
        p = Myprocess(name, i)
        p.start()
        process_list.append(p)
    for i in process_list:
        i.join()    
```
运行结果：
```
我是老1，我叫 P，我的PID是  3324，PPID是 19504
我是老2，我叫 y，我的PID是 10780，PPID是 19504
我是老4，我叫 h，我的PID是  1932，PPID是 19504
我是老3，我叫 t，我的PID是 11564，PPID是 19504
我是老5，我叫 o，我的PID是 10180，PPID是 19504
我是老6，我叫 n，我的PID是  5108，PPID是 19504
```
**结果分析：**
&emsp;&emsp; 

## 2.2 `multiprocessing.Process`
### 2.2.1 `multiprocessing.Process`的类型是？
&emsp;&emsp; 它是一个类。

### 2.2.2 `multiprocessing.Process`接收的参数是？
`multiprocessing.Process`的构造函数接收的参数为：
```python
Process(group=None, target=None, name=None, args=(), kwargs={}, *, daemon=None)
```
**形参：**
> &emsp;&emsp; `group`: 它的值始终为None，此参数的存在只是为了和`threading.Thread`保持一致(`group` should always be None; it exists solely for compatibility with `threading.Thread`. )
> &emsp;&emsp; `target`: 表示调用对象，即子进程要执行的任务（ target is the callable object to be invoked by the `run()` method. It defaults to None, meaning nothing is called.）
> &emsp;&emsp; `name`: 子进程的名称(name is the process name)
> &emsp;&emsp; `args`: 调用对象的位置参数元组(args is the argument tuple for the target invocation. )
> &emsp;&emsp; `kwargs`: 调用对象的字典（kwargs is a dictionary of keyword arguments for the target invocation.）
> &emsp;&emsp; `daemon`：If provided, the keyword-only daemon argument sets the process daemon flag to True or False. If None (the default), this flag will be inherited from the creating process.（daemon参数是在python3.3加入的）
> 

### 2.2.3 `multiprocessing.Process` 有哪些方法？

#### `run()`           
进程启动时运行的方法，它会去调用`target`指定的函数

#### `start()`         
启动进程，并调用该子进程中的`run()`方法 

#### `join([timeout])`

#### `is_alive()`     

#### `terminate()`    

#### `kill()`         

#### `close()`        

### 2.2.3 `multiprocessing.Process` 有哪些属性？？

## 2.3 有哪几种编写方式？


### 如何获取PID和PPID？



## 为什么`__name__ == '__main__'`是必须的？
https://docs.python.org/3/library/multiprocessing.html


# 3.`subprocess`
## 





# 参考文献
1. [一篇文章搞定Python多进程(全)](https://zhuanlan.zhihu.com/p/64702600)
2. [Python程序入口 __name__ == '__main__' 有重要功能（多线程）而非编程习惯](https://zhuanlan.zhihu.com/p/340965963)