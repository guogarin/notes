
- [1.](#1)
- [2.](#2)
- [3. `Mixin`类](#3-mixin类)
  - [3.1 什么是`Mixin`?](#31-什么是mixin)
  - [3.2 它可以用来解决什么问题？](#32-它可以用来解决什么问题)
  - [3.3 什么时候应该使用`Mixin`？](#33-什么时候应该使用mixin)
  - [3.4 如何使用？](#34-如何使用)
  - [3.5 可以为`Mixin`类创建对象吗？](#35-可以为mixin类创建对象吗)
  - [3.6 `Mixin`这项技术强调的是什么？](#36-mixin这项技术强调的是什么)
  - [3.7 `mixin`类一般有什么特征？](#37-mixin类一般有什么特征)
  - [3.8 总结](#38-总结)
- [4. `property`属性](#4-property属性)
  - [4.1 基本介绍](#41-基本介绍)
    - [4.1.1 `property`是什么？](#411-property是什么)
    - [4.1.2 `property`属性 的原理](#412-property属性-的原理)
      - [(1) `property`的实现](#1-property的实现)
      - [(2) `property`的运行原理](#2-property的运行原理)
  - [4.2 使用`property`属性](#42-使用property属性)
    - [10.2.1 `property`属性 有哪些使用方法？](#1021-property属性-有哪些使用方法)
    - [4.2.2 通过装饰器](#422-通过装饰器)
      - [(1) 通过装饰器定义`property`属性时需要注意哪些点？](#1-通过装饰器定义property属性时需要注意哪些点)
      - [(2) 实例](#2-实例)
      - [(3) 为什么在上面的代码中，`__init__()`明明是不带下划线的`first_name`，而在`property`的函数中访问的却是带下划线的`_first_name`?](#3-为什么在上面的代码中__init__明明是不带下划线的first_name而在property的函数中访问的却是带下划线的_first_name)
    - [4.2.3 通过`property()`函数](#423-通过property函数)
      - [(1) 如何使用`property()`函数？](#1-如何使用property函数)
    - [4.2.4 这两种定义`property()`属性的方法 我们应该使用哪个？](#424-这两种定义property属性的方法-我们应该使用哪个)
  - [4.3 `property`属性的应用](#43-property属性的应用)
    - [4.3.1 使用 `property()`属性的 原则是？](#431-使用-property属性的-原则是)
    - [4.3.2 `property`属性有哪些应用场景](#432-property属性有哪些应用场景)
- [5. 描述符(descriptor)](#5-描述符descriptor)
  - [5.1 什么是描述符？描述符协议 又是什么？](#51-什么是描述符描述符协议-又是什么)
  - [5.2 描述符的作用是？](#52-描述符的作用是)
  - [5.3 描述符的类型](#53-描述符的类型)
    - [5.3.1 描述符有哪几种类型？](#531-描述符有哪几种类型)
    - [5.3.2 这几种描述符类型有何差异？](#532-这几种描述符类型有何差异)
  - [5.4 描述符的具体使用](#54-描述符的具体使用)
    - [5.4.1 使用实例](#541-使用实例)
    - [11.4.2 注意事项](#1142-注意事项)
  - [5.5 描述其的运行原理](#55-描述其的运行原理)
    - [5.5.1 实例讲解](#551-实例讲解)
  - [5.6 描述符的应用](#56-描述符的应用)
    - [5.6.1 Python 内部的描述符](#561-python-内部的描述符)
    - [5.6.2 自定义描述符](#562-自定义描述符)
      - [(1) 概述](#1-概述)
      - [(2) 实现可复用的`@property`属性](#2-实现可复用的property属性)
  - [5.7 总结](#57-总结)
  - [5.8 参考文献](#58-参考文献)
- [6. 让对象支持 上下文管理协议(with语句)](#6-让对象支持-上下文管理协议with语句)
  - [6.1 如何让对象支持 下文管理协议(with语句)？](#61-如何让对象支持-下文管理协议with语句)
  - [6.2 稍微复杂一点的实例](#62-稍微复杂一点的实例)
  - [6.3 关于 使用`contextlib`实现 上下文管理器时，系统的执行步骤](#63-关于-使用contextlib实现-上下文管理器时系统的执行步骤)




&emsp;
&emsp; 
# 1. 





&emsp;
&emsp; 
# 2. 




&emsp;
&emsp; 
# 3. `Mixin`类
## 3.1 什么是`Mixin`?
&emsp;&emsp; `Mixin`即`Mix-in`，是一种**编程模式**，在 Python 等面向对象语言中，`Mixin`通常一个简单的类，它实现了某种功能单元，用于被其他子类继承，将功能组合到子类中。**我们可以将其看做是一项 代码复用 的技术**，使用它可以减少代码量。

## 3.2 它可以用来解决什么问题？
&emsp;&emsp; 多重继承是一个很有用的技术，但是很难用好，而且很难被其他开发者看懂，而`Mixin`可以一定程度上弥补这些缺陷。
&emsp;&emsp; 换句话说，`mixin`强调的是扩展及代码复用。

## 3.3 什么时候应该使用`Mixin`？
&emsp;&emsp; 当多个类都实现了同一种功能时，这时应该考虑将该功能抽离成 `Mixin`类，然后需要这个功能的类都可以继承它。

## 3.4 如何使用？
举个例子吧，定义一个简单的类：
```python
class Person:
    def __init__(self, name, gender, age):
        self.name = name
        self.gender = gender
        self.age = age

class Dog:
    def __init__(self, name, gender, age, breed):
        self.name = name
        self.gender = gender
        self.age = age   
        self.breed = breed
```
我们可以通过 调用实例属性的方式 来访问：
```python
p = Person("小陈", "男", 18)
print(p.name)  # "小陈"    

d = Dog("Lucky", '公', 3, 'Labrador')
print(d.name) # Lucky
```
但问题来了，我们希望`Person`和`Dog`都能拥有像 `dict` 一样调用属性的功能，于是我们需要给这两个类都加上`__getitem__()`和`__setitem__()`:
```python
class Person:
    def __init__(self, name, gender, age):
        self.name = name
        self.gender = gender
        self.age = age

    def __getitem__(self, key):
        return self.__dict__.get(key)

    def __setitem__(self, key, value):
        return self.__dict__.set(key, value)

class Dog:
    def __init__(self, name, gender, age, breed):
        self.name = name
        self.gender = gender
        self.age = age   
        self.breed = breed

    def __getitem__(self, key):
        return self.__dict__.get(key)

    def __setitem__(self, key, value):
        return self.__dict__.set(key, value)        

p = Person("小陈", "男", 18)
print(p['name'])  # "小陈"
print(p['age'])  # 18        


d = Dog("Lucky", '公', 3, 'Labrador')
print(d['name']) # Lucky
print(d['age'])    
```
运行结果：
```
小陈
18
Lucky
3
```
**结果分析：**
&emsp;&emsp; 我们成功的给`Person`和`Dog`添加了用关键字访问的功能，**但是这一点也不python，如果后续还需要添加其它功能，或者添加其它类，我们是不是还得分别给它们添加相关的方法呢？** `Mixin`完全可以解决这个问题：首先定义一个 `Mixin` 类：
```python
class MappingMixin:
    def __getitem__(self, key):
        return self.__dict__.get(key)

    def __setitem__(self, key, value):
        return self.__dict__.set(key, value)
```
`MappingMixin`类可以让子类拥有像 `dict` 一样调用属性的功能。我们将这个 `Mixin`类 加入到 `Person`类中：
```python
class Person(MappingMixin):
    def __init__(self, name, gender, age):
        self.name = name
        self.gender = gender
        self.age = age

class Dog(MappingMixin):
    def __init__(self, name, gender, age, breed):
        self.name = name
        self.gender = gender
        self.age = age   
        self.breed = breed        
```
现在 `Person`拥有另一种调用属性方式了：
```python
p = Person("小陈", "男", 18)
print(p['name'])  # "小陈"
print(p['age'])  # 18        


d = Dog("Lucky", '公', 3, 'Labrador')
print(d['name']) # Lucky
print(d['age'])  
```
再定义一个 `Mixin`类，这个类实现了 `__repr__` 方法，能自动将属性与值拼接成字符串：
```python
class ReprMixin:
    def __repr__(self):
        s = self.__class__.__name__ + '('
        for k, v in self.__dict__.items():
            if not k.startswith('_'):
                s += '{}={}, '.format(k, v)
        s = s.rstrip(', ') + ')'  # 将最后一个逗号和空格换成括号
        return s
```
利用多重继承，将`ReprMixin`也加到`Person`类中：
```python
class Person(MappingMixin, ReprMixin):
    def __init__(self, name, gender, age):
        self.name = name
        self.gender = gender
        self.age = age

class Dog(MappingMixin, ReprMixin):
    def __init__(self, name, gender, age, breed):
        self.name = name
        self.gender = gender
        self.age = age   
        self.breed = breed   

p = Person("小陈", "男", 18)
print(p['name'])  # "小陈"
print(p)  # Person(name=小陈, gender=男, age=18)

p = Person("小陈", "男", 18)
print(p['name'])  # "小陈"
print(p['age'])  # 18        


d = Dog("Lucky", '公', 3, 'Labrador')
print(d['name']) # Lucky
print(d['age'])  
print(d)
```
运行结果：
```
小陈
Person(name=小陈, gender=男, age=18)
小陈
18
Lucky
3
Dog(name=Lucky, gender=公, age=3, breed=Labrador)
```
**总结：**
&emsp;&emsp; 通过定义`Mixin`类`MappingMixin`和`ReprMixin`，我们简化了代码。

## 3.5 可以为`Mixin`类创建对象吗？
&emsp;&emsp; 可以的，这有点像带单下划线`_`的类对象是属于`proctected`对象一样，是一个约定成俗的东西，解释器并没有强制，但是最好按规矩办事。

## 3.6 `Mixin`这项技术强调的是什么？
&emsp;&emsp; `mixin`强调的是 代码复用。

## 3.7 `mixin`类一般有什么特征？
① 类名以`Mixin`结尾，如`MappingMixin`；
 

## 3.8 总结
&emsp;&emsp; 其实可以把 `mixin`类 看成是一个插件，如果你创建的类要用到这个插件(`Mixin`)类提供的功能的话，那你就把这个`Mixin`类放到你的派生列表中。一般来说一个类会需要很多个功能，所以会需要好几个插件(即`Mixin`类)，所以它通常会和多重继承一起出现。







&emsp;
&emsp; 
# 4. `property`属性
## 4.1 基本介绍
### 4.1.1 `property`是什么？
&emsp;&emsp; `property`是一种内置的语法，使用`property`属性，可以把 类的方法 伪装成 类的属性(成员变量)，调用的方式也从原来的`Foo.func()`变为了`Foo.func`。

### 4.1.2 `property`属性 的原理
#### (1) `property`的实现
`property`其实是一个类，它有有三个成员方法和三个装饰器函数：
成员函数：
> `fget`：
> `fset`：
> `fdel`：
> 
装饰器函数：
> `getter` ：
> `setter` ：
> `deleter`：
> 
一个 `property`属性 其实就是一系列相关绑定方法的集合。如果查看拥有`property` 的类，就会发现 `property` 本身的 `fget`、 `fset` 和 `fdel`属性 就是类里面的普通方法。比如：
```python
print(Person.first_name.fget)
print(Person.first_name.fset)
print(Person.first_name.fdel)
```
运行结果：
```
<function Person.first_name at 0x0000022F50A3E950>
<function Person.first_name at 0x0000022F50A3E9E0>
<function Person.first_name at 0x0000022F50A3EA70>
```
通常来讲，我们不会直接取调用 `fget` 或者 `fset`，它们会在访问 property 的时候自动被触发。
#### (2) `property`的运行原理
&emsp;&emsp; 前面已经介绍，`property`会使 方法 **伪装成** 属性，这就导致该方法可以和属性一样使用：不再需要`()`。后面对这个`property`的读取会映射到`getter`上；修改会映射到`setter`上；`del`会映射到`deleter`上面。具体实例可以看下面对 通过装饰器定义的`Person`类 的代码运行分析。


&emsp; 
## 4.2 使用`property`属性
### 10.2.1 `property`属性 有哪些使用方法？
`property`属性有两种使用方法：
> **① 通过装饰器；**
> **② 通过`property()`函数**
> 

### 4.2.2 通过装饰器
#### (1) 通过装饰器定义`property`属性时需要注意哪些点？
&emsp;&emsp; ① `get`方法不需要显示定义，因为使用装饰器`@property`的那个方法其实就是该属性的`get`方法；
&emsp;&emsp; ② 一个属性中3个相关联的方法的名字都必须一样，而且必须和被修饰的方法名一致，比如`Person`类中的`first_name`；
&emsp;&emsp; ③ 只有在 `get`属性 被创建后，后面的两个装饰器 `set`属性 和 `del`属性 才能被定义；
&emsp;&emsp; ④ `@property`方法必须执行的很快。复杂或缓慢的操作(如IO或其它会引发副作用的那些任务)，还是用普通的方法来实现比较好。

#### (2) 实例
```python
class Person:
    def __init__(self, first_name):
        self.first_name = first_name # 注意，self.first_name调用的是 @first_name.setter

    # Getter function
    @property
    def first_name(self):
        return self._first_name

    # Setter function
    @first_name.setter
    def first_name(self, value):
        if not isinstance(value, str):
            raise TypeError('Expected a string')
        self._first_name = value

    # Deleter function (optional)
    @first_name.deleter
    def first_name(self):
        raise AttributeError("Can't delete attribute")

a = Person('Guido')
print(a.first_name)
a.first_name = 'jack'
print(a.first_name)
```
运行结果：
```
Guido
jack
```
> ① ·`print(a.first_name`访问的其实是被`@property`修饰的函数；
> ② `a.first_name = 'jack'`中的`a.first_name `访问的是被`@first_name.setter`修饰的函数；
> 


#### (3) 为什么在上面的代码中，`__init__()`明明是不带下划线的`first_name`，而在`property`的函数中访问的却是带下划线的`_first_name`?
&emsp;&emsp; 因为在`Person.__init__()`中，`self.first_name = first_name`的`self.first_name`调用的是`@first_name.setter`属性，我们来给上面的代码加点`log`：
```python
class Person:
    def __init__(self, first_name):
        print("Entered __init__.")
        self.first_name = first_name
        print("Left __init__.")

    # Getter function
    @property
    def first_name(self):
        return self._first_name

    # Setter function
    @first_name.setter
    def first_name(self, value):
        if not isinstance(value, str):
            raise TypeError('Expected a string')
        print("in @first_name.setter") # log 加在这里了
        self._first_name = value

    # Deleter function (optional)
    @first_name.deleter
    def first_name(self):
        raise AttributeError("Can't delete attribute")

a = Person('Guido')
print('\n', '*'*20, '\n')
print(a.first_name)
```
运行结果：
```
Entered __init__.
in @first_name.setter
Left __init__.

 ********************

Guido
```
**结果分析：**
&emsp;&emsp; 根据日志可以知道，`Person.__init__()`调用了`@first_name.setter`属性。

### 4.2.3 通过`property()`函数
#### (1) 如何使用`property()`函数？
&emsp;&emsp; 通过`property()`函数，我们可以还能在已存在的 get 和 set 方法基础上定义 property。
```python
class Person:
    def __init__(self, first_name):
        self.set_first_name(first_name)

    # Getter function
    def get_first_name(self):
        return self._first_name

    # Setter function
    def set_first_name(self, value):
        if not isinstance(value, str):
            raise TypeError('Expected a string')
        self._first_name = value
        
    # Deleter function (optional)
    def del_first_name(self):
        raise AttributeError("Can't delete attribute")

    # Make a property from existing get/set methods
    name = property(get_first_name, set_first_name, del_first_name)


a = Person('Guido')
print(a.name)
a.name = 'jack'
print(a.name)
```
运行结果：
```
Guido
jack
```

### 4.2.4 这两种定义`property()`属性的方法 我们应该使用哪个？
&emsp;&emsp; 一般情况下，建议使用装饰器来定义`property()`属性，一般在重构代码的时候才会使用`property()`函数来定义`property()`属性。

&emsp; 
## 4.3 `property`属性的应用
### 4.3.1 使用 `property()`属性的 原则是？
原则就是，不要写没有做任何其他额外操作的 `property`，例如：
```python
class Person:
    def __init__(self, first_name):
        self.first_name = first_name

    @property
    def first_name(self):
        return self._first_name

    @first_name.setter
    def first_name(self, value):
        self._first_name = value
```
上面的代码完全可以用成员函数来替代，而且这样做有如下缺点：
> 首先，它会让你的代码变得很臃肿，并且还会迷惑阅读者。
> 其次，它还会让你的程序运行起来变慢很多。
> 最后，这样的设计并没有带来任何的好处。特别是当你以后想给普通 attribute 访问添加额外的处理逻辑的时候，你可以将它变成一个 property 而无需改变原来的代码。因为访问 attribute的代码还是保持原样
> 

### 4.3.2 `property`属性有哪些应用场景
`property`属性一般有如下应用场景：
> ① 数据检查；
> ② 定义 需要动态计算的属性
> ③ 阻止属性被修改
**① 数据检查**
上面的`Person`类就是这样的例子：
```python
class Person:

    # 其它成员，略...

    # Setter function
    @first_name.setter
    def first_name(self, value):
        if not isinstance(value, str):
            raise TypeError('Expected a string')
        self._first_name = value
```
上面的`setter`属性检查了传过来的值是不是`str`，不是就`raise`。

**② 定义动态计算的属性**
&emsp;&emsp; `Properties` 还是一种定义动态计算 `attribute` 的方法。这种类型的 `attributes` 并不会被实际的存储，而是在需要的时候计算出来。
&emsp;&emsp; 比如，一个记录个人信息的类中，一般会要求输入生日，但是一般不会要用户输入自己的年龄，因为年龄是会随着时间而动态变化的，这个时候`property`属性就派上了用场：
```python
from datetime import datetime

class Person:
    def __init__(self, name, birthday, gender):
        self.name = name
        self.birthday = datetime.strptime(birthday, "%Y-%m-%d")
        self.gender = gender

    @property    
    def age(self):
        return datetime.now().year - self.birthday.year  


p1 = Person("张无忌", "2000-05-06", "男")
p2 = Person("周芷若", "2002-05-06", "女")

print(p1.age)
print(p2.age)
```
运行结果：
```
21
19
```
**③ 阻止属性被修改**
下面的`@ohms.setter`可以阻止 父类的 属性 被修改：
```python
class Resistor:
    def __init__(self, ohms):
        print("Enterd Resistor.__init__()")
        self.ohms = ohms
        self.voltage = 0
        self.current = 0
        print("Left Resistor.__init__()\n")

class FixedResistance(Resistor):
    def __init__(self, ohms):
        super().__init__(ohms)

    @property
    def ohms(self):
        return self._ohms

    @ohms.setter
    def ohms(self, ohms):
        print("    Entered @ohms.setter")
        if hasattr(self, '_ohms'):
            raise AttributeError("Ohms is immutable")
        self._ohms = ohms
        print("    Left @ohms.setter")


r4 = FixedResistance(1e3)
r4.ohms = 2e3
```
运行结果：
```
Enterd Resistor.__init__()
    Entered @ohms.setter
    Left @ohms.setter
Left Resistor.__init__()

    Entered @ohms.setter
Traceback (most recent call last):
  File "f:\code\python\test\test.py", line 27, in <module>
    r4.ohms = 2e3
  File "f:\code\python\test\test.py", line 21, in ohms
    raise AttributeError("Ohms is immutable")
AttributeError: Ohms is immutable
```
**结果分析：**
&emsp;&emsp; `super().__init__(ohms)`会运行基类的初始化函数，基类的初始化函数中的`self.ohms = ohms`的`self.ohms`会调用子类的`@ohms.setter`，所以`_ohms`在此时被创建了；
&emsp;&emsp; `r4.ohms = 2e3`调用的也是`@ohms.setter`，而此时`_ohms`已经在初始化的时候被创建了，所以报错






&emsp;
&emsp; 
# 5. 描述符(descriptor)
## 5.1 什么是描述符？描述符协议 又是什么？
&emsp;&emsp; 描述符的定义很简单，实现了下列 **任意一个或多个** 方法的 `Python`对象 就是一个描述符：
```python
__get__(self, instance, type=None)
__set__(self, instance, value)
__delete__(self, instance)
```
这些方法的参数含义如下：
> **`self`** 是当前定义的描述符对象实例。
> **`instance`** 是该描述符将作用的对象实例。
> **`type`** 是该描述符作用的对象的类型（即所属的类）。
> 
上述方法也被称为**描述符协议(descriptor protocol)**，Python 会在特定的时机按协议传入参数调用某一方法，如果我们未按协议约定的参数定义方法，调用可能会出错。
&emsp;&emsp; **本质上看，描述符就是一个类**，只不过它定义了**另一个类**中属性的访问方式。换句话说，一个类可以将属性管理全权委托给描述符类。


&emsp;
## 5.2 描述符的作用是？
&emsp;&emsp; 描述符就是一个“绑定行为“的对象属性，在描述符协议中，它可以通过方法重写属性的访问。我们或许经常看见描述符的作用描述中，有两个关键词“绑定行为”和“托管属性”，那到底是什么意思呢，这有一个通俗的解释：
> &emsp;&emsp; **绑定行为**：所谓的绑定行为，是指在属性的访问、赋值、删除时还绑定发生了其他的事情，正如前面属性控制三剑客所完成的事情一样；
> &emsp;&emsp; **托管属性**：python描述符是一种创建“托管属性”的方法，即通过描述符（类）去托管另一个类的相关属性，也可以说是类的属性的一个代理。为了方便的理解“托管属性”这个概念，将通过几个通俗的例子去说明。
> 
以人类而言，Person是一个类，人应该有很多属性，比如人是美丽的、性感的、成熟的、博学的、大方的等等，所谓的“描述”，本身指的就是描述某一个类的某一些特性的，在程序设计中，属性就是用来描述类的特征的，所谓的描述符（描述类）就是专门再创建一个类，让这个类去描述本身那个类的相关属性，这也正是“描述”二字的由来，其实和我们生活中的描述是一个意思。
&emsp;&emsp; 总而言之，描述符的作用是用来代理另外一个类的属性的。


&emsp;
## 5.3 描述符的类型
### 5.3.1 描述符有哪几种类型？
根据**所实现的协议方法不同**，描述符可分为两类：
* ① 若实现了 `__set__()` 或 `__delete__()` 任一方法，该描述符是一个**数据描述符（data descriptor）**。
* ② 若仅实现 `__get__()` 方法，该描述符是一个**非数据描述符（non-data descriptor）**。
  
### 5.3.2 这几种描述符类型有何差异？
两者的在表现行为上存在差异：
> 数据描述符 总是会覆盖实例字典 `__dict__` 中的属性。
> 而非数据描述符 会被实例字典 `__dict__` 中定义的属性所覆盖。
> 
下面写段代码来验证一下:
```python
class NonDataDescriptor:
    def __get__(self, instance, owner):
        if instance is None:
            print('NonDataDescriptor.__get__(): Accessing y from the class', owner)
            return self

        print('NonDataDescriptor.__get__(): Accessing y from the object', instance)
        return 'Y from non-data descriptor'

class Descriptor:
    def __get__(self, instance, owner):
        if instance is None:
            print('Descriptor.__get__(): Accessing x from the class', owner)
            return self
        
        print('Descriptor.__get__(): Accessing x from the object', instance)
        return 'X from descriptor'

    def __set__(self, instance, value):
        print('Descriptor.__set__(): Setting x on the object', instance)
        instance.__dict__['_x'] = value

class Bar:
    x = Descriptor()
    y = NonDataDescriptor()


bar = Bar()
print(bar.x, end = "\n\n")
print(bar.y, end = "\n\n")

# 下面通过__dict__修改
print("通过__dict__修改之后：")
bar.__dict__['x'] = "x"
bar.__dict__['y'] = "y"
print(bar.x, end = "\n\n")
print(bar.y, end = "\n\n")
```
运行结果：
```
X from descriptor

NonDataDescriptor.__get__(): Accessing y from the object <__main__.Bar object at 0x000001EE5C523E80>
Y from non-data descriptor

通过__dict__修改之后：
Descriptor.__get__(): Accessing x from the object <__main__.Bar object at 0x000001EE5C523E80>
X from descriptor

y

```
**结果分析：**
&emsp;&emsp; 可以看到，通过`__dict__`覆盖后，类型为数据描述符的`x`还是调用的`Descriptor.__get__()`；而类型为非数据描述符的`y`被覆盖了。


&emsp;
## 5.4 描述符的具体使用
### 5.4.1 使用实例
&emsp;&emsp; 前面提到，要实现所谓的描述符，就是要实现上面描述符协议中的三个魔术方法，但是和普通类定义的方式不一样，因为“属性代理（属性托管）”的机制，我们需要定义两个类：
> 一个 描述符类`A`，它实现描述符协议中方法；
> 一个 被描述符代理的类`B`，即所谓的描述类，它会使用前面定义的 描述符类`A`。
> 
来看一个例子，其中`Descriptor`是描述符类，`Foo`使用了描述符类：
```python
class Descriptor:
    def __get__(self, instance, owner):
        if instance is None:
            print('__get__(): Accessing x from the class', owner)
            return self
        
        print('__get__(): Accessing x from the object', instance)
        return 'X from descriptor'

    def __set__(self, instance, value):
        print('__set__(): Setting x on the object', instance)
        instance.__dict__['_x'] = value

class Foo:
    x = Descriptor()


print("通过类访问：")
print(Foo.x)    

print("\n通过实例访问：")
foo = Foo()
print(foo.x)
foo.x = 5
```
运行结果：
```
通过类访问：
__get__(): Accessing x from the class <class '__main__.Foo'>
<__main__.Descriptor object at 0x00000248C0AEE980>

通过实例访问：
__get__(): Accessing x from the object <__main__.Foo object at 0x00000248C0B92FE0>
X from descriptor
__set__(): Setting x on the object <__main__.Foo object at 0x00000248C0B92FE0>
```
**结果分析：**
&emsp;&emsp; 可以看到的是，无论是通过类本身，还是通过类实例，访问`Foo.x`都会自动调用该属性所绑定的描述符实例的 `__get__()`方法。
&emsp;&emsp; 对 实例对象`foo`的`x`进行赋值，会调用描述符的`__set__()` 方法。

### 11.4.2 注意事项
&emsp;&emsp; 我们注意到，上面的`Foo`类在使用描述符类的时候，是将`x`定义成了类属性，如果将`x`定义成实例属性会发生什么呢？我们写段代码来验证一下：
```python
class Descriptor:
    # 同上，略...

class Foo:
    def __init__(self):
        self.x = Descriptor()


foo = Foo()
print(foo.x)
foo.x = 5
```
运行结果：
```
<__main__.Descriptor object at 0x0000023607BA2F50>
```
**结果分析：**
&emsp;&emsp; 可以看到的是，描述符没有生效，只是打印了`self.x`自己的地址。

&emsp;&emsp; <span style="color:red; font-size:21px; font-weight:bold"> 需要注意的是，描述符在属性查找过程中会被`.`点操作符调用，且只有在作为类变量使用时才有效。如果直接赋值给实例属性，描述符不会生效。 </span>
另外，使用`__dict__`属性访问描述符也不会调用 描述符的协议方法，而是返回描述符实例本身：
```python
class Descriptor:
    # 同上，略...

class Foo:
    x = Descriptor()

print(Foo.__dict__['x'])
```
运行结果：
```
<__main__.Descriptor object at 0x0000023607BA2F50>
```


&emsp;
## 5.5 描述其的运行原理
### 5.5.1 实例讲解
现有描述符`Grade`和 使用描述符的`Exam`类：
```python
class Grade:
    def __get__(self, instance, instance_type):
        ...
        
    def __set__(self, instance, value):
        ...

class Exam:
    # Class attributes
    math_grade = Grade()
    writing_grade = Grade()
    science_grade = Grade()        
```
我们需要给`Exam`实例的`writing_grade`属性赋值
```python
exam = Exam()
exam.writing_grade = 40
```
那么解释器会把这次赋值操作转译为：
```python
Exam.__dict__['writing_grade'].__set__(exam,
```
获取这个属性也一样：
```python
exam.writing_grade
```
将被翻译成：
```python
Exam.__dict__['writing_grade'].__get__(exam, Exam)
```
上面的转译效果是由`object`类的` __getattribute__()`方法完成的，简单的说，就是当 `Exam`实例 中没有名为`writing_grade`的属性时，Python会转而在类的层面查找，如果类的层面有，而且还是个实现了`__get__()` 和  `__set__()` 的对象，那么系统就会认为你想通过描述符协议定义的这个属性的访问行为。


&emsp;
## 5.6 描述符的应用
### 5.6.1 Python 内部的描述符
&emsp;&emsp; 除了一些自定义的场景，Python 本身的语言机制中就大量使用了描述符：
> ① `@property`属性
> ② 类方法`@classmethod`
> ③ 静态方法`@staticmethod`
> 

### 5.6.2 自定义描述符
#### (1) 概述
描述符的本质在于“描述”二字，最大的用处是对属性的个性定制与控制，如前所说，
&emsp;&emsp; (1）可以在设置属性时，做些检测等方面的处理   
&emsp;&emsp; (2）设置属性不能被删除？那定义_delete_方法，并raise 异常。 
&emsp;&emsp; (3）还可以设置只读属性 
&emsp;&emsp; (4）把一个描述符作为某个对象的属性。这个属性要更改，比如增加判断，或变得更复杂的时候，所有的处理只要在描述符中操作就行了。 
这一系列其实都是为了更好地去控制一个属性。
#### (2) 实现可复用的`@property`属性
&emsp;&emsp; 详见 [Effective Python Item 46](../Effective%20Python.md)的相关笔记。


&emsp;
## 5.7 总结
&emsp;&emsp; 其他类在使用描述符的时候，必须将描述符实例定义成类属性，不能定义成实例属性：
```python
class Descriptor:
    # 同上，略...

class Foo:
    x = Descriptor() # 正确
    def __init__(self):
        self.y = Descriptor() # 错误
```

&emsp;
## 5.8 参考文献
1. [面向对象（深入）|python描述器详解](https://zhuanlan.zhihu.com/p/32764345)






&emsp;
&emsp; 
# 6. 让对象支持 上下文管理协议(with语句)
## 6.1 如何让对象支持 下文管理协议(with语句)？
有两种方法：
**(1) 标准做法：实现 `__enter__()` 和 `__exit__()` 方法**
为了让一个对象兼容 `with` 语句，需要实现`__enter__()` 和 `__exit__()` 方法：
> ` __enter__()`：它将在`with`出现的时候被触发，返回对象会赋给`as`声明的变量；
> `__exit__()` ： 他将在 离开`with`语句块时被触发，一般用它来进行清理工作。
> 
```python
class Query(object):

    def __init__(self, name):
        self.name = name

    def __enter__(self):
        print('__enter__()')
        return self
    
    def __exit__(self, exc_type, exc_value, traceback):
        print('__exit__()')
    
    def query(self):
        print('Query info about %s...' % self.name)

# 使用
with Query('Bob') as q:
    q.query()
```
运行结果：
```
__enter__()
Query info about Bob...
__exit__()
```
**结果分析：**
&emsp;&emsp; ① 可以看到，` __enter__()`在进入`with`的时候被调用，而`__exit__()` 在离开`with`的时候被调用；
&emsp;&emsp; ② `__enter__()`的返回值赋给了`as`声明的变量。

**(2) 使用`contextlib`**
&emsp;&emsp; 其实和 实现 `__enter__()` 和 `__exit__()`的标准做法原理都是一样的，对于上面那个`Query`类，用`contextlib`可以改写如下：
```python
from contextlib import contextmanager

class Query(object):
    def __init__(self, name):
        self.name = name

    def query(self):
        print('Query info about %s...' % self.name)

@contextmanager
def create_query(name):
    print('Begin')
    q = Query(name)

    yield q # ① 进入with语句的时候，解释器直接推进到这里，然后立即返回

    # ② 执行完with语句的主体后，会执行这后面的代码
    
    print('End')

with create_query('Bob') as q:
    q.query()    
```
运行结果：
```
Begin
Query info about Bob...
End
```
其实这两种实现上下文管理器的方法，其它本质都是一样的，使用`contextlib`来实现其实就是：
> 新建一个辅助函数，这个辅助函数用`@contextmanager`修饰，
> `__enter__()` 里面的处理逻辑稍作修改放到了 辅助函数的`yield`语句 前面
>  `__exit__()` 里面的处理逻辑稍作修改放到了 辅助函数的`yield`语句 后面
> `__enter__()` 的返回值利用`yield`返回
> 

## 6.2 稍微复杂一点的实例
考虑如下的一个类，它能为我们创建一个网络连接：
**(1) 标准做法：实现 `__enter__()` 和 `__exit__()` 方法**
```python
from socket import socket, AF_INET, SOCK_STREAM
from functools import partial

class LazyConnection:
    def __init__(self, address, family=AF_INET, type=SOCK_STREAM):
        self.address = address
        self.family = family
        self.type = type
        self.sock = None

    def __enter__(self):
        print("__enter__() called.")
        if self.sock is not None:
            raise RuntimeError('Already connected')
        self.sock = socket(self.family, self.type)
        self.sock.connect(self.address)
        print(self.sock)
        return self.sock

    def __exit__(self, exc_ty, exc_val, tb):
        print("__exit__() called.")
        self.sock.close()
        self.sock = None


conn = LazyConnection(('www.python.org', 80))
# Connection closed
with conn as s:
    # conn.__enter__() executes: connection open
    print(s)
    s.send(b'GET /index.html HTTP/1.0\r\n')
    s.send(b'Host: www.python.org\r\n')
    s.send(b'\r\n')
    resp = b''.join(iter(partial(s.recv, 8192), b''))
    # conn.__exit__() executes: connection closed

print("Done!")
```
运行结果：
```
__enter__() called.
<socket.socket fd=380, family=AddressFamily.AF_INET, type=SocketKind.SOCK_STREAM, proto=0, laddr=('192.168.142.94', 55833), raddr=('151.101.76.223', 80)>
<socket.socket fd=380, family=AddressFamily.AF_INET, type=SocketKind.SOCK_STREAM, proto=0, laddr=('192.168.142.94', 55833), raddr=('151.101.76.223', 80)>
__exit__() called.
Done!
```
**结果分析：**
&emsp;&emsp; ① 可以看到，` __enter__()`在进入`with`的时候被调用，而`__exit__()` 在离开`with`的时候被调用；
&emsp;&emsp; ② `__enter__()`的返回值赋给了`as`声明的变量。

**(2) 使用`contextlib`和`with`语句**
```python
from contextlib import contextmanager
from socket import socket, AF_INET, SOCK_STREAM
from functools import partial

class LazyConnection:
    def __init__(self, address, family=AF_INET, type=SOCK_STREAM):
        self.address = address
        self.family = family
        self.type = type
        self.sock = None


@contextmanager
def create_LazyConnection(address, family=AF_INET, type=SOCK_STREAM):
    conn = LazyConnection(address, family, type)
    print("__enter__() called.")
    if conn.sock is not None:
        raise RuntimeError('Already connected')
    conn.sock = socket(conn.family, conn.type)
    conn.sock.connect(conn.address)
    print(conn.sock)

    yield conn.sock        
    
    print("__exit__() called.")
    conn.sock.close()
    conn.sock = None        

with create_LazyConnection(('www.python.org', 80)) as s:
    # conn.__enter__() executes: connection open
    print(s)
    s.send(b'GET /index.html HTTP/1.0\r\n')
    s.send(b'Host: www.python.org\r\n')
    s.send(b'\r\n')
    resp = b''.join(iter(partial(s.recv, 8192), b''))        
    # conn.__exit__() executes: connection closed

print("Done!")
```
运行结果：
```
__enter__() called.
<socket.socket fd=312, family=AddressFamily.AF_INET, type=SocketKind.SOCK_STREAM, proto=0, laddr=('192.168.142.94', 
59870), raddr=('151.101.76.223', 80)>
<socket.socket fd=312, family=AddressFamily.AF_INET, type=SocketKind.SOCK_STREAM, proto=0, laddr=('192.168.142.94', 
59870), raddr=('151.101.76.223', 80)>
__exit__() called.
Done!
```
**结果分析：**
&emsp;&emsp; 可以看到，和标准做法的效果其实是一样的。

## 6.3 关于 使用`contextlib`实现 上下文管理器时，系统的执行步骤
当系统开始执行`with`语句时，系统的执行步骤是：
> ① 把`@contextmanager`修饰的`create_LazyConnection()`函数推进到`yield conn.sock`，
> ② 执行`with`语句的主体部分；
> ③ 执行`create_LazyConnection()`函数中`yield conn.sock`后面的代码
> 


