
- [1 python的魔术方法](#1-python的魔术方法)
  - [1.1 什么是魔术方法？](#11-什么是魔术方法)
  - [1.2 `__new__`](#12-__new__)
    - [`__new__`的作用](#__new__的作用)
    - [1.2.1 `__new__`的其它应用](#121-__new__的其它应用)
  - [1.3 `__call__`](#13-__call__)
    - [1.3.1 `__call__`的作用是？](#131-__call__的作用是)
  - [1.4 `__getattr__(), __getattribute__(), __setattr__()`](#14-__getattr__-__getattribute__-__setattr__)
    - [1.4.1 `__getattr__()`](#141-__getattr__)
      - [(1) `__getattr__()`在何时被调用？](#1-__getattr__在何时被调用)
      - [(2) 定义`__getattr__()`时需要注意什么？](#2-定义__getattr__时需要注意什么)
    - [1.4.2 `__getattribute__()`](#142-__getattribute__)
      - [(1) `__getattribute__()`何时会被调用？](#1-__getattribute__何时会被调用)
      - [(2) 如果同时定义了`__getattribute__()` 和 `__getattr__()`，访问类属性时会发生什么？](#2-如果同时定义了__getattribute__-和-__getattr__访问类属性时会发生什么)
      - [(3) 定义`__getattribute__`时需要注意什么？](#3-定义__getattribute__时需要注意什么)
    - [1.4.3 `__setattr__()`](#143-__setattr__)
      - [(1) `__setattr__()`会在什么时候被调用？它需要完成的工作是？](#1-__setattr__会在什么时候被调用它需要完成的工作是)
      - [(2) 自定义`__setattr__()`时需要注意什么？](#2-自定义__setattr__时需要注意什么)
      - [(3) 通过`__dict__`添加属性会调用`__setattr__()`吗？](#3-通过__dict__添加属性会调用__setattr__吗)
      - [(4) 总结](#4-总结)
    - [1.4.4 关于`__getattribute__()` 、 `__getattr__()` 和 `__setattr__()` 造成死循环的原因的 一点总结](#144-关于__getattribute__--__getattr__-和-__setattr__-造成死循环的原因的-一点总结)
    - [1.4.5 如果一定要在`__getattribute__()` 、 `__getattr__()` 和 `__setattr__()`内部调用 本对象自己的属性，应该怎么做？](#145-如果一定要在__getattribute__--__getattr__-和-__setattr__内部调用-本对象自己的属性应该怎么做)
    - [1.4.6 `__getattribute__()` 、 `__getattr__()` 和 `__setattr__()`这几个方法来自哪里？](#146-__getattribute__--__getattr__-和-__setattr__这几个方法来自哪里)
  - [1.5 `__init_subclass__(cls)`方法](#15-__init_subclass__cls方法)
    - [1.5.1 `__init_subclass__(cls)`何时会被调用？](#151-__init_subclass__cls何时会被调用)
      - [上面`Derived`类中，基类后面的参数是什么](#上面derived类中基类后面的参数是什么)
    - [1.5.2 `__init_subclass__()`解决了什么问题？](#152-__init_subclass__解决了什么问题)
    - [1.5.3 `__init_subclass__(cls)`是什么类型的方法？是(实例方法、类方法，还是静态方法？)](#153-__init_subclass__cls是什么类型的方法是实例方法类方法还是静态方法)
  - [1.6 `__str__()` 和 `__repr__()`](#16-__str__-和-__repr__)
    - [1.6.1 这两个方法的作用是？](#161-这两个方法的作用是)
    - [1.6.2  `print()`调用的是哪个方法？](#162--print调用的是哪个方法)
      - [(1) 不显示指定](#1-不显示指定)
      - [(2) 显式指定](#2-显式指定)
    - [1.6.3 自定义`__repr__()` 的标准做法](#163-自定义__repr__-的标准做法)
    - [1.6.4 如果同时定义了`__str__()` 和 `__repr__()`，如何在格式化字符串的时候指定调用哪个版本？](#164-如果同时定义了__str__-和-__repr__如何在格式化字符串的时候指定调用哪个版本)
  - [1.7 `__enter__()` 和 `__exit__()`](#17-__enter__-和-__exit__)
- [2. Python的内置属性](#2-python的内置属性)
  - [2.1 `__dict__`属性](#21-__dict__属性)
    - [2.1.1 `__dict__`中存放的是什么？](#211-__dict__中存放的是什么)
    - [2.1.2 类本身的`__dict__` 和 类实例的`__dict__` 中存放的有何不同？](#212-类本身的__dict__-和-类实例的__dict__-中存放的有何不同)
    - [2.1.3 类内的 属性、方法 分别存放在哪里？](#213-类内的-属性方法-分别存放在哪里)
    - [2.1.4 `__dict__`的应用](#214-__dict__的应用)
      - [(1) 简化`__init__`的编写](#1-简化__init__的编写)
  - [2.2 `__slots__`](#22-__slots__)
- [3. `Mixin`类](#3-mixin类)
  - [3.1 什么是`Mixin`?](#31-什么是mixin)
  - [3.2 它可以用来解决什么问题？](#32-它可以用来解决什么问题)
  - [3.3 什么时候应该使用`Mixin`？](#33-什么时候应该使用mixin)
  - [3.4 如何使用？](#34-如何使用)
  - [3.5 可以为`Mixin`类创建对象吗？](#35-可以为mixin类创建对象吗)
  - [3.6 `Mixin`这项技术强调的是什么？](#36-mixin这项技术强调的是什么)
  - [3.7 `mixin`类一般有什么特征？](#37-mixin类一般有什么特征)
  - [3.8 总结](#38-总结)
- [4. `property`属性](#4-property属性)
  - [4.1 基本介绍](#41-基本介绍)
    - [4.1.1 `property`是什么？](#411-property是什么)
    - [4.1.2 `property`属性 的原理](#412-property属性-的原理)
      - [(1) `property`的实现](#1-property的实现)
      - [(2) `property`的运行原理](#2-property的运行原理)
  - [4.2 使用`property`属性](#42-使用property属性)
    - [10.2.1 `property`属性 有哪些使用方法？](#1021-property属性-有哪些使用方法)
    - [4.2.2 通过装饰器](#422-通过装饰器)
      - [(1) 通过装饰器定义`property`属性时需要注意哪些点？](#1-通过装饰器定义property属性时需要注意哪些点)
      - [(2) 实例](#2-实例)
      - [(3) 为什么在上面的代码中，`__init__()`明明是不带下划线的`first_name`，而在`property`的函数中访问的却是带下划线的`_first_name`?](#3-为什么在上面的代码中__init__明明是不带下划线的first_name而在property的函数中访问的却是带下划线的_first_name)
    - [4.2.3 通过`property()`函数](#423-通过property函数)
      - [(1) 如何使用`property()`函数？](#1-如何使用property函数)
    - [4.2.4 这两种定义`property()`属性的方法 我们应该使用哪个？](#424-这两种定义property属性的方法-我们应该使用哪个)
  - [4.3 `property`属性的应用](#43-property属性的应用)
    - [4.3.1 使用 `property()`属性的 原则是？](#431-使用-property属性的-原则是)
    - [4.3.2 `property`属性有哪些应用场景](#432-property属性有哪些应用场景)
- [5. 描述符(descriptor)](#5-描述符descriptor)
  - [5.1 什么是描述符？描述符协议 又是什么？](#51-什么是描述符描述符协议-又是什么)
  - [5.2 描述符的作用是？](#52-描述符的作用是)
  - [5.3 描述符的类型](#53-描述符的类型)
    - [5.3.1 描述符有哪几种类型？](#531-描述符有哪几种类型)
    - [5.3.2 这几种描述符类型有何差异？](#532-这几种描述符类型有何差异)
  - [5.4 描述符的具体使用](#54-描述符的具体使用)
    - [5.4.1 使用实例](#541-使用实例)
    - [11.4.2 注意事项](#1142-注意事项)
  - [5.5 描述其的运行原理](#55-描述其的运行原理)
    - [5.5.1 实例讲解](#551-实例讲解)
  - [5.6 描述符的应用](#56-描述符的应用)
    - [5.6.1 Python 内部的描述符](#561-python-内部的描述符)
    - [5.6.2 自定义描述符](#562-自定义描述符)
      - [(1) 概述](#1-概述)
      - [(2) 实现可复用的`@property`属性](#2-实现可复用的property属性)
  - [5.7 总结](#57-总结)
  - [5.8 参考文献](#58-参考文献)
- [6. 让对象支持 上下文管理协议(with语句)](#6-让对象支持-上下文管理协议with语句)
  - [6.1 如何让对象支持 下文管理协议(with语句)？](#61-如何让对象支持-下文管理协议with语句)
  - [6.2 稍微复杂一点的实例](#62-稍微复杂一点的实例)
  - [6.3 关于 使用`contextlib`实现 上下文管理器时，系统的执行步骤](#63-关于-使用contextlib实现-上下文管理器时系统的执行步骤)

&emsp;
&emsp; 
# 1 python的魔术方法
## 1.1 什么是魔术方法？
&emsp;&emsp; 在Python中，所有以双下划线`__`包起来的方法（如`__init__`），统称为`Magic Method`（魔术方法），它是一种的特殊方法，普通方法需要调用，而魔术方法不需要调用就可以自动执行。
&emsp;&emsp; 魔术方法在类或对象的某些事件出发后会自动执行，让类具有神奇的“魔力”。如果希望根据自己的程序定制自己特殊功能的类，那么就需要对这些方法进行重写。
&emsp;&emsp; Python中常用的运算符、for循环、以及类操作等都是运行在魔术方法之上的。


&emsp;
## 1.2 `__new__`
### `__new__`的作用
&emsp;&emsp; `__new__()`负责创建对象，每次创建一个新对象时，第一个调用的函数就是他。
&emsp;&emsp; `__new__()`会返回一个创建好的实例，然后`__init__()`会获取这个实例，然后对它进行初始化，**`__new__()` + `__init__` 是 python的构造函数**，它们的各自的工作是：
> **`__new__()`**：分配对象并将其返回；
> **`__init__`** ：初始化`__new__()`返回的对象
> 

### 1.2.1 `__new__`的其它应用
<span style="color:red; font-weight:bold; font-size:21px"> ① 实现单例模式 </span> 

&emsp;&emsp; 前面介绍了，`__new__()`是创建对象时调用的第一个函数，那意味着创建任何对象都要通过它，用它来实现单例模式太合适不过了：
```python
class Singleton:
    _instance = None
    def __new__(cls,*args, **kwargs):
        if cls._instance is None:
            cls._instance = object.__new__(cls,*args, **kwargs)
        return cls._instance


s1 = Singleton()
s2 = Singleton()
print(s1)
print(s2) 
```
运行结果：
```
<__main__.Singleton object at 0x00000289C2A33100>
<__main__.Singleton object at 0x00000289C2A33100>
```
**结果分析：**
&emsp;&emsp; 成功的用`__new__()`实现了单例模式。

<span style="color:red; font-weight:bold; font-size:21px"> ② 实现工厂模式 </span>

https://zhuanlan.zhihu.com/p/35943253


&emsp;
## 1.3 `__call__`
### 1.3.1 `__call__`的作用是？
&emsp;&emsp; `__call__`的功能类似于在类中重载 `()` 运算符，使得 **类实例对象**(注意是类对象，而不是类本身) 可以像调用普通函数那样，以`对象名()`的形式使用：
```python
from datetime import datetime

class Animal:
    def __init__(self, name, age) -> None:
        self.name = name
        self.__age = age


class Creature:
    def __init__(self, name, age) -> None:
        self.name = name
        self.__age = age

    def __call__(self):
        print(f"现在是{datetime.now().strftime('%a, %b %d %H:%M')}，你正在调用 __call__方法。")


c = Creature('jack', 20)
c()
print("\n","*"*50,"\n")
a = Animal('jack', 20)
a()
```
运行结果：
```
现在是Fri, Nov 19 21:47，你正在调用 __call__方法。

 **************************************************

Traceback (most recent call last):
  File "f:\code\python\test\test.py", line 23, in <module>
    a()
TypeError: 'Animal' object is not callable
```
**结果分析：**
&emsp;&emsp; `c`是`Creature`对象，因为`Creature`类定义了`__call__`对象，所以我们可以像调用一个函数一样调用它。
&emsp;&emsp; 但是`Animal`没有定义`__call__`对象，所以我们不能像函数一样调用它，因此会报错。


&emsp;
## 1.4 `__getattr__(), __getattribute__(), __setattr__()`
### 1.4.1 `__getattr__()`
#### (1) `__getattr__()`在何时被调用？
&emsp;&emsp; 类实例`instance`通过`instance.gender`访问属性`gender`，**只有当属性`gender`没有没有找到时**，才会调用`__getattr__()`。当属性`gender`可以通过正常机制追溯到时，_`_getattr__()`是不会被调用的。
&emsp;&emsp; 其实可以把`__getattr__()`看成是访问一个不存在的属性的最后落脚点，当我们访问一个不存在的属性的时候，会抛出异常，提示我们不存在这个属性。而这个异常就是`__getattr__()`方法抛出的。
```python
class Foo:
    def __init__(self, n):
        self.name = n

    def __getattr__(self, item):
        return f"Caught {item} in __getattr__()."

f = Foo("jack")
print(f.name)
print(f.gender)
```
运行结果：
```
jack
Caught gender in __getattr__().
```
**结果分析：**
&emsp;可以看到，
> &emsp;&emsp; ① 当我们访问一个存在的属性`name`时，没有调用 `__getattr__()`；
> &emsp;&emsp; ② 但我们在访问一个不存在的属性时，最终调用了`__getattr__()`。
> 

#### (2) 定义`__getattr__()`时需要注意什么？
如果在`__getattr__(self, item)`中对 传进去的`item`属性 进行访问，会导致无限递归错误：
```python
class Foo:
    def __init__(self, n):
        self.name = n

    def __getattr__(self, item):
        print(self.item) # 注意，这个item是传进来的实参
        return f"Caught {item} in __getattr__()."

f = Foo("jack")
print(f.name)
print(f.gender)
```
运行结果：
```
jack
Traceback (most recent call last):
  File "f:\code\python\test\test.py", line 11, in <module>
    print(f.gender)
  File "f:\code\python\test\test.py", line 6, in __getattr__
    print(self.item)
  File "f:\code\python\test\test.py", line 6, in __getattr__
    print(self.item)
  File "f:\code\python\test\test.py", line 6, in __getattr__
    print(self.item)
  [Previous line repeated 996 more times]
RecursionError: maximum recursion depth exceeded
```
这里强调一点，无限递归只会发生在访问不存在的属性时：
```python
class Foo:
    def __init__(self, n):
        self.name = n

    def __getattr__(self, item):
        print(self.name) # 注意，name属性是存在的！
        return f"Caught {item} in __getattr__()."

f = Foo("jack")
print(f.name)
print(f.gender)
```
运行结果：
```
jack
jack
Caught gender in __getattr__().
```
可以看到的是，没有发生栈溢出，那如果访问的是其它不存在的属性呢？来看看代码：
```python
class Foo:
    def __init__(self, n):
        self.name = n

    def __getattr__(self, item):
        # 注意，qi_ta_bu_cun_zai_de_shu_xing 和 item 一样不存在！
        print(self.qi_ta_bu_cun_zai_de_shu_xing) 
        return f"Caught {item} in __getattr__()."

f = Foo("jack")
print(f.name)
print(f.gender)
```
运行结果：
```
jack
Traceback (most recent call last):
  File "d:\code_practice\practice.py", line 11, in <module>
    print(f.gender)
  File "d:\code_practice\practice.py", line 6, in __getattr__
    print(self.qi_ta_bu_cun_zai_de_shu_xing) # 注意，这个item是实参
  File "d:\code_practice\practice.py", line 6, in __getattr__
    print(self.qi_ta_bu_cun_zai_de_shu_xing) # 注意，这个item是实参
  File "d:\code_practice\practice.py", line 6, in __getattr__
    print(self.qi_ta_bu_cun_zai_de_shu_xing) # 注意，这个item是实参
  [Previous line repeated 996 more times]
RecursionError: maximum recursion depth exceeded
```
<span style="color:red; font-size:21px; font-weight:bold">总结：</span>
&emsp;&emsp; 因为每次尝试访问不存在的属性时都会访问`__getattr__()`方法，所以在`__getattr__()`里面有访问不存在属性的代码最终肯定会继续除法`__getattr__()`方法，这就会导致无限循环。
&emsp;&emsp; 而访问存在的属性就不会无限循环，因为访问存在的属性并不会调用`__getattr__()`，那肯定不会造成无限循环。

### 1.4.2 `__getattribute__()`
#### (1) `__getattribute__()`何时会被调用？
&emsp;&emsp; 当类实例`instance`通过`instance.gender`访问属性`gender`，`__getattribute__`方法一直会被调用，无论属性`gender`是否追溯到。
```python
class Foo:
    def __init__(self, n):
        self.name = n

    def __getattribute__(self, item):
        return f"Caught {item} in __getattribute__()."

f = Foo("jack")
print(f.name)
print(f.gender)
```
运行结果：
```
Caught name in __getattribute__().
Caught gender in __getattribute__().
```
**结果分析：**
&emsp;&emsp; 可以看到，无论属性在不在，最终都会调用`__getattribute__()`。

#### (2) 如果同时定义了`__getattribute__()` 和 `__getattr__()`，访问类属性时会发生什么？
&emsp;&emsp; 如果同时定义了`__getattribute__()` 和 `__getattr__()`，**除在以下两种特殊情况下外，`_getattr__()`方法不会再被调用了**：
> ① 通过`__getattribute__()`显式的调用`__getattr__()`；
> ② `__getattribute__`方法内部出现`AttributeError`错误，
> 

**1) 正常情况：**
```python
class Foo:
    def __init__(self, n):
        self.name = n

    def __getattr__(self, item):

        return f"在__getattr__()中捕获 {item}."

    def __getattribute__(self, item):
        return f"Caught {item} in __getattribute__()."        

f = Foo("jack")
print(f.name)
print(f.gender)
```
运行结果：
```
Caught name in __getattribute__().
Caught gender in __getattribute__().
```
**结果分析：**
&emsp;&emsp; 可以看到，不管属性存不存在，都不会调用`__getattr__`，只会调用`__getattribute__`。

**2) 通过`__getattribute__`显式的调用`__getattr__()`：**
```python
class Foo:
    def __init__(self, n):
        self.name = n

    def __getattr__(self, item):

        return f"在__getattr__()中捕获 {item}."

    def __getattribute__(self, item):
        print("Entered __getattribute__.")
        super().__getattr__() # 显式调用 __getattr__()
        print("Left __getattribute__.")
        return f"Caught {item} in __getattribute__()."        


f = Foo("jack")
print(f.name)
print(f.gender)
```
运行结果：
```
Entered __getattribute__.
在__getattr__()中捕获 name.
Entered __getattribute__.
在__getattr__()中捕获 gender.
```
**结果分析：**
&emsp;&emsp; 可以看到，对属性进行访问时，是先进入了`__getattribute__()`，后面通过`super().__getattr__()`才进入的`__getattr__()`。

**3) `__getattribute__`方法内部出现`AttributeError`错误：**
```python
class Foo:
    def __init__(self, n):
        self.name = n

    def __getattr__(self, item):

        return f"在__getattr__()中捕获 {item}."

    def __getattribute__(self, item):
        print("Entered __getattribute__.")
        raise AttributeError # 主动触发 AttributeError
        print("Left __getattribute__.")
        return f"Caught {item} in __getattribute__()."        

f = Foo("jack")
print(f.name)
print(f.gender)
```
运行结果：
```
Entered __getattribute__.
在__getattr__()中捕获 name.
Entered __getattribute__.
在__getattr__()中捕获 gender.
```
**结果分析：**
&emsp;&emsp; 可以看到，对属性进行访问时，是先进入了`__getattribute__()`，后面通过`super().__getattr__()`才进入的`__getattr__()`。

<span style="color:red; font-size:21px; font-weight:bold">总结：</span>
&emsp;&emsp; ① 在同时定义了`__getattribute__()` 和 `__getattr__()`之后，任何访问属性的操作都会访问`__getattribute__()`，而不会访问`__getattr__()`；
&emsp;&emsp; ② 虽然在两个例外情况下会访问`_getattr__()`，但都是先进入`__getattribute__()`，然后再调用`_getattr__()`。

#### (3) 定义`__getattribute__`时需要注意什么？
&emsp;&emsp; 和`__getattr__()`一样，`__getattribute__`也存在死循环的风险，但是它们触发死循环的情况有所不同。
&emsp;&emsp; 和`__getattr__()`不一样的是：**在`__getattribute__`访问任何类的属性必定会触发死循环，不论该属性是否存在。**
**1) 属性存在**
```python
class Foo:
    def __init__(self, n):
        self.name = n

    def __getattribute__(self, item):
        print(self.name)
        return f"Caught {item} in __getattribute__()."        

f = Foo("jack")
print(f.name)
print(f.gender)
```
运行结果：
```
Traceback (most recent call last):
  File "d:\code_practice\practice.py", line 10, in <module>
    print(f.name)
  File "d:\code_practice\practice.py", line 6, in __getattribute__
    print(self.name)
  File "d:\code_practice\practice.py", line 6, in __getattribute__
    print(self.name)
  File "d:\code_practice\practice.py", line 6, in __getattribute__
    print(self.name)
  [Previous line repeated 996 more times]
RecursionError: maximum recursion depth exceeded
```
**2) 属性不存在**
```python
class Foo:
    def __init__(self, n):
        self.name = n

    def __getattribute__(self, item):
        print(self.NonExist)
        return f"Caught {item} in __getattribute__()."        

f = Foo("jack")
print(f.name)
```
运行结果：
```
Traceback (most recent call last):
  File "d:\code_practice\practice.py", line 10, in <module>
    print(f.name)
  File "d:\code_practice\practice.py", line 6, in __getattribute__
    print(self.NonExist)
  File "d:\code_practice\practice.py", line 6, in __getattribute__
    print(self.NonExist)
  File "d:\code_practice\practice.py", line 6, in __getattribute__
    print(self.NonExist)
  [Previous line repeated 996 more times]
RecursionError: maximum recursion depth exceeded
```
**结果分析：**
&emsp;&emsp; 可以看到，无论属性存不存在，只要在`__getattribute__()`尝试用`self`访问一个属性，那么就会触发死循环。

### 1.4.3 `__setattr__()`
#### (1) `__setattr__()`会在什么时候被调用？它需要完成的工作是？
&emsp;&emsp; 如果一个类定义了`__setattr__()`，那么所有**通过`slef.attr = value`**来 对类属性赋值、添加类属性 发生，就会调用`__setattr__()`，直接修改`self.__dict__`**不会**调用`__setattr__()`。
&emsp;&emsp; `__setattr__()`需要将值传过来的`key : value`保存到实例字典`self.__dict__`中。
```python
class Foo:
    def __init__(self, n):
        self.name = n

    # 注意，没有在__setattr__中对类属性进行注册
    def __setattr__(self, item, value):
        print(f"Caught {item} : {value} in __setattr__().")
        self.__dict__[item] = value


f = Foo("jack")
print(f.name) # 访问类属性
f.name = "Micheal"
print(f.name)
```
运行结果：
```
Caught name : jack in __setattr__().
jack
Caught name : Micheal in __setattr__().
Micheal
```
**结果分析：**
&emsp;&emsp; 我们对`f.name`进行过两次赋值：`f = Foo("jack")` 和 `f.name = "Micheal"`，这两次赋值都触发了`__setattr__()`

#### (2) 自定义`__setattr__()`时需要注意什么？
有两点需要注意：
&emsp; <span style="color:red; font-size:19px; font-weight:bold"> 1) 别忘了在内部将属性添加到`slef.__dict__`中 </span>
&emsp;&emsp; 由于`__setattr__()`负责在`self.__dict__`中对属性进行注册，所以自己在重载时千万不能忘记将传过来的属性和属性值保存到实例字典中。下面就是一个反面案例：
```python
class Foo:
    def __init__(self, n):
        self.name = n

    # 注意，没有在__setattr__中对类属性进行注册
    def __setattr__(self, item, value):
        print(f"Caught {item} : {value} in __setattr__().")


f = Foo("jack")
print(f.name) # 访问类属性
```
运行结果：
```
Caught name : jack in __setattr__().
Traceback (most recent call last):
  File "f:\code\python\test\test.py", line 11, in <module>
    print(f.name) # 访问类属性
AttributeError: 'Foo' object has no attribute 'name'   
```
**结果分析：**
&emsp;&emsp; 上面的代码没有在`Foo.__setattr__()`中对属性进行注册，所以后面`print(f.name)`会报`AttributeError`。
&emsp; <span style="color:red; font-size:19px; font-weight:bold"> 2) 不要在内部利用`self.attr = value`这样的语法赋值，而应该采用`self.__dict__`赋值 </span>
&emsp;&emsp; 因为`self.attr = value`会继续调用`__setattr__()`方法，然后开始无限循环：
```python
class Foo:
    def __init__(self, n):
        self.name = n

    # 注意，没有在__setattr__中对类属性进行注册
    def __setattr__(self, item, value):
        print(f"Caught {item} : {value} in __setattr__().")
        self.item = value # 错误，应该使用 self.__dict__[item] = value

f = Foo("jack")

```
运行结果：
```
  File "f:\code\python\test\test.py", line 8, in __setattr__
    self.item = value # 错误，应该使用 self.__dict__[item] = value
  [Previous line repeated 990 more times]
  File "f:\code\python\test\test.py", line 7, in __setattr__
    print(f"Caught {item} : {value} in __setattr__().")
RecursionError: maximum recursion depth exceeded while calling a Python object
```

#### (3) 通过`__dict__`添加属性会调用`__setattr__()`吗？
&emsp;&emsp; 显然不会。

#### (4) 总结
&emsp;&emsp; 只要通过`slef.attr = value`来 对类属性赋值、添加类属性 发生，就会调用`__setattr__()`，直接修改`self.__dict__`不会调用`__setattr__()`；
&emsp;&emsp; python的实例属性的定义、获取和管理可以通过`__setattr__()`和`__dict__`配合进行；
&emsp;&emsp; 不要再`__setattr__()`使用`self.attr = value`添加(修改属性，因为会导致无限循环；

### 1.4.4 关于`__getattribute__()` 、 `__getattr__()` 和 `__setattr__()` 造成死循环的原因的 一点总结
&emsp; 其实它俩都是因为会不停的递归调用而引发的死循环：
> &emsp;&emsp; ① `__getattr__()` 只有在属性不存在的时候才会被调用，所以只有在它里面调用不存在的属性的时候才会引发死循环；
> &emsp;&emsp; ② `__getattribute__()`无论访问的属性是否存在都会被触发，所以只要在它里面用`self`调用一个属性都会引发死循环。
> &emsp;&emsp; ③ `__setattr__()` 只要有`slef.attr = value`来 对类属性赋值、添加类属性 发生，就会被调用，所以
> 

### 1.4.5 如果一定要在`__getattribute__()` 、 `__getattr__()` 和 `__setattr__()`内部调用 本对象自己的属性，应该怎么做？
&emsp;&emsp; 为确保不会发生无限递归，使用`super()`来使用自己的属性最稳妥。

### 1.4.6 `__getattribute__()` 、 `__getattr__()` 和 `__setattr__()`这几个方法来自哪里？
&emsp;&emsp; 这几个方法其实都是`object`类提供的。


&emsp;
## 1.5 `__init_subclass__(cls)`方法
&emsp;&emsp; 类方法 `__init_subclass__(cls)`在`python3.6`引入，作用是：可以在 不使用元类的情况下 改变子类的行为。也就是说它是独立于元类编程的，而且也能达到编辑其他类的一种手段。
### 1.5.1 `__init_subclass__(cls)`何时会被调用？
&emsp;&emsp; `__init_subclass__()`会在 定义它的类被继承时 被调用，举个例子：
> 假设有一个类`Base`，他定义了`__init_subclass__()`，如果此时有一个类`Derieve`继承了`Base`，此时`Base.__init_subclass__()`会被调用，即使没有实例化`Base`或`Derieve`
> 
```python
class Base:
    def __init_subclass__(cls, **kwargs):
        super().__init_subclass__()
        print(f"__init_subclass__() \n{cls} \n{kwargs}")


class Derived(Base, name="satori", age=16): 
    pass
```
运行结果：
```
__init_subclass__() 
<class '__main__.Derived'>
{'name': 'satori', 'age': 16}
```
**结果分析：**
&emsp;&emsp; 可以看到的是，我们并没有实例化`Base`或`Derieve`，但是`Base.__init_subclass__()`却被调用了，证实了之前说的。
#### 上面`Derived`类中，基类后面的参数是什么
&emsp;&emsp; 官网是这么说的：
> Keyword arguments which are given to a new class are passed to the parent’s class __init_subclass__. For compatibility with other classes using __init_subclass__, one should take out the needed keyword arguments and pass the others over to the base class
> 
里面的参数是传给定义了`__init_subclass__`的基类的。

### 1.5.2 `__init_subclass__()`解决了什么问题？
&emsp;&emsp; 总的来说，`__init_subclass__()` 是钩子函数，**它解决了如何让父类知道被继承的问题。** 钩子中能改变类的行为，而不必求助与元类或类装饰器。钩子用起来也更简单且容易理解。

&emsp;&emsp; __init_subclass__ 的目标是提供更简单的定制方式，在简单的场景下是元类的替代品。值得试一试。
### 1.5.3 `__init_subclass__(cls)`是什么类型的方法？是(实例方法、类方法，还是静态方法？)
&emsp;&emsp; 可以看到的是，`__init_subclass__ `第一个参数是 `cls` 而不是常见的 `self` 。这是因为这个方法隐式地被 `@classmethod` 装饰，也就是说它是一个 **类方法**。


&emsp;
## 1.6 `__str__()` 和 `__repr__()`
### 1.6.1 这两个方法的作用是？
&emsp;&emsp; 它俩控制的是实例的字符串表示。如果想改变一个实例的字符串表示，可重新定义它的 `__str__()` 和 `__repr__()` 方法。但是他俩还是有区别的：
> `__repr__`的目标是 准确性，或者说，`__repr__`的结果是让解释器用的。 
> `__str__`的目标是 可读性，或者说，`__str__`的结果是让人看的。
> 


### 1.6.2  `print()`调用的是哪个方法？
#### (1) 不显示指定
&emsp;&emsp; 默认调用的是`__str__()`；但如果`__str__()`没有被定义，那解释器会用 `__repr__()`来代替输出：
```python
class Foo:
    def __str__(self):
        return "Foo.__str__"

    def __repr__(self):
        return "Foo.__repr__"

class Bar:
    def __repr__(self):
        return "Bar.__repr__"

foo = Foo()
bar = Bar()
print(foo)
print(bar)
```
运行结果：
```
Foo.__str__
Bar.__repr__
```

#### (2) 显式指定
```python
class Foo:
    def __str__(self):
        return "Foo.__str__"

    def __repr__(self):
        return "Foo.__repr__"

foo = Foo()
     
print(f"{foo!s}")
print(f"{foo!r}")
```
运行结果：
```
Foo.__str__
Foo.__repr__
```

### 1.6.3 自定义`__repr__()` 的标准做法
&emsp; 前面定义`__repr__()`都是为了说明这两个魔术方法，对于`__repr__()`，标准做法是：
> 要让 `eval(repr(x)) == x` 为真：
> 
```python
num = 3.14
print("num.__repr__() == num       : ", num.__repr__() == num)

print("eval(num.__repr__()) == num : ", eval(num.__repr__()) == num)
```
运行结果：
```
num.__repr__() == num       :  False
eval(num.__repr__()) == num :  True
```
**结果分析：**
&emsp;&emsp; 可以看到，将`__repr__()`的输出传给`eval()`函数之后，得到了一个它会和原对象相等。
如果实在不能做到`eval(repr(x)) == x` 为真，应该创建一个有用的文本表示，并使用 < 和 > 括起来。比如：
```python
>>> f = open('file.dat')
>>> f
<_io.TextIOWrapper name='file.dat' mode='r' encoding='UTF-8'>
>>>
```


### 1.6.4 如果同时定义了`__str__()` 和 `__repr__()`，如何在格式化字符串的时候指定调用哪个版本？
显示指定即可：
```python
class Foo:
    def __str__(self):
        return "Foo.__str__"

    def __repr__(self):
        return "Foo.__repr__"

foo = Foo()
     
print(f"{foo!s}")
print(f"{foo!r}")
```
运行结果：
```
Foo.__str__
Foo.__repr__
```


&emsp;
## 1.7 `__enter__()` 和 `__exit__()`
见 [6. 让对象支持 上下文管理协议(with语句)](#6-让对象支持-上下文管理协议with语句)




&emsp;
&emsp; 
# 2. Python的内置属性
## 2.1 `__dict__`属性
### 2.1.1 `__dict__`中存放的是什么？ 
&emsp;&emsp; `__dict__`是一个字典，其键为属性名，值为属性的值。

### 2.1.2 类本身的`__dict__` 和 类实例的`__dict__` 中存放的有何不同？
类本身的`__dict__` ：
> 类内部的函数都存在这，包括 静态函数、类函数、普通函数
> 类属性
> 
类实例的`__dict__` ：
> 只存放 实例属性(即`self.xxx`这样的。)
> 
```python
class Student:
    count = 0
    def __init__(self, n, g):
        self.name = n
        self.gender = g
        Student.count += 1
    
    def get_name(self):
        return self.name
    
    @staticmethod
    def static_test():
        print('a static func.')

    @classmethod
    def class_test(self):
        print('a class func.')

print(Student.__dict__, end="\n\n")

s = Student("Jack", "Man")
print(s.__dict__)
```
运行结果：
```
{'__module__': '__main__', 'count': 0, '__init__': <function Student.__init__ at 0x00000206B2E3E8C0>, 'get_name': <function Student.get_name at 0x00000206B2E3E950>, 'static_test': <staticmethod(<function Student.static_test at 0x00000206B2E3E9E0>)>, 'class_test': <classmethod(<function Student.class_test at 0x00000206B2E3EA70>)>, '__dict__': <attribute '__dict__' of 'Student' objects>, '__weakref__': <attribute '__weakref__' of 'Student' objects>, '__doc__': None}    

{'name': 'Jack', 'gender': 'Man'}
```
**结果分析：**
&emsp;&emsp; 可以看到的是，类内部函数全都在类的`__dict__`里面，类变量`count`也在里面；
&emsp;&emsp; 实例属性只存在于 实例自己的`__dict__`里面。
以上结果和前面的结论相符

### 2.1.3 类内的 属性、方法 分别存放在哪里？
① 所有的方法，包括 静态函数、类函数、普通函数，都保存在类本身的`__dict__` 中；
② 类属性存放在类本身的`__dict__` 中
③ 除了类属性外，其它的属性都存放在 实例的`__dict__` 中

### 2.1.4 `__dict__`的应用
#### (1) 简化`__init__`的编写
```python
class Person:  
    def __init__(self,_obj):
        self.name=dicts["name"]
        self.age=dicts["age"]
        self.sex=dicts["gender"]
        self.hobby=dicts["hobby"]

dicts={"name":"lisa","age":23,"sex":"women","hobby":"hardstyle"}
a=A(dicts)        
```
上面这么写是不是很冗长，很繁琐？使用`__dict__`t一句话就可以搞定：
```python
cclass Person:  
    def __init__(self, init_dict):  
        self.__dict__.update(init_dict)

dicts={"name":"lisa","age":23,"gender":"female","hobby":"hardstyle"}
a=A(dicts)            
```        

&emsp;
## 2.2 `__slots__`
https://zhuanlan.zhihu.com/p/25930288






&emsp;
&emsp; 
# 3. `Mixin`类
## 3.1 什么是`Mixin`?
&emsp;&emsp; `Mixin`即`Mix-in`，是一种**编程模式**，在 Python 等面向对象语言中，`Mixin`通常一个简单的类，它实现了某种功能单元，用于被其他子类继承，将功能组合到子类中。**我们可以将其看做是一项 代码复用 的技术**，使用它可以减少代码量。

## 3.2 它可以用来解决什么问题？
&emsp;&emsp; 多重继承是一个很有用的技术，但是很难用好，而且很难被其他开发者看懂，而`Mixin`可以一定程度上弥补这些缺陷。
&emsp;&emsp; 换句话说，`mixin`强调的是扩展及代码复用。

## 3.3 什么时候应该使用`Mixin`？
&emsp;&emsp; 当多个类都实现了同一种功能时，这时应该考虑将该功能抽离成 `Mixin`类，然后需要这个功能的类都可以继承它。

## 3.4 如何使用？
举个例子吧，定义一个简单的类：
```python
class Person:
    def __init__(self, name, gender, age):
        self.name = name
        self.gender = gender
        self.age = age

class Dog:
    def __init__(self, name, gender, age, breed):
        self.name = name
        self.gender = gender
        self.age = age   
        self.breed = breed
```
我们可以通过 调用实例属性的方式 来访问：
```python
p = Person("小陈", "男", 18)
print(p.name)  # "小陈"    

d = Dog("Lucky", '公', 3, 'Labrador')
print(d.name) # Lucky
```
但问题来了，我们希望`Person`和`Dog`都能拥有像 `dict` 一样调用属性的功能，于是我们需要给这两个类都加上`__getitem__()`和`__setitem__()`:
```python
class Person:
    def __init__(self, name, gender, age):
        self.name = name
        self.gender = gender
        self.age = age

    def __getitem__(self, key):
        return self.__dict__.get(key)

    def __setitem__(self, key, value):
        return self.__dict__.set(key, value)

class Dog:
    def __init__(self, name, gender, age, breed):
        self.name = name
        self.gender = gender
        self.age = age   
        self.breed = breed

    def __getitem__(self, key):
        return self.__dict__.get(key)

    def __setitem__(self, key, value):
        return self.__dict__.set(key, value)        

p = Person("小陈", "男", 18)
print(p['name'])  # "小陈"
print(p['age'])  # 18        


d = Dog("Lucky", '公', 3, 'Labrador')
print(d['name']) # Lucky
print(d['age'])    
```
运行结果：
```
小陈
18
Lucky
3
```
**结果分析：**
&emsp;&emsp; 我们成功的给`Person`和`Dog`添加了用关键字访问的功能，**但是这一点也不python，如果后续还需要添加其它功能，或者添加其它类，我们是不是还得分别给它们添加相关的方法呢？** `Mixin`完全可以解决这个问题：首先定义一个 `Mixin` 类：
```python
class MappingMixin:
    def __getitem__(self, key):
        return self.__dict__.get(key)

    def __setitem__(self, key, value):
        return self.__dict__.set(key, value)
```
`MappingMixin`类可以让子类拥有像 `dict` 一样调用属性的功能。我们将这个 `Mixin`类 加入到 `Person`类中：
```python
class Person(MappingMixin):
    def __init__(self, name, gender, age):
        self.name = name
        self.gender = gender
        self.age = age

class Dog(MappingMixin):
    def __init__(self, name, gender, age, breed):
        self.name = name
        self.gender = gender
        self.age = age   
        self.breed = breed        
```
现在 `Person`拥有另一种调用属性方式了：
```python
p = Person("小陈", "男", 18)
print(p['name'])  # "小陈"
print(p['age'])  # 18        


d = Dog("Lucky", '公', 3, 'Labrador')
print(d['name']) # Lucky
print(d['age'])  
```
再定义一个 `Mixin`类，这个类实现了 `__repr__` 方法，能自动将属性与值拼接成字符串：
```python
class ReprMixin:
    def __repr__(self):
        s = self.__class__.__name__ + '('
        for k, v in self.__dict__.items():
            if not k.startswith('_'):
                s += '{}={}, '.format(k, v)
        s = s.rstrip(', ') + ')'  # 将最后一个逗号和空格换成括号
        return s
```
利用多重继承，将`ReprMixin`也加到`Person`类中：
```python
class Person(MappingMixin, ReprMixin):
    def __init__(self, name, gender, age):
        self.name = name
        self.gender = gender
        self.age = age

class Dog(MappingMixin, ReprMixin):
    def __init__(self, name, gender, age, breed):
        self.name = name
        self.gender = gender
        self.age = age   
        self.breed = breed   

p = Person("小陈", "男", 18)
print(p['name'])  # "小陈"
print(p)  # Person(name=小陈, gender=男, age=18)

p = Person("小陈", "男", 18)
print(p['name'])  # "小陈"
print(p['age'])  # 18        


d = Dog("Lucky", '公', 3, 'Labrador')
print(d['name']) # Lucky
print(d['age'])  
print(d)
```
运行结果：
```
小陈
Person(name=小陈, gender=男, age=18)
小陈
18
Lucky
3
Dog(name=Lucky, gender=公, age=3, breed=Labrador)
```
**总结：**
&emsp;&emsp; 通过定义`Mixin`类`MappingMixin`和`ReprMixin`，我们简化了代码。

## 3.5 可以为`Mixin`类创建对象吗？
&emsp;&emsp; 可以的，这有点像带单下划线`_`的类对象是属于`proctected`对象一样，是一个约定成俗的东西，解释器并没有强制，但是最好按规矩办事。

## 3.6 `Mixin`这项技术强调的是什么？
&emsp;&emsp; `mixin`强调的是 代码复用。

## 3.7 `mixin`类一般有什么特征？
① 类名以`Mixin`结尾，如`MappingMixin`；
② `Mixin`类一般不带 实例属性，也没有`__init__()`；
③ 

## 3.8 总结
&emsp;&emsp; 其实可以把 `mixin`类 看成是一个插件，如果你创建的类要用到这个插件(`Mixin`)类提供的功能的话，那你就把这个`Mixin`类放到你的派生列表中。一般来说一个类会需要很多个功能，所以会需要好几个插件(即`Mixin`类)，所以它通常会和多重继承一起出现。







&emsp;
&emsp; 
# 4. `property`属性
## 4.1 基本介绍
### 4.1.1 `property`是什么？
&emsp;&emsp; `property`是一种内置的语法，使用`property`属性，可以把 类的方法 伪装成 类的属性(成员变量)，调用的方式也从原来的`Foo.func()`变为了`Foo.func`。

### 4.1.2 `property`属性 的原理
#### (1) `property`的实现
`property`其实是一个类，它有有三个成员方法和三个装饰器函数：
成员函数：
> `fget`：
> `fset`：
> `fdel`：
> 
装饰器函数：
> `getter` ：
> `setter` ：
> `deleter`：
> 
一个 `property`属性 其实就是一系列相关绑定方法的集合。如果查看拥有`property` 的类，就会发现 `property` 本身的 `fget`、 `fset` 和 `fdel`属性 就是类里面的普通方法。比如：
```python
print(Person.first_name.fget)
print(Person.first_name.fset)
print(Person.first_name.fdel)
```
运行结果：
```
<function Person.first_name at 0x0000022F50A3E950>
<function Person.first_name at 0x0000022F50A3E9E0>
<function Person.first_name at 0x0000022F50A3EA70>
```
通常来讲，我们不会直接取调用 `fget` 或者 `fset`，它们会在访问 property 的时候自动被触发。
#### (2) `property`的运行原理
&emsp;&emsp; 前面已经介绍，`property`会使 方法 **伪装成** 属性，这就导致该方法可以和属性一样使用：不再需要`()`。后面对这个`property`的读取会映射到`getter`上；修改会映射到`setter`上；`del`会映射到`deleter`上面。具体实例可以看下面对 通过装饰器定义的`Person`类 的代码运行分析。


&emsp; 
## 4.2 使用`property`属性
### 10.2.1 `property`属性 有哪些使用方法？
`property`属性有两种使用方法：
> **① 通过装饰器；**
> **② 通过`property()`函数**
> 

### 4.2.2 通过装饰器
#### (1) 通过装饰器定义`property`属性时需要注意哪些点？
&emsp;&emsp; ① `get`方法不需要显示定义，因为使用装饰器`@property`的那个方法其实就是该属性的`get`方法；
&emsp;&emsp; ② 一个属性中3个相关联的方法的名字都必须一样，而且必须和被修饰的方法名一致，比如`Person`类中的`first_name`；
&emsp;&emsp; ③ 只有在 `get`属性 被创建后，后面的两个装饰器 `set`属性 和 `del`属性 才能被定义；
&emsp;&emsp; ④ `@property`方法必须执行的很快。复杂或缓慢的操作(如IO或其它会引发副作用的那些任务)，还是用普通的方法来实现比较好。

#### (2) 实例
```python
class Person:
    def __init__(self, first_name):
        self.first_name = first_name # 注意，self.first_name调用的是 @first_name.setter

    # Getter function
    @property
    def first_name(self):
        return self._first_name

    # Setter function
    @first_name.setter
    def first_name(self, value):
        if not isinstance(value, str):
            raise TypeError('Expected a string')
        self._first_name = value

    # Deleter function (optional)
    @first_name.deleter
    def first_name(self):
        raise AttributeError("Can't delete attribute")

a = Person('Guido')
print(a.first_name)
a.first_name = 'jack'
print(a.first_name)
```
运行结果：
```
Guido
jack
```
> ① ·`print(a.first_name`访问的其实是被`@property`修饰的函数；
> ② `a.first_name = 'jack'`中的`a.first_name `访问的是被`@first_name.setter`修饰的函数；
> 


#### (3) 为什么在上面的代码中，`__init__()`明明是不带下划线的`first_name`，而在`property`的函数中访问的却是带下划线的`_first_name`?
&emsp;&emsp; 因为在`Person.__init__()`中，`self.first_name = first_name`的`self.first_name`调用的是`@first_name.setter`属性，我们来给上面的代码加点`log`：
```python
class Person:
    def __init__(self, first_name):
        print("Entered __init__.")
        self.first_name = first_name
        print("Left __init__.")

    # Getter function
    @property
    def first_name(self):
        return self._first_name

    # Setter function
    @first_name.setter
    def first_name(self, value):
        if not isinstance(value, str):
            raise TypeError('Expected a string')
        print("in @first_name.setter") # log 加在这里了
        self._first_name = value

    # Deleter function (optional)
    @first_name.deleter
    def first_name(self):
        raise AttributeError("Can't delete attribute")

a = Person('Guido')
print('\n', '*'*20, '\n')
print(a.first_name)
```
运行结果：
```
Entered __init__.
in @first_name.setter
Left __init__.

 ********************

Guido
```
**结果分析：**
&emsp;&emsp; 根据日志可以知道，`Person.__init__()`调用了`@first_name.setter`属性。

### 4.2.3 通过`property()`函数
#### (1) 如何使用`property()`函数？
&emsp;&emsp; 通过`property()`函数，我们可以还能在已存在的 get 和 set 方法基础上定义 property。
```python
class Person:
    def __init__(self, first_name):
        self.set_first_name(first_name)

    # Getter function
    def get_first_name(self):
        return self._first_name

    # Setter function
    def set_first_name(self, value):
        if not isinstance(value, str):
            raise TypeError('Expected a string')
        self._first_name = value
        
    # Deleter function (optional)
    def del_first_name(self):
        raise AttributeError("Can't delete attribute")

    # Make a property from existing get/set methods
    name = property(get_first_name, set_first_name, del_first_name)


a = Person('Guido')
print(a.name)
a.name = 'jack'
print(a.name)
```
运行结果：
```
Guido
jack
```

### 4.2.4 这两种定义`property()`属性的方法 我们应该使用哪个？
&emsp;&emsp; 一般情况下，建议使用装饰器来定义`property()`属性，一般在重构代码的时候才会使用`property()`函数来定义`property()`属性。

&emsp; 
## 4.3 `property`属性的应用
### 4.3.1 使用 `property()`属性的 原则是？
原则就是，不要写没有做任何其他额外操作的 `property`，例如：
```python
class Person:
    def __init__(self, first_name):
        self.first_name = first_name

    @property
    def first_name(self):
        return self._first_name

    @first_name.setter
    def first_name(self, value):
        self._first_name = value
```
上面的代码完全可以用成员函数来替代，而且这样做有如下缺点：
> 首先，它会让你的代码变得很臃肿，并且还会迷惑阅读者。
> 其次，它还会让你的程序运行起来变慢很多。
> 最后，这样的设计并没有带来任何的好处。特别是当你以后想给普通 attribute 访问添加额外的处理逻辑的时候，你可以将它变成一个 property 而无需改变原来的代码。因为访问 attribute的代码还是保持原样
> 

### 4.3.2 `property`属性有哪些应用场景
`property`属性一般有如下应用场景：
> ① 数据检查；
> ② 定义 需要动态计算的属性
> ③ 阻止属性被修改
**① 数据检查**
上面的`Person`类就是这样的例子：
```python
class Person:

    # 其它成员，略...

    # Setter function
    @first_name.setter
    def first_name(self, value):
        if not isinstance(value, str):
            raise TypeError('Expected a string')
        self._first_name = value
```
上面的`setter`属性检查了传过来的值是不是`str`，不是就`raise`。

**② 定义动态计算的属性**
&emsp;&emsp; `Properties` 还是一种定义动态计算 `attribute` 的方法。这种类型的 `attributes` 并不会被实际的存储，而是在需要的时候计算出来。
&emsp;&emsp; 比如，一个记录个人信息的类中，一般会要求输入生日，但是一般不会要用户输入自己的年龄，因为年龄是会随着时间而动态变化的，这个时候`property`属性就派上了用场：
```python
from datetime import datetime

class Person:
    def __init__(self, name, birthday, gender):
        self.name = name
        self.birthday = datetime.strptime(birthday, "%Y-%m-%d")
        self.gender = gender

    @property    
    def age(self):
        return datetime.now().year - self.birthday.year  


p1 = Person("张无忌", "2000-05-06", "男")
p2 = Person("周芷若", "2002-05-06", "女")

print(p1.age)
print(p2.age)
```
运行结果：
```
21
19
```
**③ 阻止属性被修改**
下面的`@ohms.setter`可以阻止 父类的 属性 被修改：
```python
class Resistor:
    def __init__(self, ohms):
        print("Enterd Resistor.__init__()")
        self.ohms = ohms
        self.voltage = 0
        self.current = 0
        print("Left Resistor.__init__()\n")

class FixedResistance(Resistor):
    def __init__(self, ohms):
        super().__init__(ohms)

    @property
    def ohms(self):
        return self._ohms

    @ohms.setter
    def ohms(self, ohms):
        print("    Entered @ohms.setter")
        if hasattr(self, '_ohms'):
            raise AttributeError("Ohms is immutable")
        self._ohms = ohms
        print("    Left @ohms.setter")


r4 = FixedResistance(1e3)
r4.ohms = 2e3
```
运行结果：
```
Enterd Resistor.__init__()
    Entered @ohms.setter
    Left @ohms.setter
Left Resistor.__init__()

    Entered @ohms.setter
Traceback (most recent call last):
  File "f:\code\python\test\test.py", line 27, in <module>
    r4.ohms = 2e3
  File "f:\code\python\test\test.py", line 21, in ohms
    raise AttributeError("Ohms is immutable")
AttributeError: Ohms is immutable
```
**结果分析：**
&emsp;&emsp; `super().__init__(ohms)`会运行基类的初始化函数，基类的初始化函数中的`self.ohms = ohms`的`self.ohms`会调用子类的`@ohms.setter`，所以`_ohms`在此时被创建了；
&emsp;&emsp; `r4.ohms = 2e3`调用的也是`@ohms.setter`，而此时`_ohms`已经在初始化的时候被创建了，所以报错






&emsp;
&emsp; 
# 5. 描述符(descriptor)
## 5.1 什么是描述符？描述符协议 又是什么？
&emsp;&emsp; 描述符的定义很简单，实现了下列 **任意一个或多个** 方法的 `Python`对象 就是一个描述符：
```python
__get__(self, instance, type=None)
__set__(self, instance, value)
__delete__(self, instance)
```
这些方法的参数含义如下：
> **`self`** 是当前定义的描述符对象实例。
> **`instance`** 是该描述符将作用的对象实例。
> **`type`** 是该描述符作用的对象的类型（即所属的类）。
> 
上述方法也被称为**描述符协议(descriptor protocol)**，Python 会在特定的时机按协议传入参数调用某一方法，如果我们未按协议约定的参数定义方法，调用可能会出错。
&emsp;&emsp; **本质上看，描述符就是一个类**，只不过它定义了**另一个类**中属性的访问方式。换句话说，一个类可以将属性管理全权委托给描述符类。


&emsp;
## 5.2 描述符的作用是？
&emsp;&emsp; 描述符就是一个“绑定行为“的对象属性，在描述符协议中，它可以通过方法重写属性的访问。我们或许经常看见描述符的作用描述中，有两个关键词“绑定行为”和“托管属性”，那到底是什么意思呢，这有一个通俗的解释：
> &emsp;&emsp; **绑定行为**：所谓的绑定行为，是指在属性的访问、赋值、删除时还绑定发生了其他的事情，正如前面属性控制三剑客所完成的事情一样；
> &emsp;&emsp; **托管属性**：python描述符是一种创建“托管属性”的方法，即通过描述符（类）去托管另一个类的相关属性，也可以说是类的属性的一个代理。为了方便的理解“托管属性”这个概念，将通过几个通俗的例子去说明。
> 
以人类而言，Person是一个类，人应该有很多属性，比如人是美丽的、性感的、成熟的、博学的、大方的等等，所谓的“描述”，本身指的就是描述某一个类的某一些特性的，在程序设计中，属性就是用来描述类的特征的，所谓的描述符（描述类）就是专门再创建一个类，让这个类去描述本身那个类的相关属性，这也正是“描述”二字的由来，其实和我们生活中的描述是一个意思。
&emsp;&emsp; 总而言之，描述符的作用是用来代理另外一个类的属性的。


&emsp;
## 5.3 描述符的类型
### 5.3.1 描述符有哪几种类型？
根据**所实现的协议方法不同**，描述符可分为两类：
* ① 若实现了 `__set__()` 或 `__delete__()` 任一方法，该描述符是一个**数据描述符（data descriptor）**。
* ② 若仅实现 `__get__()` 方法，该描述符是一个**非数据描述符（non-data descriptor）**。
  
### 5.3.2 这几种描述符类型有何差异？
两者的在表现行为上存在差异：
> 数据描述符 总是会覆盖实例字典 `__dict__` 中的属性。
> 而非数据描述符 会被实例字典 `__dict__` 中定义的属性所覆盖。
> 
下面写段代码来验证一下:
```python
class NonDataDescriptor:
    def __get__(self, instance, owner):
        if instance is None:
            print('NonDataDescriptor.__get__(): Accessing y from the class', owner)
            return self

        print('NonDataDescriptor.__get__(): Accessing y from the object', instance)
        return 'Y from non-data descriptor'

class Descriptor:
    def __get__(self, instance, owner):
        if instance is None:
            print('Descriptor.__get__(): Accessing x from the class', owner)
            return self
        
        print('Descriptor.__get__(): Accessing x from the object', instance)
        return 'X from descriptor'

    def __set__(self, instance, value):
        print('Descriptor.__set__(): Setting x on the object', instance)
        instance.__dict__['_x'] = value

class Bar:
    x = Descriptor()
    y = NonDataDescriptor()


bar = Bar()
print(bar.x, end = "\n\n")
print(bar.y, end = "\n\n")

# 下面通过__dict__修改
print("通过__dict__修改之后：")
bar.__dict__['x'] = "x"
bar.__dict__['y'] = "y"
print(bar.x, end = "\n\n")
print(bar.y, end = "\n\n")
```
运行结果：
```
X from descriptor

NonDataDescriptor.__get__(): Accessing y from the object <__main__.Bar object at 0x000001EE5C523E80>
Y from non-data descriptor

通过__dict__修改之后：
Descriptor.__get__(): Accessing x from the object <__main__.Bar object at 0x000001EE5C523E80>
X from descriptor

y

```
**结果分析：**
&emsp;&emsp; 可以看到，通过`__dict__`覆盖后，类型为数据描述符的`x`还是调用的`Descriptor.__get__()`；而类型为非数据描述符的`y`被覆盖了。


&emsp;
## 5.4 描述符的具体使用
### 5.4.1 使用实例
&emsp;&emsp; 前面提到，要实现所谓的描述符，就是要实现上面描述符协议中的三个魔术方法，但是和普通类定义的方式不一样，因为“属性代理（属性托管）”的机制，我们需要定义两个类：
> 一个 描述符类`A`，它实现描述符协议中方法；
> 一个 被描述符代理的类`B`，即所谓的描述类，它会使用前面定义的 描述符类`A`。
> 
来看一个例子，其中`Descriptor`是描述符类，`Foo`使用了描述符类：
```python
class Descriptor:
    def __get__(self, instance, owner):
        if instance is None:
            print('__get__(): Accessing x from the class', owner)
            return self
        
        print('__get__(): Accessing x from the object', instance)
        return 'X from descriptor'

    def __set__(self, instance, value):
        print('__set__(): Setting x on the object', instance)
        instance.__dict__['_x'] = value

class Foo:
    x = Descriptor()


print("通过类访问：")
print(Foo.x)    

print("\n通过实例访问：")
foo = Foo()
print(foo.x)
foo.x = 5
```
运行结果：
```
通过类访问：
__get__(): Accessing x from the class <class '__main__.Foo'>
<__main__.Descriptor object at 0x00000248C0AEE980>

通过实例访问：
__get__(): Accessing x from the object <__main__.Foo object at 0x00000248C0B92FE0>
X from descriptor
__set__(): Setting x on the object <__main__.Foo object at 0x00000248C0B92FE0>
```
**结果分析：**
&emsp;&emsp; 可以看到的是，无论是通过类本身，还是通过类实例，访问`Foo.x`都会自动调用该属性所绑定的描述符实例的 `__get__()`方法。
&emsp;&emsp; 对 实例对象`foo`的`x`进行赋值，会调用描述符的`__set__()` 方法。

### 11.4.2 注意事项
&emsp;&emsp; 我们注意到，上面的`Foo`类在使用描述符类的时候，是将`x`定义成了类属性，如果将`x`定义成实例属性会发生什么呢？我们写段代码来验证一下：
```python
class Descriptor:
    # 同上，略...

class Foo:
    def __init__(self):
        self.x = Descriptor()


foo = Foo()
print(foo.x)
foo.x = 5
```
运行结果：
```
<__main__.Descriptor object at 0x0000023607BA2F50>
```
**结果分析：**
&emsp;&emsp; 可以看到的是，描述符没有生效，只是打印了`self.x`自己的地址。

&emsp;&emsp; <span style="color:red; font-size:21px; font-weight:bold"> 需要注意的是，描述符在属性查找过程中会被`.`点操作符调用，且只有在作为类变量使用时才有效。如果直接赋值给实例属性，描述符不会生效。 </span>
另外，使用`__dict__`属性访问描述符也不会调用 描述符的协议方法，而是返回描述符实例本身：
```python
class Descriptor:
    # 同上，略...

class Foo:
    x = Descriptor()

print(Foo.__dict__['x'])
```
运行结果：
```
<__main__.Descriptor object at 0x0000023607BA2F50>
```


&emsp;
## 5.5 描述其的运行原理
### 5.5.1 实例讲解
现有描述符`Grade`和 使用描述符的`Exam`类：
```python
class Grade:
    def __get__(self, instance, instance_type):
        ...
        
    def __set__(self, instance, value):
        ...

class Exam:
    # Class attributes
    math_grade = Grade()
    writing_grade = Grade()
    science_grade = Grade()        
```
我们需要给`Exam`实例的`writing_grade`属性赋值
```python
exam = Exam()
exam.writing_grade = 40
```
那么解释器会把这次赋值操作转译为：
```python
Exam.__dict__['writing_grade'].__set__(exam,
```
获取这个属性也一样：
```python
exam.writing_grade
```
将被翻译成：
```python
Exam.__dict__['writing_grade'].__get__(exam, Exam)
```
上面的转译效果是由`object`类的` __getattribute__()`方法完成的，简单的说，就是当 `Exam`实例 中没有名为`writing_grade`的属性时，Python会转而在类的层面查找，如果类的层面有，而且还是个实现了`__get__()` 和  `__set__()` 的对象，那么系统就会认为你想通过描述符协议定义的这个属性的访问行为。


&emsp;
## 5.6 描述符的应用
### 5.6.1 Python 内部的描述符
&emsp;&emsp; 除了一些自定义的场景，Python 本身的语言机制中就大量使用了描述符：
> ① `@property`属性
> ② 类方法`@classmethod`
> ③ 静态方法`@staticmethod`
> 

### 5.6.2 自定义描述符
#### (1) 概述
描述符的本质在于“描述”二字，最大的用处是对属性的个性定制与控制，如前所说，
&emsp;&emsp; (1）可以在设置属性时，做些检测等方面的处理   
&emsp;&emsp; (2）设置属性不能被删除？那定义_delete_方法，并raise 异常。 
&emsp;&emsp; (3）还可以设置只读属性 
&emsp;&emsp; (4）把一个描述符作为某个对象的属性。这个属性要更改，比如增加判断，或变得更复杂的时候，所有的处理只要在描述符中操作就行了。 
这一系列其实都是为了更好地去控制一个属性。
#### (2) 实现可复用的`@property`属性
&emsp;&emsp; 详见 [Effective Python Item 46](../Effective%20Python.md)的相关笔记。


&emsp;
## 5.7 总结
&emsp;&emsp; 其他类在使用描述符的时候，必须将描述符实例定义成类属性，不能定义成实例属性：
```python
class Descriptor:
    # 同上，略...

class Foo:
    x = Descriptor() # 正确
    def __init__(self):
        self.y = Descriptor() # 错误
```

&emsp;
## 5.8 参考文献
1. [面向对象（深入）|python描述器详解](https://zhuanlan.zhihu.com/p/32764345)






&emsp;
&emsp; 
# 6. 让对象支持 上下文管理协议(with语句)
## 6.1 如何让对象支持 下文管理协议(with语句)？
有两种方法：
**(1) 标准做法：实现 `__enter__()` 和 `__exit__()` 方法**
为了让一个对象兼容 `with` 语句，需要实现`__enter__()` 和 `__exit__()` 方法：
> ` __enter__()`：它将在`with`出现的时候被触发，返回对象会赋给`as`声明的变量；
> `__exit__()` ： 他将在 离开`with`语句块时被触发，一般用它来进行清理工作。
> 
```python
class Query(object):

    def __init__(self, name):
        self.name = name

    def __enter__(self):
        print('__enter__()')
        return self
    
    def __exit__(self, exc_type, exc_value, traceback):
        print('__exit__()')
    
    def query(self):
        print('Query info about %s...' % self.name)

# 使用
with Query('Bob') as q:
    q.query()
```
运行结果：
```
__enter__()
Query info about Bob...
__exit__()
```
**结果分析：**
&emsp;&emsp; ① 可以看到，` __enter__()`在进入`with`的时候被调用，而`__exit__()` 在离开`with`的时候被调用；
&emsp;&emsp; ② `__enter__()`的返回值赋给了`as`声明的变量。

**(2) 使用`contextlib`**
&emsp;&emsp; 其实和 实现 `__enter__()` 和 `__exit__()`的标准做法原理都是一样的，对于上面那个`Query`类，用`contextlib`可以改写如下：
```python
from contextlib import contextmanager

class Query(object):
    def __init__(self, name):
        self.name = name

    def query(self):
        print('Query info about %s...' % self.name)

@contextmanager
def create_query(name):
    print('Begin')
    q = Query(name)

    yield q # ① 进入with语句的时候，解释器直接推进到这里，然后立即返回

    # ② 执行完with语句的主体后，会执行这后面的代码
    
    print('End')

with create_query('Bob') as q:
    q.query()    
```
运行结果：
```
Begin
Query info about Bob...
End
```
其实这两种实现上下文管理器的方法，其它本质都是一样的，使用`contextlib`来实现其实就是：
> 新建一个辅助函数，这个辅助函数用`@contextmanager`修饰，
> `__enter__()` 里面的处理逻辑稍作修改放到了 辅助函数的`yield`语句 前面
>  `__exit__()` 里面的处理逻辑稍作修改放到了 辅助函数的`yield`语句 后面
> `__enter__()` 的返回值利用`yield`返回
> 

## 6.2 稍微复杂一点的实例
考虑如下的一个类，它能为我们创建一个网络连接：
**(1) 标准做法：实现 `__enter__()` 和 `__exit__()` 方法**
```python
from socket import socket, AF_INET, SOCK_STREAM
from functools import partial

class LazyConnection:
    def __init__(self, address, family=AF_INET, type=SOCK_STREAM):
        self.address = address
        self.family = family
        self.type = type
        self.sock = None

    def __enter__(self):
        print("__enter__() called.")
        if self.sock is not None:
            raise RuntimeError('Already connected')
        self.sock = socket(self.family, self.type)
        self.sock.connect(self.address)
        print(self.sock)
        return self.sock

    def __exit__(self, exc_ty, exc_val, tb):
        print("__exit__() called.")
        self.sock.close()
        self.sock = None


conn = LazyConnection(('www.python.org', 80))
# Connection closed
with conn as s:
    # conn.__enter__() executes: connection open
    print(s)
    s.send(b'GET /index.html HTTP/1.0\r\n')
    s.send(b'Host: www.python.org\r\n')
    s.send(b'\r\n')
    resp = b''.join(iter(partial(s.recv, 8192), b''))
    # conn.__exit__() executes: connection closed

print("Done!")
```
运行结果：
```
__enter__() called.
<socket.socket fd=380, family=AddressFamily.AF_INET, type=SocketKind.SOCK_STREAM, proto=0, laddr=('192.168.142.94', 55833), raddr=('151.101.76.223', 80)>
<socket.socket fd=380, family=AddressFamily.AF_INET, type=SocketKind.SOCK_STREAM, proto=0, laddr=('192.168.142.94', 55833), raddr=('151.101.76.223', 80)>
__exit__() called.
Done!
```
**结果分析：**
&emsp;&emsp; ① 可以看到，` __enter__()`在进入`with`的时候被调用，而`__exit__()` 在离开`with`的时候被调用；
&emsp;&emsp; ② `__enter__()`的返回值赋给了`as`声明的变量。

**(2) 使用`contextlib`和`with`语句**
```python
from contextlib import contextmanager
from socket import socket, AF_INET, SOCK_STREAM
from functools import partial

class LazyConnection:
    def __init__(self, address, family=AF_INET, type=SOCK_STREAM):
        self.address = address
        self.family = family
        self.type = type
        self.sock = None


@contextmanager
def create_LazyConnection(address, family=AF_INET, type=SOCK_STREAM):
    conn = LazyConnection(address, family, type)
    print("__enter__() called.")
    if conn.sock is not None:
        raise RuntimeError('Already connected')
    conn.sock = socket(conn.family, conn.type)
    conn.sock.connect(conn.address)
    print(conn.sock)

    yield conn.sock        
    
    print("__exit__() called.")
    conn.sock.close()
    conn.sock = None        

with create_LazyConnection(('www.python.org', 80)) as s:
    # conn.__enter__() executes: connection open
    print(s)
    s.send(b'GET /index.html HTTP/1.0\r\n')
    s.send(b'Host: www.python.org\r\n')
    s.send(b'\r\n')
    resp = b''.join(iter(partial(s.recv, 8192), b''))        
    # conn.__exit__() executes: connection closed

print("Done!")
```
运行结果：
```
__enter__() called.
<socket.socket fd=312, family=AddressFamily.AF_INET, type=SocketKind.SOCK_STREAM, proto=0, laddr=('192.168.142.94', 
59870), raddr=('151.101.76.223', 80)>
<socket.socket fd=312, family=AddressFamily.AF_INET, type=SocketKind.SOCK_STREAM, proto=0, laddr=('192.168.142.94', 
59870), raddr=('151.101.76.223', 80)>
__exit__() called.
Done!
```
**结果分析：**
&emsp;&emsp; 可以看到，和标准做法的效果其实是一样的。

## 6.3 关于 使用`contextlib`实现 上下文管理器时，系统的执行步骤
当系统开始执行`with`语句时，系统的执行步骤是：
> ① 把`@contextmanager`修饰的`create_LazyConnection()`函数推进到`yield conn.sock`，
> ② 执行`with`语句的主体部分；
> ③ 执行`create_LazyConnection()`函数中`yield conn.sock`后面的代码
> 


