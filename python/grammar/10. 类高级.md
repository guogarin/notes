[toc]






&emsp;
&emsp;
# 1、抽象基类(ABC, abstract class)
## 1.1. 基础
### 1.1.1 什么时候才应该使用 抽象基类？
《fluent python》的作者不推荐用户自己编写抽象基类， 因为很容易过度设计，只有少数精英Python开发者编写的抽象基类不会对用户施加不必要的限制，让他们做无用功：
> &emsp;&emsp; 抽象基类是用于封装框架引入的一般性概念和抽象的， 例如“一个序列”和“一个确切的数”。 （读者）基本上不需要自己编写新的抽象基类， 只要正确使用现有的抽象基类， 就能获得 99.9% 的好处， 而不用冒着设计不当导致的巨大风险。
> 

### 1.1.2 什么是抽象类？
&emsp;&emsp; 在C++中，抽象基类是指类里定义了纯虚成员函数的类。
&emsp;&emsp; 在python中，抽象基类一般指的是只提供接口，不能实例化的类。

### 1.1.3 抽象基类有什么特点？
&emsp;&emsp; 抽象基类不能被实例化。

### 1.1.4 如何定义抽象基类？
Python没有定义抽象基类的语法，只能通过使用 `abc` 模块来定义抽象基类：
```python
from abc import ABCMeta, abstractmethod

class MyAbc(metaclass=ABCMeta):
    @abstractmethod
    def my_abstractmethod(self):
        print("my_abstractmethod")


m = MyAbc()
```
运行结果：
```
Traceback (most recent call last):
  File "d:\code_practice\practice.py", line 9, in <module>
    m = MyAbc()
TypeError: Can't instantiate abstract class MyAbc with abstract method my_abstractmethod
```

### 1.1.5 `collections.abc` 与 `abc`模块 是同一个东西吗?
&emsp;&emsp; 不是一个东西，`collections.abc`是基于`abc`模块的，它从`abc`模块中导入抽象基类( `ABCMeta` ， `abstractmethod` )，进而封装了一系列抽象基类;
&emsp;&emsp; 而`abc`(即`Lib/abc`) 本质就是一个单独模块，是用来定义抽象基类的，也可以说是抽象基类的接口；
**总结：**
&emsp;&emsp; `abc`模块是定义抽象基类的基础，而`collections.abc`是基于 `abc`模块定义了一些有用的的抽象基类，这些基类可以方便我们开发；

&emsp;
## 1.2. 标准库中的抽象基类
### 1.2.1 标准库中的抽象基类在哪个模块中？
&emsp;&emsp; Python 自带许多内置的`ABC`用于实现数据结构（在`collections.abc`模块中）、数字（在`numbers`模块中）、流（在`io`模块中）、导入查找器和加载器（在`importlib.abc`模块中）。

### 1.2.2 抽象基类的 抽象方法(Abstract Methods) 和 `Mixin`方法(Mixin Methods) 是什么？
关于 下表中的抽象方法(Abstract Methods)和`Mixin`方法(Mixin Methods)：
> **抽象方法(Abstract Methods)**  : 子类必须实现的方法；
> **`Mixin` 方法(Mixin Methods)** : 子类可选择提供的方法。
> 
比如说，对于抽象基类`Sequence`：
> `__getitem__`和`__len__`是抽象方法;
> __contains__, __iter__, __reversed__, index, and count是`Mixin`方法。
> 
**(1) 继承`Sequence`，但不实现抽象方法`__len__`**
```python
from collections.abc import Sequence

class C(Sequence):                      # Direct inheritance
    def __init__(self): ...             # Extra method not required by the ABC
    def __getitem__(self, index):  ...  # Required abstract method
    #def __len__(self):  ...             # Required abstract method
    def count(self, value): ...         # Optionally override a mixin method

c = C()
```
运行结果：
```
Traceback (most recent call last):
  File "d:\code_practice\practice.py", line 9, in <module>
    c = C()
TypeError: Can't instantiate abstract class C with abstract method __len__
```
显然，抽象方法`__len__`是必须的。
**(2) 继承`Sequence`，但不实现`Mixin`方法`count`**
```python
from collections.abc import Sequence

class C(Sequence):                      # Direct inheritance
    def __init__(self): ...             # Extra method not required by the ABC
    def __getitem__(self, index):  ...  # Required abstract method
    def __len__(self):  ...             # Required abstract method
    #def count(self, value): ...         # Optionally override a mixin method

c = C()
print("Done!")
```
运行结果：
```
Done!
```
可以看到的是，`Mixin`方法是可选的，可根据需要选择是否实现。
**关于继承抽象基类需要注意的另一点是：**
如果继承了某个ABC，但没有实现某个抽象方法，报错只会出现在实例化该类时：
```python
from collections.abc import Sequence

class C(Sequence):                      # Direct inheritance
    def __init__(self): ...             # Extra method not required by the ABC
    def __getitem__(self, index):  ...  # Required abstract method
    #def __len__(self):  ...             # Required abstract method
    #def count(self, value): ...         # Optionally override a mixin method


print("Done!")
```
运行结果：
```
Done!
```

### 1.2.3 `collections.abc`模块中的ABC
#### 1.2.3.1 `collections.abc`中包含的ABC
&emsp;&emsp; 官方文档对[collections.abc的容器抽象基类](https://docs.python.org/3/library/collections.abc.html#collections-abstract-base-classes)做了总结， 说明了相互之间的关系， 以及各个基类提供的 抽象方法 和 `Mixin`方法：
| ABC               | 继承自                           | 抽象方法                                                           | Mixin 方法                                                                                                              | 加入版本 |
| ----------------- | -------------------------------- | ------------------------------------------------------------------ | ----------------------------------------------------------------------------------------------------------------------- | -------- |
| `Container`       |                                  |                                                                    | `__contains__`                                                                                                          |          |
| `Hashable`        |                                  |                                                                    | `__hash__`                                                                                                              |          |
| `Iterable`        |                                  |                                                                    | `__iter__`                                                                                                              |          |
| `Iterator`        | `Iterable`                       | `__next__`                                                         | `__iter__`                                                                                                              |          |
| `Reversible`      | `Iterable`                       | `__reversed__`                                                     |                                                                                                                         |          |
| `Generator`       | `Iterator`                       | `send`, `throw`                                                    | `close`, `__iter__`, `__next__`                                                                                         |          |
| `Sized`           |                                  | `__len__`                                                          |                                                                                                                         |          |
| `Callable`        |                                  | `__call__`                                                         |                                                                                                                         |          |
| `Collection`      | `Sized`, `Iterable`, `Container` | `__contains__`, `__iter__`, `__len__`                              |                                                                                                                         |          |
| `Sequence`        | `Reversible`, `Collection`       | `__getitem__`, `__len__`                                           | `__contains__`, `__iter__`, `__reversed__`, `index`, and `count`                                                        |          |
| `MutableSequence` | `Sequence`                       | `__getitem__`, `__setitem__`, `__delitem__`, `__len__`, `insert`   | Inherited `Sequence` methods and `append`, `reverse`, `extend`, `pop`, `remove`, and `__iadd__`                         |          |
| `ByteString`      | `Sequence`                       | `__getitem__`, `__len__`                                           | Inherited `Sequence` methods                                                                                            |          |
| `Set`             | `Collection`                     | `__contains__`, `__iter__`, `__len__`                              | `__le__`, `__lt__`, `__eq__`, `__ne__`, `__gt__`, `__ge__`, `__and__`, `__or__`, `__sub__`, `__xor__`, and `isdisjoint` |          |
| `MutableSet`      | `Set`                            | `__contains__`, `__iter__`, `__len__`, `add`, `discard`            | Inherited `Set` methods and `clear`, `pop`, `remove`, `__ior__`, `__iand__`, `__ixor__`, and `__isub__`                 |          |
| `Mapping`         | `Collection`                     | `__getitem__`, `__iter__`, `__len__`                               | `__contains__`, `keys`, `items`, `values`, `get`, `__eq__`, and `__ne__`                                                |          |
| `MutableMapping`  | `Mapping`                        | `__getitem__`, `__setitem__`, `__delitem__`, `__iter__`, `__len__` | Inherited `Mapping` methods and `pop`, `popitem`, `clear`, `update`, and `setdefault`                                   |          |
| `MappingView`     | `Sized`                          |                                                                    | `__len__`                                                                                                               |          |
| `ItemsView`       | `MappingView`, `Set`             |                                                                    | `__contains__`, `__iter__`                                                                                              |          |
| `KeysView`        | `MappingView`, `Set`             |                                                                    | `__contains__`, `__iter__`                                                                                              |          |
| `ValuesView`      | `MappingView`, `Collection`      |                                                                    | `__contains__`, `__iter__`                                                                                              |          |
| `Awaitable`       |                                  | `__await__`                                                        |                                                                                                                         |          |
| `Coroutine`       | `Awaitable`                      | `send`, `throw`                                                    | `close`                                                                                                                 |          |
| `AsyncIterable`   |                                  | `__aiter__`                                                        |                                                                                                                         |          |
| `AsyncIterator`   | `AsyncIterable`                  | `__anext__`                                                        | `__aiter__`                                                                                                             |          |
| `AsyncGenerator`  | `AsyncIterator`                  | `asend`, `athrow`                                                  | `aclose`, `__aiter__`, `__anext__`                                                                                      |          |

#### 1.2.3.2 `collections.abc`中包含的ABC 的分类

**(1) `Iterable`、`Container`、`Sized`**
这三个抽象基类是最基础的类，各个集合都继承了这三个抽象基类。
> ① `Itearble` 通过 `__iter__` 方法支持迭代
> ② `Container` 通过 `__contains__` 方法支持in运算符
> ③ `Sized` 通过 `__len__` 方法支持`len()`函数
> 
**(2) `Sequence`、 `Mapping` 和 `Set`**
&emsp;&emsp; 这三个是主要的**不可变**集合类型， 而且各自都有**可变版本**(`Mutable`)的子类：
> ① `MutableSequence` 
> ② `MutableMapping`
> ③ `MutableSet` 
> 

**(3) `MappingView`**
&emsp;&emsp; 在 Python3 中， 映射方法 `.items()`、 `.keys()` 和 `.values()` 返回的对象分别是`ItemsView`、 `KeysView` 和 `ValuesView` 的实例。 前两个类还从 `Set` 类继承了丰富的接口。

**(4) `Callable` 和 `Hashable`**
&emsp;&emsp; 这两个抽象基类与集合没有太大的关系， 只不过因为 `collections.abc` 是标准库中定义抽象基类的第一个模块， 而它们又太重要了， 因此才把它们放到 `collections.abc` 模块中。 我从未见过 `Callable`或 `Hashable` 的子类。 这两个抽象基类的主要作用是为内置函数 `isinstance` 提供支持， 以一种安全的方式判断对象能不能调用或散列。

**(5) `Iterator`**
&emsp;&emsp; 它是`Iterable` 的子类。

**(6) `Awaitable`**
TODO: 

### 1.2.4 `numbers`模块中的抽象基类
&emsp;&emsp; `numbers`模块中定义的是“数字塔”（即各个抽象基类的层次结构是线性的），其中 `Number` 是位于最顶端的超类，随后是 `Complex` 子类，依次往下，最底端是 `Integral` 类：
> ① `Number`
> ② `Complex`
> ③ `Real`
> ④ `Rational`
> ⑤ `Integral`
> 
&emsp;&emsp; 因此， 如果想检查一个数是不是整数，可以使用 `isinstance(x, numbers.Integral)`， 这样代码就能接受 `int`、 `bool`（`int` 的子类） ， 或者外部库使用 `numbers` 抽象基类注册的其他类型。 为了满足检查的需要， 你或者你的 API 的用户始终可以把兼容的类型注册为 `numbers.Integral` 的虚拟子类。
&emsp;&emsp; 与之类似， 如果一个值可能是浮点数类型， 可以使用 `isinstance(x, numbers.Real)` 检查。 这样代码就能接受 `bool`、 `int`、 `float`、 `fractions.Fraction`， 或者外部库 提供的非复数类型。
&emsp;&emsp; `decimal.Decimal `没有注册为 `numbers.Real` 的虚拟子类， 这有点奇怪。 没注册的原因是， 如果你的程序需要 `Decimal` 的精度， 要防止与其他低精度数字类型混淆， 尤其是浮点数。

### 1.2.5 `issubclass()` 和 `isinstance()` 的用法
**(1) 方法一：继承**
&emsp;&emsp; 新编写的类可以直接从一个抽象基类继承。类必须提供所需的抽象方法。其余的 mixin 方法来自继承，如果需要可以重写，可根据需要添加其他方法：
```python
class C(Sequence):                      # Direct inheritance
    def __init__(self): ...             # Extra method not required by the ABC
    def __getitem__(self, index):  ...  # Required abstract method
    def __len__(self):  ...             # Required abstract method
    def count(self, value): ...         # Optionally override a mixin method
>>>
>>> issubclass(C, Sequence)
True
>>> isinstance(C(), Sequence)
True
```
**(2) 方法二：注册虚拟子类(virtual subclass)**
&emsp;&emsp; 现有类和内置类可以注册为 ABC 的“虚拟子类”。这些类应该定义完整的 API，包括所有的抽象方法和所有的 `M<ixin`方法。这允许用户依靠 `isinstance()` 和 `issubclass()` 测试来确定是否支持完整接口。此规则的例外情况是从 API 的其余部分自动推断出的方法：
```python
class D:                                 # No inheritance
    def __init__(self): ...              # Extra method not required by the ABC
    def __getitem__(self, index):  ...   # Abstract method
    def __len__(self):  ...              # Abstract method
    def count(self, value): ...          # Mixin method
    def index(self, value): ...          # Mixin method

Sequence.register(D)                     # Register instead of inherit
>>>
>>> issubclass(D, Sequence)
True
>>> isinstance(D(), Sequence)
True
```
**(3) 方法三：直接使用**
&emsp;&emsp; 某些简单接口可以通过所需方法的存在直接识别（除非这些方法已设置为 None）：
```python
class E:
    def __iter__(self): ...
    def __next__(next): ...
>>>
>>> issubclass(E, Iterable)
True
>>> isinstance(E(), Iterable)
True
```
复杂接口不支持这种一种技术，因为接口不仅仅是方法名的存在，接口指定方法之间的语义和关系，这些语义和关系不能仅从特定方法名称的存在来推断。例如，已知一个类提供了`__getitem__``、__len__` 和 `__iter__`，这时就不足以区分序列和映射。





&emsp;
&emsp; 
# 2. 子类化内置类型很麻烦(Subclassing Built-In Types Is Tricky)
## 2.1 继承内置类型会出现什么问题？
&emsp; 内置类型（使用 C 语言编写） 不会调用用户定义的类覆盖的特殊方法：
> &emsp;&emsp; 内置类型的子类覆盖的方法会不会隐式调用， CPython 没有制定官方规则。 基本上， 内置类型的方法不会调用子类覆盖的方法。 例如， `dict` 的子类覆盖的 `__getitem__()` 方法不会被内置类型的`get()` 方法调用。
> 
下面的示例说明了这个问题：
```python
class DoppelDict(dict):
    def __setitem__(self, key, value):
        super().__setitem__(key, [value] * 2) # ➊

dd = DoppelDict(one=1) # ➋
print(dd) 

dd['two'] = 2  # ➌
print(dd) 

dd.update(three=3) # ➍
print(dd)
```
运行结果：
```
{'one': 1}
{'one': 1, 'two': [2, 2]}
{'one': 1, 'two': [2, 2], 'three': 3}
```
**结果分析：**
> ❶ `DoppelDict.__setitem__` 方法会重复存入的值（只是为了提供易于观察的效果） 。 它把职责委托给超类。
> ❷ 继承自 `dict` 的 `__init__` 方法显然忽略了我们覆盖的 `__setitem__` 方法： 'one' 的值没有重复。
> ❸ `[]` 运算符会调用我们覆盖的 `__setitem__` 方法， 按预期那样工作： 'two' 对应的是两个重复的值， 即`[2, 2]`。
> ❹ 继承自 `dict `的 `update` 方法也不使用我们覆盖的 `__setitem__` 方法： 'three' 的值没有重复。
> 
&emsp;&emsp; 原生类型的这种行为违背了面向对象编程的一个基本原则：始终应该从实例（`self`） 所属的类开始搜索方法，即使在超类实现的类中调用也是如此。在这种糟糕的局面中， `__missing__()`方法却能按预期方式工作，不过这只是特例。


## 2.2 如何解决这个问题呢？
&emsp;&emsp; 直接子类化内置类型（如 `dict`、`list` 或 `str`）容易出错，因为内置类型的方法通常会忽略用户覆盖的方法。不要子类化内置类型， 用户自己定义的类应该继承 `collections` 模块中的类， 例如`UserDict`、`UserList` 和 `UserString`， 这些类做了特殊设计， 因此易于扩展。
如果不子类化 `dict`， 而是子类化 `collections.UserDict`， 前面暴露的问题便迎刃而解了：
```python
from collections import UserDict


class DoppelDict(UserDict):
    def __setitem__(self, key, value):
        super().__setitem__(key, [value] * 2) # ➊

dd = DoppelDict(one=1) # ➋
print(dd) 

dd['two'] = 2  # ➌
print(dd) 

dd.update(three=3) # ➍
print(dd)
```
运行结果：
```
{'one': [1, 1]}
{'one': [1, 1], 'two': [2, 2]}
{'one': [1, 1], 'two': [2, 2], 'three': [3, 3]}
```




&emsp;
&emsp; 
# 3. `Mixin`类
## 3.1 什么是`Mixin`?
&emsp;&emsp; `Mixin`即`Mix-in`，是一种**编程模式**，在 Python 等面向对象语言中，`Mixin`通常一个简单的类，它实现了某种功能单元，用于被其他子类继承，将功能组合到子类中。**我们可以将其看做是一项 代码复用 的技术**，使用它可以减少代码量。

## 3.2 它可以用来解决什么问题？
&emsp;&emsp; 多重继承是一个很有用的技术，但是很难用好，而且很难被其他开发者看懂，而`Mixin`可以一定程度上弥补这些缺陷。
&emsp;&emsp; 换句话说，`mixin`强调的是扩展及代码复用。

## 3.3 什么时候应该使用`Mixin`？
&emsp;&emsp; 当多个类都实现了同一种功能时，这时应该考虑将该功能抽离成 `Mixin`类，然后需要这个功能的类都可以继承它。

## 3.4 如何使用？
举个例子吧，定义一个简单的类：
```python
class Person:
    def __init__(self, name, gender, age):
        self.name = name
        self.gender = gender
        self.age = age

class Dog:
    def __init__(self, name, gender, age, breed):
        self.name = name
        self.gender = gender
        self.age = age   
        self.breed = breed
```
我们可以通过 调用实例属性的方式 来访问：
```python
p = Person("小陈", "男", 18)
print(p.name)  # "小陈"    

d = Dog("Lucky", '公', 3, 'Labrador')
print(d.name) # Lucky
```
但问题来了，我们希望`Person`和`Dog`都能拥有像 `dict` 一样调用属性的功能，于是我们需要给这两个类都加上`__getitem__()`和`__setitem__()`:
```python
class Person:
    def __init__(self, name, gender, age):
        self.name = name
        self.gender = gender
        self.age = age

    def __getitem__(self, key):
        return self.__dict__.get(key)

    def __setitem__(self, key, value):
        return self.__dict__.set(key, value)

class Dog:
    def __init__(self, name, gender, age, breed):
        self.name = name
        self.gender = gender
        self.age = age   
        self.breed = breed

    def __getitem__(self, key):
        return self.__dict__.get(key)

    def __setitem__(self, key, value):
        return self.__dict__.set(key, value)        

p = Person("小陈", "男", 18)
print(p['name'])  # "小陈"
print(p['age'])  # 18        


d = Dog("Lucky", '公', 3, 'Labrador')
print(d['name']) # Lucky
print(d['age'])    
```
运行结果：
```
小陈
18
Lucky
3
```
**结果分析：**
&emsp;&emsp; 我们成功的给`Person`和`Dog`添加了用关键字访问的功能，**但是这一点也不python，如果后续还需要添加其它功能，或者添加其它类，我们是不是还得分别给它们添加相关的方法呢？** `Mixin`完全可以解决这个问题：首先定义一个 `Mixin` 类：
```python
class MappingMixin:
    def __getitem__(self, key):
        return self.__dict__.get(key)

    def __setitem__(self, key, value):
        return self.__dict__.set(key, value)
```
`MappingMixin`类可以让子类拥有像 `dict` 一样调用属性的功能。我们将这个 `Mixin`类 加入到 `Person`类中：
```python
class Person(MappingMixin):
    def __init__(self, name, gender, age):
        self.name = name
        self.gender = gender
        self.age = age

class Dog(MappingMixin):
    def __init__(self, name, gender, age, breed):
        self.name = name
        self.gender = gender
        self.age = age   
        self.breed = breed        
```
现在 `Person`拥有另一种调用属性方式了：
```python
p = Person("小陈", "男", 18)
print(p['name'])  # "小陈"
print(p['age'])  # 18        


d = Dog("Lucky", '公', 3, 'Labrador')
print(d['name']) # Lucky
print(d['age'])  
```
再定义一个 `Mixin`类，这个类实现了 `__repr__` 方法，能自动将属性与值拼接成字符串：
```python
class ReprMixin:
    def __repr__(self):
        s = self.__class__.__name__ + '('
        for k, v in self.__dict__.items():
            if not k.startswith('_'):
                s += '{}={}, '.format(k, v)
        s = s.rstrip(', ') + ')'  # 将最后一个逗号和空格换成括号
        return s
```
利用多重继承，将`ReprMixin`也加到`Person`类中：
```python
class Person(MappingMixin, ReprMixin):
    def __init__(self, name, gender, age):
        self.name = name
        self.gender = gender
        self.age = age

class Dog(MappingMixin, ReprMixin):
    def __init__(self, name, gender, age, breed):
        self.name = name
        self.gender = gender
        self.age = age   
        self.breed = breed   

p = Person("小陈", "男", 18)
print(p['name'])  # "小陈"
print(p)  # Person(name=小陈, gender=男, age=18)

p = Person("小陈", "男", 18)
print(p['name'])  # "小陈"
print(p['age'])  # 18        


d = Dog("Lucky", '公', 3, 'Labrador')
print(d['name']) # Lucky
print(d['age'])  
print(d)
```
运行结果：
```
小陈
Person(name=小陈, gender=男, age=18)
小陈
18
Lucky
3
Dog(name=Lucky, gender=公, age=3, breed=Labrador)
```
**总结：**
&emsp;&emsp; 通过定义`Mixin`类`MappingMixin`和`ReprMixin`，我们简化了代码。

## 3.5 可以为`Mixin`类创建对象吗？
&emsp;&emsp; 可以的，这有点像带单下划线`_`的类对象是属于`proctected`对象一样，是一个约定成俗的东西，解释器并没有强制，但是最好按规矩办事。

## 3.6 `Mixin`这项技术强调的是什么？
&emsp;&emsp; `mixin`强调的是 代码复用。

## 3.7 `mixin`类一般有什么特征？
① 类名以`Mixin`结尾，如`MappingMixin`；
 

## 3.8 总结
&emsp;&emsp; 其实可以把 `mixin`类 看成是一个插件，如果你创建的类要用到这个插件(`Mixin`)类提供的功能的话，那你就把这个`Mixin`类放到你的派生列表中。一般来说一个类会需要很多个功能，所以会需要好几个插件(即`Mixin`类)，所以它通常会和多重继承一起出现。







&emsp;
&emsp; 
# 4. `property`属性
## 4.1 基本介绍
### 4.1.1 `property`是什么？
&emsp;&emsp; `property`是一种内置的语法，使用`property`属性，可以把 类的方法 伪装成 类的属性(成员变量)，调用的方式也从原来的`Foo.func()`变为了`Foo.func`。

### 4.1.2 `property`属性 的原理
#### (1) `property`的实现
`property`其实是一个类，它有有三个成员方法和三个装饰器函数：
成员函数：
> ① `fget`：
> ② `fset`：
> ③ `fdel`：
> 
装饰器函数：
> ① `getter` ：
> ② `setter` ：
> ③ `deleter`：
> 
一个 `property`属性 其实就是一系列相关绑定方法的集合。如果查看拥有`property` 的类，就会发现 `property` 本身的 `fget`、 `fset` 和 `fdel`属性 就是类里面的普通方法。比如：
```python
print(Person.first_name.fget)
print(Person.first_name.fset)
print(Person.first_name.fdel)
```
运行结果：
```
<function Person.first_name at 0x0000022F50A3E950>
<function Person.first_name at 0x0000022F50A3E9E0>
<function Person.first_name at 0x0000022F50A3EA70>
```
通常来讲，我们不会直接取调用 `fget` 或者 `fset`，它们会在访问 property 的时候自动被触发。
#### (2) `property`的运行原理
&emsp;&emsp; 前面已经介绍，`property`会使 方法 **伪装成** 属性，这就导致该方法可以和属性一样使用：不再需要`()`。后面对这个`property`的读取会映射到`getter`上；修改会映射到`setter`上；`del`会映射到`deleter`上面。具体实例可以看下面对 通过装饰器定义的`Person`类 的代码运行分析。


&emsp; 
## 4.2 使用`property`属性
### 4.2.1 `property`属性 有哪些使用方法？
`property`属性有两种使用方法：
> **① 通过装饰器；**
> **② 通过`property()`函数**
> 

### 4.2.2 通过装饰器
#### (1) 通过装饰器定义`property`属性时需要注意哪些点？
&emsp;&emsp; ① `get`方法不需要显示定义，因为使用装饰器`@property`的那个方法其实就是该属性的`get`方法；
&emsp;&emsp; ② 一个属性中3个相关联的方法的名字都必须一样，而且必须和被修饰的方法名一致，比如`Person`类中的`first_name`；
&emsp;&emsp; ③ 只有在 `get`属性 被创建后，后面的两个装饰器 `set`属性 和 `del`属性 才能被定义；
&emsp;&emsp; ④ `@property`方法必须执行的很快。复杂或缓慢的操作(如IO或其它会引发副作用的那些任务)，还是用普通的方法来实现比较好。

#### (2) 实例
```python
class Person:
    def __init__(self, first_name):
        self.first_name = first_name # 注意，self.first_name调用的是 @first_name.setter

    # Getter function
    @property
    def first_name(self):
        return self._first_name

    # Setter function
    @first_name.setter
    def first_name(self, value):
        if not isinstance(value, str):
            raise TypeError('Expected a string')
        self._first_name = value

    # Deleter function (optional)
    @first_name.deleter
    def first_name(self):
        raise AttributeError("Can't delete attribute")

a = Person('Guido')
print(a.first_name)
a.first_name = 'jack'
print(a.first_name)
```
运行结果：
```
Guido
jack
```
> ① `print(a.first_name`访问的其实是被`@property`修饰的函数；
> ② `a.first_name = 'jack'`中的`a.first_name `访问的是被`@first_name.setter`修饰的函数；
> 


#### (3) 为什么在上面的代码中，`__init__()`明明是不带下划线的`first_name`，而在`property`的函数中访问的却是带下划线的`_first_name`?
&emsp;&emsp; 因为在`Person.__init__()`中，`self.first_name = first_name`的`self.first_name`调用的是`@first_name.setter`属性，我们来给上面的代码加点`log`：
```python
class Person:
    def __init__(self, first_name):
        print("Entered __init__.")
        self.first_name = first_name
        print("Left __init__.")

    # Getter function
    @property
    def first_name(self):
        return self._first_name

    # Setter function
    @first_name.setter
    def first_name(self, value):
        if not isinstance(value, str):
            raise TypeError('Expected a string')
        print("in @first_name.setter") # log 加在这里了
        self._first_name = value

    # Deleter function (optional)
    @first_name.deleter
    def first_name(self):
        raise AttributeError("Can't delete attribute")

a = Person('Guido')
print('\n', '*'*20, '\n')
print(a.first_name)
```
运行结果：
```
Entered __init__.
in @first_name.setter
Left __init__.

 ********************

Guido
```
**结果分析：**
&emsp;&emsp; 根据日志可以知道，`Person.__init__()`调用了`@first_name.setter`属性。

### 4.2.3 通过`property()`函数
#### (1) 如何使用`property()`函数？
&emsp;&emsp; 通过`property()`函数，我们可以还能在已存在的 get 和 set 方法基础上定义 property。
```python
class Person:
    def __init__(self, first_name):
        self.set_first_name(first_name)

    # Getter function
    def get_first_name(self):
        return self._first_name

    # Setter function
    def set_first_name(self, value):
        if not isinstance(value, str):
            raise TypeError('Expected a string')
        self._first_name = value
        
    # Deleter function (optional)
    def del_first_name(self):
        raise AttributeError("Can't delete attribute")

    # Make a property from existing get/set methods
    name = property(get_first_name, set_first_name, del_first_name)


a = Person('Guido')
print(a.name)
a.name = 'jack'
print(a.name)
```
运行结果：
```
Guido
jack
```

### 4.2.4 这两种定义`property()`属性的方法 我们应该使用哪个？
&emsp;&emsp; 一般情况下，建议使用装饰器来定义`property()`属性，一般在重构代码的时候才会使用`property()`函数来定义`property()`属性。

&emsp; 
## 4.3 `property`属性的应用
### 4.3.1 使用 `property()`属性的 原则是？
原则就是，不要写没有做任何其他额外操作的 `property`，例如：
```python
class Person:
    def __init__(self, first_name):
        self.first_name = first_name

    @property
    def first_name(self):
        return self._first_name

    @first_name.setter
    def first_name(self, value):
        self._first_name = value
```
上面的代码完全可以用成员函数来替代，而且这样做有如下缺点：
> 首先，它会让你的代码变得很臃肿，并且还会迷惑阅读者。
> 其次，它还会让你的程序运行起来变慢很多。
> 最后，这样的设计并没有带来任何的好处。特别是当你以后想给普通 attribute 访问添加额外的处理逻辑的时候，你可以将它变成一个 property 而无需改变原来的代码。因为访问 attribute的代码还是保持原样
> 

### 4.3.2 `property`属性有哪些应用场景
`property`属性一般有如下应用场景：
> ① 数据检查；
> ② 定义 需要动态计算的属性
> ③ 阻止属性被修改
> 
**① 数据检查**
上面的`Person`类就是这样的例子：
```python
class Person:

    # 其它成员，略...

    # Setter function
    @first_name.setter
    def first_name(self, value):
        if not isinstance(value, str):
            raise TypeError('Expected a string')
        self._first_name = value
```
上面的`setter`属性检查了传过来的值是不是`str`，不是就`raise`。

**② 定义动态计算的属性**
&emsp;&emsp; `Properties` 还是一种定义动态计算 `attribute` 的方法。这种类型的 `attributes` 并不会被实际的存储，而是在需要的时候计算出来。
&emsp;&emsp; 比如，一个记录个人信息的类中，一般会要求输入生日，但是一般不会要用户输入自己的年龄，因为年龄是会随着时间而动态变化的，这个时候`property`属性就派上了用场：
```python
from datetime import datetime

class Person:
    def __init__(self, name, birthday, gender):
        self.name = name
        self.birthday = datetime.strptime(birthday, "%Y-%m-%d")
        self.gender = gender

    @property    
    def age(self):
        return datetime.now().year - self.birthday.year  


p1 = Person("张无忌", "2000-05-06", "男")
p2 = Person("周芷若", "2002-05-06", "女")

print(p1.age)
print(p2.age)
```
运行结果：
```
21
19
```
**③ 阻止属性被修改**
下面的`@ohms.setter`可以阻止 父类的 属性 被修改：
```python
class Resistor:
    def __init__(self, ohms):
        print("Enterd Resistor.__init__()")
        self.ohms = ohms
        self.voltage = 0
        self.current = 0
        print("Left Resistor.__init__()\n")

class FixedResistance(Resistor):
    def __init__(self, ohms):
        super().__init__(ohms)

    @property
    def ohms(self):
        return self._ohms

    @ohms.setter
    def ohms(self, ohms):
        print("    Entered @ohms.setter")
        if hasattr(self, '_ohms'):
            raise AttributeError("Ohms is immutable")
        self._ohms = ohms
        print("    Left @ohms.setter")


r4 = FixedResistance(1e3)
r4.ohms = 2e3
```
运行结果：
```
Enterd Resistor.__init__()
    Entered @ohms.setter
    Left @ohms.setter
Left Resistor.__init__()

    Entered @ohms.setter
Traceback (most recent call last):
  File "f:\code\python\test\test.py", line 27, in <module>
    r4.ohms = 2e3
  File "f:\code\python\test\test.py", line 21, in ohms
    raise AttributeError("Ohms is immutable")
AttributeError: Ohms is immutable
```
**结果分析：**
&emsp;&emsp; `super().__init__(ohms)`会运行基类的初始化函数，基类的初始化函数中的`self.ohms = ohms`的`self.ohms`会调用子类的`@ohms.setter`，所以`_ohms`在此时被创建了；
&emsp;&emsp; `r4.ohms = 2e3`调用的也是`@ohms.setter`，而此时`_ohms`已经在初始化的时候被创建了，所以报错






&emsp;
&emsp; 
# 5. 描述符(descriptor)
## 5.1 什么是描述符？描述符协议 又是什么？
&emsp;&emsp; 描述符的定义很简单，实现了下列 **任意一个或多个** 方法的 `Python`对象 就是一个描述符：
```python
__get__(self, instance, type=None)
__set__(self, instance, value)
__delete__(self, instance)
```
这些方法的参数含义如下：
> **`self`** 是当前定义的描述符对象实例。
> **`instance`** 是该描述符将作用的对象实例。
> **`type`** 是该描述符作用的对象的类型（即所属的类）。
> 
上述方法也被称为**描述符协议(descriptor protocol)**，Python 会在特定的时机按协议传入参数调用某一方法，如果我们未按协议约定的参数定义方法，调用可能会出错。
&emsp;&emsp; **本质上看，描述符就是一个类**，只不过它定义了**另一个类**中属性的访问方式。换句话说，一个类可以将属性管理全权委托给描述符类。


&emsp;
## 5.2 描述符的作用是？
&emsp;&emsp; 描述符就是一个“绑定行为“的对象属性，在描述符协议中，它可以通过方法重写属性的访问。我们或许经常看见描述符的作用描述中，有两个关键词“绑定行为”和“托管属性”，那到底是什么意思呢，这有一个通俗的解释：
> &emsp;&emsp; **绑定行为**：所谓的绑定行为，是指在属性的访问、赋值、删除时还绑定发生了其他的事情，正如前面属性控制三剑客所完成的事情一样；
> &emsp;&emsp; **托管属性**：python描述符是一种创建“托管属性”的方法，即通过描述符（类）去托管另一个类的相关属性，也可以说是类的属性的一个代理。为了方便的理解“托管属性”这个概念，将通过几个通俗的例子去说明。
> 
以人类而言，Person是一个类，人应该有很多属性，比如人是美丽的、性感的、成熟的、博学的、大方的等等，所谓的“描述”，本身指的就是描述某一个类的某一些特性的，在程序设计中，属性就是用来描述类的特征的，所谓的描述符（描述类）就是专门再创建一个类，让这个类去描述本身那个类的相关属性，这也正是“描述”二字的由来，其实和我们生活中的描述是一个意思。
&emsp;&emsp; 总而言之，描述符的作用是用来代理另外一个类的属性的。


&emsp;
## 5.3 描述符的类型
### 5.3.1 描述符有哪几种类型？
根据**所实现的协议方法不同**，描述符可分为两类：
* ① 若实现了 `__set__()` 或 `__delete__()` 任一方法，该描述符是一个**数据描述符（data descriptor）**。
* ② 若仅实现 `__get__()` 方法，该描述符是一个**非数据描述符（non-data descriptor）**。
  
### 5.3.2 这几种描述符类型有何差异？
两者的在表现行为上存在差异：
> 数据描述符 总是会覆盖实例字典 `__dict__` 中的属性。
> 而非数据描述符 会被实例字典 `__dict__` 中定义的属性所覆盖。
> 
下面写段代码来验证一下:
```python
class NonDataDescriptor:
    def __get__(self, instance, owner):
        if instance is None:
            print('NonDataDescriptor.__get__(): Accessing y from the class', owner)
            return self

        print('NonDataDescriptor.__get__(): Accessing y from the object', instance)
        return 'Y from non-data descriptor'

class Descriptor:
    def __get__(self, instance, owner):
        if instance is None:
            print('Descriptor.__get__(): Accessing x from the class', owner)
            return self
        
        print('Descriptor.__get__(): Accessing x from the object', instance)
        return 'X from descriptor'

    def __set__(self, instance, value):
        print('Descriptor.__set__(): Setting x on the object', instance)
        instance.__dict__['_x'] = value

class Bar:
    x = Descriptor()
    y = NonDataDescriptor()


bar = Bar()
print(bar.x, end = "\n\n")
print(bar.y, end = "\n\n")

# 下面通过__dict__修改
print("通过__dict__修改之后：")
bar.__dict__['x'] = "x"
bar.__dict__['y'] = "y"
print(bar.x, end = "\n\n")
print(bar.y, end = "\n\n")
```
运行结果：
```
Descriptor.__get__(): Accessing x from the object <__main__.Bar object at 0x00000236C5F7FE80>
X from descriptor

NonDataDescriptor.__get__(): Accessing y from the object <__main__.Bar object at 0x00000236C5F7FE80>
Y from non-data descriptor

通过__dict__修改之后：
Descriptor.__get__(): Accessing x from the object <__main__.Bar object at 0x00000236C5F7FE80>
X from descriptor

y
```
**结果分析：**
&emsp;&emsp; 可以看到，通过`__dict__`覆盖后，类型为数据描述符的`x`还是调用的`Descriptor.__get__()`；而类型为非数据描述符的`y`被覆盖了。


&emsp;
## 5.4 描述符的具体使用
### 5.4.1 使用实例
&emsp;&emsp; 前面提到，要实现所谓的描述符，就是要实现上面描述符协议中的三个魔术方法，但是和普通类定义的方式不一样，因为“属性代理（属性托管）”的机制，我们需要定义两个类：
> 一个 描述符类`A`，它实现描述符协议中方法；
> 一个 被描述符代理的类`B`，即所谓的描述类，它会使用前面定义的 描述符类`A`。
> 
来看一个例子，其中`Descriptor`是描述符类，`Foo`使用了描述符类：
```python
class Descriptor:
    def __get__(self, instance, owner):
        if instance is None:
            print('__get__(): Accessing x from the class', owner)
            return self
        
        print('__get__(): Accessing x from the object', instance)
        return 'X from descriptor'

    def __set__(self, instance, value):
        print('__set__(): Setting x on the object', instance)
        instance.__dict__['_x'] = value

class Foo:
    x = Descriptor()


print("通过类访问：")
print(Foo.x)    

print("\n通过实例访问：")
foo = Foo()
print(foo.x)
foo.x = 5
```
运行结果：
```
通过类访问：
__get__(): Accessing x from the class <class '__main__.Foo'>
<__main__.Descriptor object at 0x00000248C0AEE980>

通过实例访问：
__get__(): Accessing x from the object <__main__.Foo object at 0x00000248C0B92FE0>
X from descriptor
__set__(): Setting x on the object <__main__.Foo object at 0x00000248C0B92FE0>
```
**结果分析：**
&emsp;&emsp; 可以看到的是，无论是通过类本身，还是通过类实例，访问`Foo.x`都会自动调用该属性所绑定的描述符实例的 `__get__()`方法。
&emsp;&emsp; 对 实例对象`foo`的`x`进行赋值，会调用描述符的`__set__()` 方法。

### 11.4.2 注意事项
&emsp;&emsp; 我们注意到，上面的`Foo`类在使用描述符类的时候，是将`x`定义成了类属性，如果将`x`定义成实例属性会发生什么呢？我们写段代码来验证一下：
```python
class Descriptor:
    # 同上，略...

class Foo:
    def __init__(self):
        self.x = Descriptor()


foo = Foo()
print(foo.x)
foo.x = 5
```
运行结果：
```
<__main__.Descriptor object at 0x0000023607BA2F50>
```
**结果分析：**
&emsp;&emsp; 可以看到的是，描述符没有生效，只是打印了`self.x`自己的地址。

&emsp;&emsp; <span style="color:red; font-size:21px; font-weight:bold"> 需要注意的是，描述符在属性查找过程中会被`.`点操作符调用，且只有在作为类变量使用时才有效。如果直接赋值给实例属性，描述符不会生效。 </span>
另外，使用`__dict__`属性访问描述符也不会调用 描述符的协议方法，而是返回描述符实例本身：
```python
class Descriptor:
    # 同上，略...

class Foo:
    x = Descriptor()

print(Foo.__dict__['x'])
```
运行结果：
```
<__main__.Descriptor object at 0x0000023607BA2F50>
```


&emsp;
## 5.5 描述其的运行原理
### 5.5.1 实例讲解
现有描述符`Grade`和 使用描述符的`Exam`类：
```python
class Grade:
    def __get__(self, instance, instance_type):
        ...
        
    def __set__(self, instance, value):
        ...

class Exam:
    # Class attributes
    math_grade = Grade()
    writing_grade = Grade()
    science_grade = Grade()        
```
我们需要给`Exam`实例的`writing_grade`属性赋值
```python
exam = Exam()
exam.writing_grade = 40
```
那么解释器会把这次赋值操作转译为：
```python
Exam.__dict__['writing_grade'].__set__(exam,
```
获取这个属性也一样：
```python
exam.writing_grade
```
将被翻译成：
```python
Exam.__dict__['writing_grade'].__get__(exam, Exam)
```
上面的转译效果是由`object`类的` __getattribute__()`方法完成的，简单的说，就是当 `Exam`实例 中没有名为`writing_grade`的属性时，Python会转而在类的层面查找，如果类的层面有，而且还是个实现了`__get__()` 和  `__set__()` 的对象，那么系统就会认为你想通过描述符协议定义的这个属性的访问行为。


&emsp;
## 5.6 描述符的应用
### 5.6.1 Python 内部的描述符
&emsp;&emsp; 除了一些自定义的场景，Python 本身的语言机制中就大量使用了描述符：
> ① `@property`属性
> ② 类方法`@classmethod`
> ③ 静态方法`@staticmethod`
> 

### 5.6.2 自定义描述符
#### (1) 概述
描述符的本质在于“描述”二字，最大的用处是对属性的个性定制与控制，如前所说，
&emsp;&emsp; (1）可以在设置属性时，做些检测等方面的处理   
&emsp;&emsp; (2）设置属性不能被删除？那定义_delete_方法，并raise 异常。 
&emsp;&emsp; (3）还可以设置只读属性 
&emsp;&emsp; (4）把一个描述符作为某个对象的属性。这个属性要更改，比如增加判断，或变得更复杂的时候，所有的处理只要在描述符中操作就行了。 
这一系列其实都是为了更好地去控制一个属性。
#### (2) 实现可复用的`@property`属性
&emsp;&emsp; 详见 [Effective Python Item 46](../Effective%20Python.md)的相关笔记。


&emsp;
## 5.7 总结
&emsp;&emsp; 其他类在使用描述符的时候，必须将描述符实例定义成类属性，不能定义成实例属性：
```python
class Descriptor:
    # 同上，略...

class Foo:
    x = Descriptor() # 正确
    def __init__(self):
        self.y = Descriptor() # 错误
```

&emsp;
## 5.8 参考文献
1. [面向对象（深入）|python描述器详解](https://zhuanlan.zhihu.com/p/32764345)






&emsp;
&emsp; 
# 6. 运算符重载(Operator Overloading)
## 6.1 Python的运算符重载有何限制吗？
&emsp;&emsp; 在某些圈子中，运算符重载的名声并不好。这个语言特性可能（已经）被滥用，让程序员困惑，导致缺陷和意料之外的性能瓶颈。但是，如果使用得当，API 会变得好用，代码会变得易于阅读。Python 施加了一些限制，做好了灵活性、可用性和安全性方面的平衡：
> ①   We cannot overload operators for the built-in types.
> &emsp;&emsp; 不能为内置类型重载运算符；
> ②  We cannot create new operators, only overload existing ones.
> &emsp;&emsp; 不能新建运算符，只能重载现有的运算符；
> ③  A few operators can’t be overloaded: is, and, or, not (but the bitwise &, |, ~, can).
> &emsp;&emsp; `is`, `and`, `or`和 `not`运算符不能被重载，但位运算符 `&`、`|` 和 `~` 可以被重载。
>


&emsp;
## 6.2 各个运算符对应的方法列表
| 运算符 | 作用 | 对应的魔术方法 | 魔术方法的英文全称 | 实现时需要注意的点 |
| ------ | ---- | -------------- | ------------------ | ------------------ |
|        |      |                |                    |                    |


&emsp;
## 6.3 一元运算符(Unary Operators)
### 6.3.1 有哪些一元运算符？它们对应的魔术方法是？
| 运算符  | 作用           | 对应的魔术方法 | 魔术方法的英文全称 | 实现时需要注意的点 |
| ------- | -------------- | -------------- | ------------------ | ------------------ |
| `-`     | 一元取负       | `__neg__`      | negative           |                    |
| `+`     | 一元取正       | `__pos__`      | positive           |                    |
| `~`     | 对整数按位取反 | `__invert__`   | invert             |                    |
| `abs()` | 取绝对值       | `__abs__`      | absolute value     |                    |

### 6.3.2 实现一元运算符需要注意算么？
支持一元运算符很简单， 只需实现相应的特殊方法：
> ① 一元运算符中，其对应的特殊方法只有一个参数`self`，然后，使用符合所在类的逻辑实现；
> ② 遵守一个基本规则： 始终返回一个新对
> 

### 6.3.3 示例
我们给之前定义的`Vector`类实现
```python
class Vector():
    def __abs__(self):
        return math.sqrt(sum(x * x for x in self))
        
    def __neg__(self):
        # 为了计算 -v， 构建一个新 Vector 实例， 把 self 的每个分量都取反。
        return Vector(-x for x in self) 

    def __pos__(self):
        # 为了计算 +v， 构建一个新 Vector 实例， 传入 self 的各个分量
        return Vector(self) 
```
### 6.3.4 `x` 和 `+x` 何时不相等
&emsp;&emsp; 每个人都觉得 `x == +x`， 而且在 Python 中， 几乎所有情况下都是这样。 但是， 我在标准库中找到两例`x != +x` 的情况。
**情况一：`decimal`模块**
&emsp;&emsp; 如果 `x` 是 `Decimal` 实例， 它在算术运算的上下文中创建， 然后在不同的上下文中计算 `+x`， 那么 `x != +x`，看例子：
```python
import decimal

ctx = decimal.getcontext() # ➊
ctx.prec = 40 # ➋ 

one_third = decimal.Decimal('1') / decimal.Decimal('3') # ➌
print(f"one_third : {one_third}\n") # ➍

print(f"one_third == +one_third : {one_third == +one_third}\n") # ➎

ctx.prec = 28 # ➏
print(f"one_third == +one_third : {one_third == +one_third}\n") # ➐

print(f"+one_third : {+one_third}" )
```
运行结果：
```
one_third : 0.3333333333333333333333333333333333333333

one_third == +one_third : True

one_third == +one_third : False

+one_third : 0.3333333333333333333333333333
```
**情况二：`collections.Counter`**
&emsp;&emsp; `Counter` 类实现了几个算术运算符， 例如中缀运算符 `+`， 作用是把两个 `Counter` 实例的计数器加在一起。 然而， 从实用角度出发， `Counter` 相加时， 负值和零值计数会从结果中剔除。 而一元运算符 + 等同于加上一个空 `Counter`， 因此它产生一个新的 `Counter` 且仅保留大于零的计数器,。
```python
from collections import Counter

ct = Counter('abracadabra')
print(f"ct : {ct}")

ct['r'] = -3
ct['d'] = 0
print(f"ct : {ct}")

print(f"-ct : {+ct}")
```
运行结果：
```
ct : Counter({'a': 5, 'b': 2, 'r': 2, 'c': 1, 'd': 1})
ct : Counter({'a': 5, 'b': 2, 'c': 1, 'd': 0, 'r': -3})
-ct : Counter({'a': 5, 'b': 2, 'c': 1})
```


&emsp;
## 6.4 `+`运算符
### 6.4.1 解释器如何解析`+`运算符？
&emsp;&emsp; 为了支持涉及不同类型的运算， Python 为中缀运算符特殊方法提供了特殊的分派机制。 对表达式 `a + b` 来说， 解释器会执行以下几步操作：
> &emsp;&emsp; (1) 如果 `a` 有 `__add__` 方法，而且返回值不是 `NotImplemented`，调用 `a.__add__(b)`， 然后返回结果。
> &emsp;&emsp; (2) 如果 `a` 没有 `__add__` 方法，或者调用 `__add__` 方法返回 `NotImplemented`，检查 `b` 有没有 `__radd__`方法，如果有，而且没有返回 `NotImplemented`，调用 `b.__radd__(a)`，然后返回结果。
> &emsp;&emsp; (3) 如果 `b` 没有 `__radd__` 方法，或者调用 `__radd__` 方法返回 `NotImplemented`， 抛出 `TypeError`，并在错误消息中指明操作数类型不支持。
> 
<div align="center"> <img src="./pic/Flowchart for computing a + b.png"> </div>

### 6.4.2 重载向量加法运算符`+`(Overloading `+` for Vector Addition)
```python
class Vector():
    # 略...

    def __add__(self, other):
    try:
        pairs = itertools.zip_longest(self, other, fillvalue=0.0)
        return Vector(a + b for a, b in pairs)
    except TypeError:
        return NotImplemented

    def __radd__(self, other):
        return self + other    
```


&emsp;
## 6.5 乘法运算符`*`
### 6.5.1 
```python
class Vector:
    typecode = 'd'
    def __init__(self, components):
        self._components = array(self.typecode, components)

    # 排版需要， 省略了很多方法
    # 参见https://github.com/fluentpython/example-code中的vector_v7.py

    def __mul__(self, scalar):
        if isinstance(scalar, numbers.Real): # ➋ 如果 scalar 是 numbers.Real 某个子类的实例
            # ➌ 用分量的乘积创建一个新 Vector 实例
            return Vector(n * scalar for n in self)
        else: 
            return NotImplemented

    def __rmul__(self, scalar):
        return self * scalar # ➍ __rmul__ 方法只需执行 self * scalar， 委托给 __mul__ 方法
```


&emsp;
## 6.6 比较运算符(Comparison Operators)
&emsp; Python 解释器对众多比较运算符（`==`、 `!=`、 `>`、 `<`、 `>=`、 `<=`） 的处理与前文类似， 不过在两个方面有重大区别。
> &emsp;&emsp; 正向和反向调用使用的是同一系列方法，这方面的规则见下表。 例如， 对 `==` 来说， 正向和反向调用都是 `__eq__` 方法， 只是把参数对调了； 而正向的 `__gt__` 方法调用的是反向的 `__lt__` 方法，并把参数对调。
> &emsp;&emsp; 对 `==` 和 `!=` 来说，如果反向调用失败，Python会比较对象的`ID`，而不抛出`TypeError`
> 
对于下面的比较运算符，若正向方法返回`NotImplemented`，则调用反向方法：
| 分组   | 中缀运算符 | 正向方法调用  | 反向方法调用  | 后备机制              | 对应的英文    |
| ------ | ---------- | ------------- | ------------- | --------------------- | ------------- |
| 相等性 | `a == b`   | `a.__eq__(b)` | `b.__eq__(a)` | 返回 `id(a) == id(b)` | equal         |
|        | `a != b`   | `a.__ne__(b)` | `b.__ne__(a)` | 返回 `not (a == b)`   | not equal     |
| 排序   | `a > b`    | `a.__gt__(b)` | `b.__lt__(a)` | 抛出 `TypeError`      | greater than  |
|        | `a < b`    | `a.__lt__(b)` | `b.__gt__(a)` | 抛出 `TypeError`      | less than     |
|        | `a >= b`   | `a.__ge__(b)` | `b.__le__(a)` | 抛出 `TypeError`      | greater euqal |
|        | `a <= b`   | `a.__le__(b)` | `b.__ge__(a)` | 抛出 `TypeError`      | less euqal    |


&emsp;
## 6.7 增量运算符(Augmented Assignment Operators)
### 6.7.1 如何实现 增量运算符？
&emsp;&emsp; 实现对应的就地运算符(in-place operator)即可，如加法就是`__iadd__`(其实就是前面多了个`i`)。

### 6.7.2 为 不可变类型 实现 增量运算符 时，需要注意什么？
&emsp;&emsp;需要在意的是，不可变类型，一定不能实现就地特殊方法。 

### 6.7.3 如何对没有实现增量运算符的类调用 增量运算符，会发生什么？
&emsp;&emsp; 如果一个类没有实现对应的就地运算符， 增量赋值运算符只是语法糖： `a += b` 的作用与 `a = a + b` 完全一样。 对不可变类型来说， 这是预期的行为， 而且， 如果定义了 `__add__` 方法的话， 不用编写额外的代码，`+=`就能使用。
&emsp;&emsp; 然而， 如果实现了就地运算符方法， 例如 `__iadd__`， 计算 `a += b` 的结果时会调用就地运算符方法。 这种运算符的名称表明， 它们会就地修改左操作数， 而不会创建新对象作为结果。

&emsp;
## 6.8 其它中缀运算符
&emsp;&emsp;**就地运算符(in-place operator)** 对应得是 增量运算符。 
| 运算符     | 正向方法       | 反向方法        | 就地方法              | 说明                           | 对应的英文            |
| ---------- | -------------- | --------------- | --------------------- | ------------------------------ | --------------------- |
| `+`        | `__add__`      | `__radd__`      | `__iadd__`            | 加法或拼接                     | Addition              |
| `-`        | `__sub__`      | `__rsub__`      | `__isub__`            | 减法                           | Subtraction           |
| `*`        | `__mul__`      | `__rmul__`      | `__imul__`            | 乘法或重复复制                 | Multiplication        |
| `/`        | `__truediv__`  | `__rtruediv__`  | `__itruediv__`        | 除法                           | True division         |
| `//`       | `__floordiv__` | `__rfloordiv__` | `__ifloordiv__`       | 整除                           | Floor division        |
| `%`        | `__mod__`      | `__rmod__`      | `__imod__`            | 取模                           | Modulo                |
| `divmod()` | `__divmod__`   | `__rdivmod__`   | `__idivmod__`         | 返回由整除的商和模数组成的元组 |                       |
| `**`       | `pow()`        | `__pow__`       | `__rpow__` `__ipow__` | 取幂`*`                        | power                 |
| `@`        | `__matmul__`   | `__rmatmul__`   | `__imatmul__`         | 矩阵乘法`#`                    | Matrix multiplication |
| `&`        | `__and__`      | `__rand__`      | `__iand__`            | 位与                           | Bitwise and           |
| `          | `              | `__or__`        | `__ror__``__ior__`    | 位或                           | Bitwise or            |
| `^`        | `__xor__`      | `__rxor__`      | `__ixor__`            | 位异或                         | Bitwise xor           |
| `<<`       | `__lshift__`   | `__rlshift__`   | `__ilshift__`         | 按位左移                       | Bitwise shift left    |
| `>>`       | `__rshift__`   | `__rrshift__`   | `__irshift__`         | 按位右移                       | Bitwise shift right   |


## 6.9 运算符可以修改操作数吗？
&emsp;&emsp; 实现一元运算符和中缀运算符的特殊方法一定不能修改操作数，使用这些运算符的表达式期待结果是新对象。只有增量赋值表达式可能会修改第一个操作数（`self`） 。


