- [](#)
- [2. `del obj`会销毁`obj`对象吗？](#2-del-obj会销毁obj对象吗)






&emsp;
&emsp;
&emsp;
# 1. 引用计数(Reference Counting)
## 1.1 python对象的引用计数是怎么保存的？
&emsp;&emsp; Python中，主要通过引用计数（Reference Counting）进行垃圾回收。在Python中，每一个对象的核心就是一个结构体`PyObject`：
```c
typedef struct_object {
    int ob_refcnt; // 引用计数器
    struct_typeobject *ob_type;
} PyObject;
```
其中结构体成员`ob_refcnt`是引用计数器，用来记录 有对少个变量指向“自己”。程序在运行的过程中会实时的更新`ob_refcnt`的值。当某对象的引用计数值为`0`,那么它的内存就会被立即释放掉。

## 1.2 如何获取一个对象的 引用计数 数值？
可以通过`sys.getrefcount()`来获取：
```python
import sys

l = [1, 2, 3]
print(sys.getrefcount(l))

l2 = l
print(sys.getrefcount(l))
```
运行结果：
```
2
3
```

## 1.3 为什么对 可变类型 通过`sys.getrefcount()`来获取引用计数时，得到的数字会比预期多`1`？
对于`a = [1, 2, 3]`，解释器做了如下工作：
> ① 新建一个临时变量`tmp`，然后把`[1, 2, 3]`赋给`tmp`，即`tmp = [1, 2, 3]`(此时，引用计数为`1`)；
> ② 将`tmp`赋给`a`，即`a = tmp`(此时，引用计数为`12`)；
> 
我们可以用代码来验证一下：
```python
import sys

# 
print(sys.getrefcount([1, 2, 3]))

a = [1, 2, 3]
print(sys.getrefcount(a))
```
运行结果：
```
1
2
```

## 1.4 对 不可变类型 调用`sys.getrefcount()`，得到的值 会是怎样的？为什么？
```python
import sys

a = 2
print(sys.getrefcount(a))
```
运行结果：
```
75
```
对 不可变类型 调用`sys.getrefcount()`，得到的值可能和想象中的不一样。原因如下：
> &emsp;&emsp; 因为`2`是不可变对象，python解释器为了节省内存，只会在内存中保留一份，所有要用到`2`这个数字的对象都会指向这一个备份，这就导致输出结果为`75`，而不是预期的`2`。
> 

## 1.5 引用计数存在的问题
### 1.5.1 引用计数 有什么缺点？

### 1.5.2 Python是如何解决这个缺点的？
循环引用
https://zhuanlan.zhihu.com/p/83251959






&emsp;
&emsp;
&emsp;
# 2. `del obj`会销毁`obj`对象吗？
&emsp;&emsp; 不一定，`del obj` 会导致指向`obj`对象的引用计数减一，如果，此时恰好引用计数为`0`了，那么`obj`对象就会被销毁，反之则不会。







&emsp;
&emsp;
&emsp;
# 3. 


