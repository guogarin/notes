- [1. 什么是装饰器(Decorator)？](#1-什么是装饰器decorator)
- [2. 为什么要用装饰器？](#2-为什么要用装饰器)
  - [2.1 装饰器的作用](#21-装饰器的作用)
- [2.2 装饰器的应用](#22-装饰器的应用)
- [3. 装饰器的原理是？](#3-装饰器的原理是)
  - [3.1 装饰器的技术支撑](#31-装饰器的技术支撑)
  - [3.2 装饰器原理](#32-装饰器原理)
  - [总结](#总结)
  - [4. 如何使用装饰器？](#4-如何使用装饰器)
    - [4.1 需要的工具](#41-需要的工具)
    - [4.2 实例说明：利用装饰器 在函数执行完之后 在继续执行一些需要的代码](#42-实例说明利用装饰器-在函数执行完之后-在继续执行一些需要的代码)
    - [4.3 使用`@`调用装饰器的原理是什么？](#43-使用调用装饰器的原理是什么)
- [5. 对于解释器来说，下面的代码的效果等同于什么？](#5-对于解释器来说下面的代码的效果等同于什么)
- [6. 装饰器的运行](#6-装饰器的运行)
  - [6.1 解释器在何时执行装饰器？](#61-解释器在何时执行装饰器)
  - [6.2 为什么会出现这种情况？](#62-为什么会出现这种情况)
- [7. 装饰器的参数](#7-装饰器的参数)
  - [7.1 `*args` 和 `**kargs` 是什么？](#71-args-和-kargs-是什么)
  - [7.2 一定要用`*args` 和 `**kargs`，直接写需要的参数名不行吗？](#72-一定要用args-和-kargs直接写需要的参数名不行吗)
    - [7.2.1 只修改`decorator_name装饰器`的形参形式](#721-只修改decorator_name装饰器的形参形式)
    - [7.2.2 修改`decorator_name装饰器`的形参形式，test()函数改为接收三个参数](#722-修改decorator_name装饰器的形参形式test函数改为接收三个参数)
  - [7.3 如何编写带参数的装饰器？如何调用？](#73-如何编写带参数的装饰器如何调用)



&emsp;
&emsp; 
# 1. 什么是装饰器(Decorator)？
&emsp;&emsp; 装饰器是可调用的对象，其参数是另一个函数（被装饰的函数）。装饰器可能会处理被装饰的函数，然后把它返回，或者将其替换成另一个函数或可调用对象。
**注意：** 传给装饰器的参数是函数。




&emsp;
&emsp;
# 2. 为什么要用装饰器？
## 2.1 装饰器的作用
&emsp;&emsp; 装饰器可以让程序在 **执行这个函数之前** 和 **执行完这个之后** 分别运行某些代码。

# 2.2 装饰器的应用
(1) 授权(Authorization)
&emsp;&emsp; 装饰器能有助于检查某个人是否被授权去使用一个web应用的端点(endpoint)。它们被大量使用于
Flask和Django web框架中。
(2) 日志(Logging)
&emsp;&emsp; 可以通过装饰器记日志，而且还能节省代码量。





&emsp;
&emsp;
# 3. 装饰器的原理是？
## 3.1 装饰器的技术支撑
&emsp;&emsp; 装饰器之所以能存在，是因为**python的函数是一等对象(first-class object)**，这让Python的函数有了如下特点：
> ① Created at runtime(在运行时创建)
> ② Assigned to a variable or element in a data structure(能赋值给变量或数据结构中的元素)
> ③ Passed as an argument to a function(能作为参数传给函数)
> ④ Returned as the result of a function(能作为函数的返回结果)
> 
这给装饰器的存在提供了技术支撑。

## 3.2 装饰器原理
&emsp;&emsp; 装饰器的原理是基于 `python的函数可以像变量一样传递`。本质上来说，装饰器其实就是 **从函数中返回函数**：我们将 函数A 作为参数传递给 函数B，函数B将函数A`装饰`后再将函数A作为参数返回，这里的装饰可以是 在调用函数A之前做点什么，也可以在调用函数A之后做点什么。我们来看一个例子：
```python
from functools import wraps # 
def decorator_name(f):
    def decoratored(*args, **kwargs):
        if not can_run:
            return "Function will not run"
        else:
            return f(*args, **kwargs)
    
    return decoratored
```
`decorator_name函数`就是一个装饰器，它先判断 `can_run`是否为`True`，是的话就返回`函数f`，不是的话就返回`"Function will not run"`。
**这个装饰器的作用其实就是**：在调用`函数f`**之前**，先判断`can_run`是否为`True`。
**我们现在来分析一下上面的装饰器：**
> **形参f**：`f`的类型是 函数
> **`decoratored函数`** ：它定义在`decorator_name函数`里面，它先判断`can_run`是否为`True`，是的话就返回`函数f`，不是的话就返回`"Function will not run"`，
> **返回值**：该装饰器的返回值是`decoratored函数`，而`decoratored函数`的作用是就是装饰参数f，所以 `decorator_name函数`的作用就是装饰它的 参数f
> 

## 总结
&emsp;&emsp; 装饰器其实就是一个嵌套函数，外层函数将 待装饰的函数`target()` 包裹起来，然后在返回 待装饰的函数`target()` 之前(或之后) 加点代码变成`wrapped()`，然后再返回 被装饰的函数`wrapped()`。




&emsp;
&emsp;
## 4. 如何使用装饰器？
### 4.1 需要的工具
需要的包：`from functools import wraps`
调用：使用`@`，我们来调用一下前面定义的`decoratored装饰器`：

### 4.2 实例说明：利用装饰器 在函数执行完之后 在继续执行一些需要的代码
下面的代码
```python
from functools import wraps

def log_before_called(func):
    @wraps(func)
    def wrappper(*args, **kwargs):
        print(f"{func.__name__} called.")
        return func(*args, **kwargs)

    return wrappper

@log_before_called
def add(x, y):
    return x + y

res = add(1, 3)
print("*"*20)
print(res)
```
运行结果：
```
add called.
********************
4
```
**结果分析：**
&emsp;&emsp; 

### 4.3 使用`@`调用装饰器的原理是什么？
就上面上面的装饰器`log_before_called`来举例吧，我们可以将
```python
@log_before_called
def add(x, y):
    return x + y
```
理解成：
```python
add = log_before_called(add)
```
而这一切都是由`functools.wraps`在后台帮我们完成的。








&emsp;
&emsp;
# 5. 对于解释器来说，下面的代码的效果等同于什么？
```python
@decorate
def target():
    print('running target()')
```
对于解释器来说，上面的代码等同于：
```python
def target():
    print('running target()')

target = decorate(target) # 注意参数和左边的变量名都是 target
```






&emsp;
&emsp;
# 6. 装饰器的运行
## 6.1 解释器在何时执行装饰器？
&emsp;&emsp; 装饰器的一个关键特性是，它们在 **被装饰的函数** 定义之后 **立即运行**。这通常是在导入时（即Python加载模块时），来看下面的例子：
```python
def register(func): 
    print(f'running register: ({func})' ) 
    return func         

@register 
def f1():
    print('running f1()')

@register
def f2():
    print('running f2()')
```
运行结果：
```
running register: (<function f1 at 0x0000027748A3E5F0>)
running register: (<function f2 at 0x0000027748A3E710>)
```
**结果分析：**
&emsp;&emsp; 我们没有在任何地方调用`f1()`、`f2()`或`register()`，但日志却显示`register()`分别被`f1()`、`f2()`调用，这也印证了前面说的 装饰器会在 **被装饰的函数** 定义之后 **立即运行**

## 6.2 为什么会出现这种情况？
前面已经提到，对于下面这段代码：
```python
@decorate
def target():
    print('running target()')
```
解释器在后台会解释为：
```python
def target():
    print('running target()')

target = decorate(target) # 注意参数和左边的变量名都是 target
```
因此我们将7.1小节的代码示例修改成：
```python
def register(func): 
    print(f'running register: ({func})' ) 
    return func         

#@register 
def f1():
    print('running f1()')

#@register
def f2():
    print('running f2()')

# 用@符号其实是把下面的这个工作交给了解释器：
f1 = register(f1)
f2 = register(f2)
```
运行结果：
```
running register: (<function f1 at 0x0000023F5BA4E5F0>)
running register: (<function f2 at 0x0000023F5BA4E710>)
```
可以看到的是，运行结果和修改前一样。






&emsp;
&emsp;
# 7. 装饰器的参数
## 7.1 `*args` 和 `**kargs` 是什么？
&emsp; 为了传可变参数个数，我们来看下面的代码：
```python
from functools import wraps

def decorator_name(func):
    @wraps(func)
    def decoratored_func(*args, **kargs):
        print(*args)
        print(kargs)
        return func(*args, **kargs)
    return decoratored_func

@decorator_name
def test(name, age):
    print("My name is %s, I am %d years old."%(name, age))


if __name__ == "__main__":
    test("Jack", 23)
```
输出：
```
Jack 23
{}
My name is Jack, I am 23 years old.
```

## 7.2 一定要用`*args` 和 `**kargs`，直接写需要的参数名不行吗？
&emsp; &emsp; 可以直接写需要的参数名，但这样就把参数的个数限定死了，在装饰器中使用`*args` 和 `**kwargs` 主要是为了兼容，因为 每个调用装饰器的函数 的形参个数都不一样，这样写兼容性高：
### 7.2.1 只修改`decorator_name装饰器`的形参形式

```python
def decorator_name(func):
    @wraps(func)
    def decoratored_func(arg1, arg2): # 这里没有使用*args和**kargs，而是将参数设为两个
        print(arg1)
        print(arg2)
        return func(arg1, arg2)
    return decoratored_func

@decorator_name
def test(name, age):
    print("My name is %s, I am %d years old."%(name, age))

if __name__ == "__main__":
    test("Jack", 23)
```
输出：
> Jack
> 23
> My name is Jack, I am 23 years old.
> 
**结论：代码正常运行，说明确实可以将装饰器的参数个数写成确定的个数。**

### 7.2.2 修改`decorator_name装饰器`的形参形式，test()函数改为接收三个参数
我们把上面的代码改一下：`decorator_name装饰器`直接把参数设为两个，test函数改为接收三个参数
```python
from functools import wraps

def decorator_name(func):
    @wraps(func)
    def decoratored_func(arg1, arg2):# 这里没有使用*args和**kargs，而是将参数设为两个
        print(arg1)
        print(arg2)
        return func(arg1, arg2)
    return decoratored_func

@decorator_name
def test(name, age, sex): # test函数接收三个参数
    print("My name is %s, I am %d years old."%(name, age))

if __name__ == "__main__": # 传三个参数给test函数
    test("Jack", 23, '男')
```
输出：
>Traceback (most recent call last):
>&emsp;  File "d:/code_practice/test.py", line 17, in <module>
>&emsp;&emsp;    test("Jack", 23, '男')
>TypeError: decoratored_func() takes 2 positional arguments but 3 were given
>
**代码报错，将装饰器的参数个数写成确定的个数会影响兼容性，因为你很难确定调用装饰器的函数接收几个参数，因此将装饰器的形成设为`*args` 和 `**kargs`会比较合理，不管调用装饰器的函数接收几个参数都不会报错。**

## 7.3 如何编写带参数的装饰器？如何调用？
&emsp;&emsp; 我们在调用装饰器的时候虽然没有显示的传参进去，但是其实这里我们隐式的传了一个参数进去：调用该装饰器的函数。
我们来看一个 用来记录日志的 装饰器`logit`：
```python
from functools import wraps
# 注意看，里面嵌套了 三层 ！三层！三层！
def logit(logfile='out.log'):
    def logging_decorator(func):
        @wraps(func)
        def wrapped_function(*args, **kwargs):
            log_string = func.__name__ + " was called"
            print(log_string)
            # 打开logfile，并写入内容
            with open(logfile, 'a') as opened_file:
                # 现在将日志打到指定的logfile
                opened_file.write(log_string + '\n')
            return func(*args, **kwargs)
        return wrapped_function
    return logging_decorator
```
我们可以看到 装饰器`logit` 接收一个参数`logfile`，这个参数有默认实参'out.log'，我们来调用一下：
```python
@logit() # 没有传 logfile进去，使用的是 默认实参 out.log
def myfunc1():
    pass
 
myfunc1()
# Output: myfunc1 was called
# 现在一个叫做 out.log 的文件出现了，里面的内容就是上面的字符串
 

@logit(logfile='func2.log') # 这里传了 func2.log 进去
def myfunc2():
    pass
 
myfunc2()
# Output: myfunc2 was called
# 现在一个叫做 func2.log 的文件出现了，里面的内容就是上面的字符串
```

| Column A                      | Column B                                         |
| ----------------------------- | ------------------------------------------------ |
| `@logit`                      | 只有一个参数：调用`logit装饰器`的函数            |
| `@logit(logfile='func2.log')` | 两个参数：① 调用`logit装饰器`的函数；② `logfile` |



