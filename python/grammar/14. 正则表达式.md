- [1. 正则表达式字符](#1-正则表达式字符)
	- [1.1 正则表达式字母表](#11-正则表达式字母表)
	- [1.2 如何转义正则字符？](#12-如何转义正则字符)
	- [1.3 `^`和`\b`的区别](#13-和b的区别)
	- [1.4 分组](#14-分组)
		- [为什么要分组？](#为什么要分组)
- [2. python的正则表达式：`re`库](#2-python的正则表达式re库)
	- [2.1 re模块提供的常量](#21-re模块提供的常量)
	- [2.2 re库提供的函数](#22-re库提供的函数)
		- [2.2.1 查找一个匹配项的函数](#221-查找一个匹配项的函数)
		- [2.2.2 查找多个匹配项](#222-查找多个匹配项)
		- [2.2.3 分割](#223-分割)
		- [2.2.4 替换](#224-替换)
		- [2.2.5 编译正则](#225-编译正则)
		- [2.2.6 其它](#226-其它)
	- [2.3 `re`库中的对象](#23-re库中的对象)
		- [2.3.1 正则对象](#231-正则对象)
		- [2.3.2 匹配对象](#232-匹配对象)
	- [Python正则表达式前加上`r`的含义与作用](#python正则表达式前加上r的含义与作用)
- [3. 练习](#3-练习)
	- [3.1](#31)



&emsp;
&emsp;
# 1. 正则表达式字符
## 1.1 正则表达式字母表
以下来自[python核心编程]()：
<div align="center"> <img src="./pic/re/re_1.png"> </div>
<div align="center"> <img src="./pic/re/re_2.png"> </div>

## 1.2 如何转义正则字符？
&emsp;&emsp; 在特殊字符前面加反斜杠`\`转义即可

## 1.3 `^`和`\b`的区别
它俩的区别如下：
| 字符 | 作用                                                             |
| ---- | ---------------------------------------------------------------- |
| `^`  | `^`的意思是以其后的字符为开始，如`^abc`匹配的是 以`abc`开始的字符 |
| `\b` | `\b`的意思是目标字符的前、后为空格或者标点                       |
例如：
> 对于正则表达式`^abc`和`\babc`，现有3个字符串`abcd`、`James abc`和`James,abc`，匹配结果如下： 
> &emsp;&emsp; ① `^abc`仅匹配`abcd`；
> &emsp;&emsp; ② `\babc`3个字符串都匹配：`abcd`、`James abc`和`James,abc`
> &emsp;&emsp; ③ `habc`两者都不匹配；
> 
代码验证：
```python
import re

print("匹配 abcd：")
print(re.search(r'^abc', 'abcd'))
print(re.search(r'\babc', 'abcd'))


print("\n\n匹配 hello, abc：")
print(re.search(r'^abc',  'hello, abc'))
print(re.search(r'\babc', 'hello, abc'))


print("\n\n匹配 habc：")
print(re.search(r'^abc',  'habc'))
print(re.search(r'\babc', 'habc'))
```
运行结果：
```
匹配 abcd：
<re.Match object; span=(0, 3), match='abc'>
<re.Match object; span=(0, 3), match='abc'>


匹配 hello, abc：
None
<re.Match object; span=(7, 10), match='abc'>


匹配 habc：
None
None
```
**结果分析：**
可以看到的是：
> ① `r'^abc'`和`r'\babc'`都匹配`'abcd'`；
> ② `r'^abc'`不匹配`'hello, abc'`，因为`'hello, abc'`不以`abc`开头；而`r'\babc'`匹配了`'hello, abc'`，因为`'hello, abc'`的`abc`前面有一个空格；
> ③ `habc`两个都不匹配，因为`habc`既不是以`abc`开头，在`abc`前面也没有空格或标点符号。
> 

## 1.4 分组
### 为什么要分组？



&emsp;
&emsp;
# 2. python的正则表达式：`re`库
## 2.1 re模块提供的常量
| 修饰符                  | 描述                                                                                        |
| ----------------------- | ------------------------------------------------------------------------------------------- |
| `re.I 或 re.IGNORECASE` | 使匹配对大小写不敏感                                                                        |
| `re.L 或 re.LOCALE`     | 做本地化识别（locale-aware）匹配                                                            |
| `re.M 或 re.MULTILINE`  | 多行匹配，影响 `^` 和 `$`                                                                   |
| `re.S 或 re.DOTALL`     | 使 `.` 匹配包括换行在内的所有字符                                                           |
| `re.U 或  re.UNICODE`   | 此标识在py3中是冗余的，因为默认字符串已经是Unicode了，保留它只是为了保持向后兼容，          |
| `re.X 或 re.VERBOSE`    | 让 `.`字符匹配任何字符，包括换行符；如果没有这个标记，`.` 就匹配 除了换行符的其他任意字符。 |
| `re.DEBUG`              | 显示编译时的debug信息                                                                       |

## 2.2 re库提供的函数
&emsp;&emsp; `re`库提供了多个函数，我们可以将他们分成如下几类：
### 2.2.1 查找一个匹配项的函数
```python
# re.search 扫描整个字符串并返回第一个成功的匹配
search(pattern, string, flags=0)

# re.match 尝试从字符串的起始位置匹配一个模式，如果不是起始位置匹配成功的话，match()就返回none。
match(pattern, string, flags=0)

# re.fullmatch 如果整个 string 匹配到pattern，就返回一个相应的 匹配对象 。 否则就返回一个 None 
fullmatch(pattern, string, flags=0)
```
形参说明：
> `pattern` : 匹配的正则表达式
> `string`  : 要匹配的字符串。
> `flags`   : 标志位，用于控制正则表达式的匹配方式，就是上面我们讲解的常量。
> 

### 2.2.2 查找多个匹配项
```python
# 在字符串中找到正则表达式所匹配的所有子串:
#    ① 如果有多个匹配模式，则返回元组列表；
#    ② 如果没有找到匹配的，则返回空列表。
findall(pattern, string, flags=0)

# 作用和findall()一样，只不过finditer()返回的是一个迭代器。
finditer(pattern, string, flags=0)
```
使用实例：
```python
import re


pat = re.compile(r'\d+')

print("findall():")
result_1 = re.findall(pat, "110是报警电话，120是急救电话，119是消防")
print(result_1, end="\n"*3)


print("finditer():")
result_2 = re.finditer(pat, "110是报警电话，120是急救电话，119是消防")
print(result_2)
for itr in result_2:
    print(itr)
    print(itr.group()) # 注意，迭代器里面每一个都是一个match对象，要调用group()方法获取匹配到的字符。
```
运行结果：
```
findall():
['110', '120', '119']


finditer():
<callable_iterator object at 0x0000023C2241E980>
<re.Match object; span=(0, 3), match='110'>
110
<re.Match object; span=(9, 12), match='120'>
120
<re.Match object; span=(18, 21), match='119'>
119
```

### 2.2.3 分割
```python
# 用 pattern 分开 string ， maxsplit表示最多进行分割次数
split(pattern, string, maxsplit=0, flags=0)
```
形参说明：
> `maxsplit` : 分割次数，`maxsplit=1`表示分割一次，默认为`0`，不限制次数。
> 其它同上。
> 

### 2.2.4 替换
```python
sub(pattern, repl, string, count=0, flags=0)

# 行为与 sub()相同，但是返回一个元组 (字符串, 替换次数).
subn(pattern, repl, string, count=0, flags=0)
```
形参说明：
> `repl` : 替换的字符串，也可为一个函数。
> `count` : 模式匹配后替换的最大次数，默认 `0` 表示替换所有的匹配。
> 其它同上。
> 
TODO:如果 repl 是一个函数，那它...

### 2.2.5 编译正则
```python
# compile 函数用于编译正则表达式，生成一个正则表达式（ Pattern ）对象，供 match() 和 search() 这两个函数使用。
compile(pattern, flags=0)
```

### 2.2.6 其它
```python
# 转义 pattern 中的特殊字符。如果你想对任意可能包含正则表达式元字符的文本字符串进行匹配，它就是有用的。
escape(pattern)

# 清除正则表达式的缓存。
# purge  
#    n. 对异己的）清洗，排除；泻药  
#    v. 清洗（组织中的异己分子）；清除，排除（不愉快的情况或感觉）
purge()
```

## 2.3 `re`库中的对象
`re`库有两种对象：
| 对象             | 名称                     | 介绍                                                                   |
| ---------------- | ------------------------ | ---------------------------------------------------------------------- |
| `re.RegexObject` | 正则表达式对象(正则对象) | `re.compile()`返回的对象                                               |
| `re.MatchObject` | 匹配对象                 | 这是**成功**调用(**失败**则返回`None`) `match()`或`search()`返回的对象 |
### 2.3.1 正则对象
&emsp;&emsp; 正则对象是`re.compile()`返回的对象，如果`Pattern`是一个正则对象，那它支持以下方法和属性：
```python
Pattern = re.compile("d")

Pattern.search(string[, pos[, endpos]])
# 类似于 search() 函数，使用了编译后的样式。

Pattern.match(string[, pos[, endpos]])
# 类似于 match() 函数，使用了编译后的样式。

Pattern.fullmatch(string[, pos[, endpos]])
# 类似于 fullmatch() 函数，使用了编译后的样式。

Pattern.split(string, maxsplit=0)
# 等价于 split() 函数，使用了编译后的样式。

Pattern.findall(string[, pos[, endpos]])
# 类似函数 findall() ， 使用了编译后样式，但也可以接收可选参数 pos 和 endpos ，限制搜索范围，就像 search()。

Pattern.finditer(string[, pos[, endpos]])
# 类似函数 finditer() ， 使用了编译后样式，但也可以接收可选参数 pos 和 endpos ，限制搜索范围，就像 search()。

Pattern.sub(repl, string, count=0)
# 等价于 sub() 函数，使用了编译后的样式。

Pattern.subn(repl, string, count=0)
# 等价于 subn() 函数，使用了编译后的样式。

Pattern.flags
# 正则匹配标记。这是可以传递给 compile() 的参数，任何 (?…) 内联标记，隐性标记比如 UNICODE 的结合。

Pattern.groups
# 捕获到的模式串中组的数量。

Pattern.groupindex
# 映射由 (?P<id>) 定义的命名符号组合和数字组合的字典。如果没有符号组，那字典就是空的。

Pattern.pattern
#编译对象的原始样式字符串。
```
下面是几个实例：
```python
import re

pattern = re.compile("d")
print(pattern.search("dog"))     # Match at index 0
print(pattern.search("dog", 1), end="\n\n")   # No match; search doesn't include the "d"


pattern = re.compile("o")
print(pattern.match("dog"))      # No match as "o" is not at the start of "dog".
print(pattern.match("dog", 1), end="\n\n")   # Match as "o" is the 2nd character of "dog".


pattern = re.compile("o[gh]")
print(pattern.fullmatch("dog")) # No match as "o" is not at the start of "dog".
print(pattern.fullmatch("ogre"))            # No match as not the full string matches.
print(pattern.fullmatch("doggie", 1, 3))    # Matches within given limits.
```
运行结果：
```
<re.Match object; span=(0, 1), match='d'>
None

None
<re.Match object; span=(1, 2), match='o'>

None
None
<re.Match object; span=(1, 3), match='og'>
```

### 2.3.2 匹配对象
&emsp;&emsp; 在**成功**调用`match()`或`search()`后，**将返回一个*匹配对象**；若调用**失败**，则返回`None`。匹配对象有`group()`和`groups()`两个主要的方法： 
| 对象       | 名称 |
| ---------- | ---- |
| `group()`  |      |
| `groups()` |      |
```python

```

## Python正则表达式前加上`r`的含义与作用
TODO:https://blog.csdn.net/u014550838/article/details/103726462



&emsp;
&emsp;
# 3. 练习
## 3.1 


https://segmentfault.com/a/1190000022242427
https://www.runoob.com/python3/python3-reg-expressions.html
https://docs.python.org/zh-cn/3/library/re.html#module-contents




```python

```
运行结果：
```

```