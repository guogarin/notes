# 1. docstring
#TODO:







&emsp;
&emsp;
&emsp;
# 2. 类型注解(type annotations)
## 2.1 为什么会需要 类型注解？
&emsp;&emsp; python 是动态语言，变量随时可以被赋值，且能赋值为不同类型，但是这种特性也是弊端：
> ① 由于不做任何类型检查，直到运行期问题才显现出来，或者线上运行时才能暴露出问题
> ② 函数的使用者看到函数的时候，并不知道你的函数的设计，并不知道应该传入什么类型数据
> 
函数注解 和 docstring 的引入，就是为了解决上述问题的。

## 2.2 关于 类型注解 的一些介绍
### 2.2.1 什么时候引入的 类型注解？
&emsp;&emsp; python3.5 开始引入的
### 2.2.2 可以对哪些值进行类型注解？
&emsp;&emsp; 可以对函数的 形参、返回值作注解。
### 2.2.3 类型注解是给谁看的？
&emsp;&emsp; 给函数的使用者、第三方工具也可以用来做代码分析。
### 2.2.4 函数的类型注解信息保存在哪？
保存在`__annotations__`属性中：
```python
def test(arg1:int, arg2:str) ->str:
	return f"{arg2} : {arg1}"

print(type(test.__annotations__))
print(test.__annotations__)
```
运行结果：
```
<class 'dict'>
{'arg1': <class 'int'>, 'arg2': <class 'str'>, 'return': <class 'str'>}
```
### 2.2.5 类型注解 是否强制规定了参数的类型？
并不是，类型注解只对函数参数做一个辅助说明，并不对函数参数进行类型检查：
```python
def test(arg1:int, arg2:str) ->str:
	return f"{arg2} : {arg1}"

print(test("Hello", "world!"))
```
运行结果：
```
world! : Hello
```
**结果分析：**
&emsp;&emsp; 类型注解说明了`arg1`参数应该为一个`int`，但是我们传了一个`str`给它，程序还是正常运行了，说明解释器并不会做类型检查。

## 2.3 既然编译器不进行参数检查，那我们自己如何实现类型检查功能？
自己编写类型功能需要用到如下两个：
> ① `inspect`模块
> ② 装饰器
> 
https://www.cnblogs.com/xzkzzz/p/11378842.html






&emsp;
&emsp;
&emsp;
# 3. 闭包(Closure)
## 3.1 什么是闭包？
&emsp;&emsp; 一般来说闭包这个概念在很多语言中都有涉及，Python中使用闭包主要是在进行函数式开发时使用。闭包的定义如下：
> &emsp;&emsp; 如果在一个内部函数里，对在外部作用域（但不是在全局作用域）的变量进行引用，那这个内部函数就被认为是闭包(closure)。举个例子：
```python
def outside_func(x):
    def inside_func(y):
        return x + y
    return inside_func

func = outside_func(1)
print(func)
print(func(2))
```
运行结果：
```
<function outside_func.<locals>.inside_func at 0x000002390848E8C0>
3
```
**结合上面的代码来解释一下闭包：**

| 定义                                               | 解释                                                              |
| -------------------------------------------------- | ----------------------------------------------------------------- |
| 如果在一个内部函数里，                             | `inside_func()`就是这个内部函数                                   |
| 对在外部作用域（但不是在全局作用域）的变量进行引用 | `outside_func()`就是这个外部作用域，`x`就是内部函数所引用的变量， |
| 那这个内部函数就被认为是闭包(closure)              | `inside_func()`就是闭包                                           |
&emsp;&emsp; 一般情况下，函数中的局部变量 仅在函数的执行期间可用，一旦 `outside_func()`执行过后，我们会认为 `x`变量将不再可用。但是我们通过`func`变量获取了返回的`inside_func()`函数，虽然此时`outside_func()`已经执行完毕，但`inside_func()`仍然记住了`outside_func()`嵌套作用域内的变量`x`。**而上面这种语言现象称之为闭包：一个能记住嵌套作用域变量值的函数，尽管作用域已经不存在。**
### 总结
&emsp;&emsp; 按理来说，则函数内部定义的变量是保存在栈区的，而且会在函数执行完毕后还给OS，闭包使得这些局部变量的值始终保存的内存中。
&emsp;&emsp; 再稍微讲究一点的解释是，`闭包 = 函数块 + 定义函数时的环境`，在上面的代码中，`outside_func()`就是函数块，`x`就是环境，当然这个环境可以有很多，不止一个简单的x。

## 3.2 关于闭包的一些注意事项
### 3.2.1 闭包中能否改变外部作用域的局部变量？
&emsp;&emsp; 可以，但是需要用`nonlocal`关键字声明一下才能修改，要不然会新建一个局部变量。


## 3.3 闭包的作用？
&emsp; 闭包主要是在函数式开发过程中使用，以下介绍两种闭包主要的用途：
> &emsp;&emsp; ① 当闭包执行完后，仍然能够保持住当前的运行环境。
> &emsp;&emsp; ② 闭包可以根据外部作用域的局部变量来得到不同的结果。
> 
**① 当闭包执行完后，仍然能够保持住当前的运行环境。**
&emsp;&emsp; 比如说，如果你希望函数的每次执行结果，都是基于这个函数上次的运行结果。我以一个类似棋盘游戏的例子来说明：
> 假设棋盘大小为50*50，左上角为坐标系原点(0,0)，我需要一个函数，接收2个参数，分别为方向(direction)，步长(step)，该函数控制棋子的运动。棋子运动的新的坐标除了依赖于方向和步长以外，当然还要根据原来所处的坐标点，用闭包就可以保持住这个棋子原来所处的坐标。
> 
```python
def create(): # pos默认是坐标系统原点 
    pos=[0, 0] # pos默认是坐标系统原点
    def player(direction,step): 
        # /* 此处应该首先判断参数direction,step的合法性，
        #   比如direction不能斜着走，step不能为负等，但
        #       此代码的重点是介绍闭包，因此略...*/
        nonlocal pos
        new_x = pos[0] + direction[0]*step 
        new_y = pos[1] + direction[1]*step 
        pos = [new_x, new_y]
        return pos 
    return player 
  
player = create() # 创建棋子player，起点为原点 
print(player([1,0],10))  # 向x轴正方向移动10步 
print(player([0,1],20))  # 向y轴正方向移动20步 
print(player([-1,0],10)) # 向x轴负方向移动10步 
```
运行结果：
```
[10, 0]
[10, 20]
[0, 20]
```
**结果分析：**
&emsp;&emsp; 显然，闭包可以保持住当前的运行环境。
**② 闭包可以根据外部作用域的局部变量来得到不同的结果。**
&emsp;&emsp; 这有点像一种类似配置功能的作用，我们可以修改外部的变量，闭包根据这个变量展现出不同的功能。比如有时我们需要对某些文件的特殊行进行分析，先要提取出这些特殊行：
```python
def make_filter(keep): 
    def the_filter(file_name): 
        file = open(file_name) 
        lines = file.readlines() 
        file.close() 
        filter_doc = [i for i in lines if keep in i] 
        return filter_doc 
    return the_filter

with open("test.txt", 'a+', encoding="utf8") as f:
    str = "A Comparative Study on 'case Grammer' in Different Languages\n"\
            "English language or literature as a subject of study\n"\
            "We can also split a string into multiple lines using string join() function. \n"
    f.write(str)

filter = make_filter("subject")
filter_result = filter("test.txt")
```

## 如何使用闭包？
&emsp;&emsp; 
https://zhuanlan.zhihu.com/p/26934085
https://www.cnblogs.com/yssjun/p/9887239.html
https://www.cnblogs.com/yssjun/p/9887239.html
https://www.jb51.net/article/54498.htm
https://blog.csdn.net/Yeoman92/article/details/67636060
https://zhuanlan.zhihu.com/p/22229197
# 参考文献
1. [Python中的闭包实例详解](https://www.jb51.net/article/54498.htm)