## 1. 可迭代对象(Iterable)
### 1.1 什么是 可迭代对象？
&emsp;&emsp; Python中有一类工具叫做迭代工具，他们能从左至右扫描对象。这包括了for循环、列表解析、in成员关系测试以及map内置函数等。
&emsp;&emsp; 而可迭代对象，顾名思义就是可以用在上述迭代工具环境中，通过一次次迭代不断产生结果的对象。

### 1.2 可迭代对象 有何共同点？或者说可迭代对象必须含有什么特征？
&emsp;&emsp; Python中的 可迭代对象 并不是指某种具体的数据类型，它是指实现了 `__iter__()`方法 或是 实现了序列语义`__getitem__( )`方法并定义了一个返回序列长度的`__len__()` 方法 的任意自定义类对象。
**① `__iter__()`方法**
&emsp;&emsp; `__iter__`方法返回一个指向该对象的迭代器

**② `__getitem__( )`方法**
&emsp;&emsp; `__getitem__( )`方法 是让对象可以通过 `obj[index]` 的方式访问实例中的元素：

以下都是可迭代对象：
```mermaid
graph LR
A[可迭代对象] 
    A --> D(迭代器)
    A --> E(内置类型)
    A --> L(自定义类型)

    L --> N["定义序列语义__getitem__( )方法并定义了一个返回序列长度的__len__()方法的类"]
    L --> M["定义了__iter__()方法的类"]

    E --> F{序列}
    E --> K{字典}
    E --> O{"open()打开文件时返回的文件句柄"}    

    F --> G[字符串]
    F --> H[列表]
    F --> I[元组]
    F --> J[集合]            
```

### 1.3 如何判断一个对象 是否 可迭代对象？
#### 1.3.1 几种判断方法
**有两种方法可以判断：**
&emsp; ① 利用`collections.Iterable` 和 `isinstance()`(**此方法不太准，不推荐**)：
```python
from collections import Iterable 
isinstance(obj, Iterable) 
```

&emsp; ② 看该对象是否可以通过`iter()`返回迭代器(**推荐这个方法**)：
&emsp; &emsp; 对于哪些只定义了`__getitem__( )`方法的对象，用`isinstance()`无法判断，可以通过对其调用`iter()`函数，看其是否可以返回迭代器：
```python
#自定义一个实现__getitem__方法的序列
class A():
    def __init__(self, *args):
        self.args = args 

    def __getitem__(self, i): 
        return self.args[i]

    def __len__(self):
        num = 0
        while True:
            try:
                self.args[num]
                num += 1
            except:
                return num

a = A(1,2,3,'ss','dd')

#可以看到实例化后的对象是可以通过 for...in 进行循环访问的，表示其是可迭代对象。
print("items in a: ", end="")
for i in range(len(a)):
    print(a[i], end=", ")
print()

#我们使用collections模块的Iterable进行判断：
from collections import Iterable,Iterator

print("isinstance(a, Iterable)      : ", isinstance(a, Iterable))
#结果出乎意料，判定对象a不是可迭代对象，为什么呢？
#因为collections模块的Iterable自动忽略了对象的__getitem__方法，只根据对象是否有__iter__方法进行判断。一般来说，标准的序列均实现了__iter__方法。
#既然上面方法无法判断具有__getitem__方法的序列是否是可迭代对象，那又该如何判断呢？
#可以使用iter()函数，如果不报错，说明是可迭代对象，报错就不是
a_iter = iter(a)
print("isinstance(a_iter, Iterable) : ", isinstance(a_iter, Iterable))
print("isinstance(a_iter, Iterator) : ", isinstance(a_iter, Iterator))
```
输出结果：
```
items in a: 1, 2, 3, ss, dd, 
isinstance(a, Iterable)      :  False
isinstance(a_iter, Iterable) :  True
isinstance(a_iter, Iterator) :  True
```
**结果分析：**
&emsp;&emsp;  ① 我们可以对 `A`类型的对象`a`进行`for`遍历，说明`A`属于可迭代类型；
&emsp;&emsp;  ② 但是`isinstance(a, Iterable)`返回的却是`False`，那是因为`collections`模块的`Iterable`自动忽略了对象的`__getitem__`方法，只根据对象是否有`__iter__`方法进行判断。一般来说，标准的序列均实现`了__iter__`方法。
&emsp;&emsp;  ③ `a_iter` 是`iter(a)`的返回对象，这更说明`A`是可迭代对象类型；
&emsp;&emsp;  ④ `isinstance(a_iter, Iterable)` 和 `isinstance(a_iter, Iterator)`返回的都是`True`，这说明可以通过`iter()`返回迭代器 的类型都是 可迭代类型。
#### 1.3.2 总结
&emsp;&emsp;  可迭代对象支持内置函数iter，通过对可迭代对象调用`iter()`函数，会返回一个迭代器，因此最稳妥的方法就是对 需要判断的对象调用`iter()`函数，然后再对其返回值调用`isinstance(a_iter, Iterator)`。

### 1.4 如何自定义 可迭代类型A？
有两种方法：
> 方法1：在类`A`中 实现`__iter__()`方法，而且`__iter__()`**必须返回一个迭代器**；
> 方法2：在类`A`中 实现**序列语义**`__getitem__( )`方法，并定义一个**返回序列长度的**`__len__()` 方法。
> 
需要注意的是，`__iter__()`**必须返回一个迭代器**；`__getitem__( )`方法必须是实现了**序列语义**，`__len__()` 方法必须**返回序列长度**。

&emsp;
## 2. 迭代器(iterator)
### 2.1 什么是迭代器？
&emsp;&emsp;  迭代器其实就是一个用来表示一连串数据流的对象，它本身也是一种 可迭代对象，迭代器可以记住遍历位置，其内部有一个状态用于记录迭代所在的位置，以便下次迭代时候能取出正确的元素。迭代器的内部实现了`__iter__`和`__next__`方法：
> `__iter__`：用来返回一个 一个迭代器，其实就是返回自己；
> `__next__`：用来返回可迭代对象的下一个元素(它可以记住遍历位置的对象，其内部有一个状态用于记录迭代所在的位置)；
> 

### 2.2 如何判断一个对象是否 迭代器？
`isinstance(a_iter, Iterator)`，其中`Iterator`来自`collections`模块：
```python
from collections import Iterator

print("isinstance(a_iter, Iterator) : ", isinstance(a_iter, Iterator))
```

### 2.3 迭代器 和 其它可迭代对象(序列和字典等) 之间的有什么区别？又有什么联系？
#### 2.3.1 区别
>  需要实现`__iter__`方法
> 和可迭代对象不同的是的是，迭代器 不仅要实现`__iter__`方法(或同时实现`__getitem__( )`和`__len__()`)，还需要实现`__next__`方法
> 
```python
s = set([1, 2, 3, 4, 5])
print(next(s))
```
报错如下：
```
Traceback (most recent call last):
  File "test.py", line 3, in <module>
    print(next(s))
TypeError: 'set' object is not an iterator
```
从报错信息可以知道，`set`对象 不是 迭代器。
**总结：**
&emsp;&emsp; 迭代器 和 序列、字典 一样，都是可迭代对象，但是迭代器比序列和字典多实现了一个方法：`__next__` 

#### 2.3.2 联系
&emsp;&emsp; 可迭代对象 通过`iter()`函数 可以生成迭代器，当把 可迭代对象 作为参数传给 内置函数 `iter()` 时，该函数会返回该对象的迭代器：
```mermaid
graph LR
    C["对可迭代对象obj调用iter(obj)"] -->| 返回 | D["指向obj的迭代器it, 即 it=iter(obj)"]
```
写段代码验证：
```python
s = set([1,2,3,4,5])

# 使用itr()方法将 可迭代对象s 获取 迭代器对象it
it = iter(s)

# 对于 迭代器对象it，我们可以调用next()方法进行迭代：
print(next(it))
print(next(it))
print(next(it))
```
输出结果：
```
1
2
3
```
结果证明的前面的结论。

### 2.4 `__next__`方法的作用是？
&emsp;&emsp; `__next__`可以用来对迭代器进行迭代访问：对**迭代器对象**调用 `__next__()`方法将返回迭代器的下一个元素(迭代器内部会记住上一次迭代到哪了)，当到达迭代器的尾部时，会引发`StopIteration`异常：
```python
s = set([1,2,3])

# 使用itr()方法将 可迭代对象s 获取 迭代器对象it
it = iter(s)

# 对于 迭代器对象it，我们可以调用next()方法进行迭代：
print(next(it))
print(next(it))
print(next(it))
print(next(it))
```
输出结果：
```
1
2
3
Traceback (most recent call last):
  File "d:\code_practice\practice.py", line 10, in <module>
    print(next(it))
StopIteration
```

### 2.5 如何生成迭代器？
生成迭代器有两种方法：
> ① 使用内置的`iter(object[, sentinel])`函数；
> ② 直接调用可迭代对象的`__iter__()`方法；
> 

值得注意的是，上面两种方式表示可以生成迭代器，但并不是使用这两个函数就一定生成迭代器，这取决于运行这两个函数返回的是什么

### 2.6 迭代器 存在的 意义(作用) 是什么？
&emsp;&emsp; 在说明迭代器存在的意义之前，我们需要引入一个容器的概念。什么是容器？容器是众多对象（在python中对象的抽象是类class）的集合，根据存储方式不同，python可分为四种容器：
> ① 列表(list): 对象以队列方式进行存储 
> ② 元组(tuple):对象以队列方式进行存储，和列表一样，只是存储数据后，不可更改， 
> ③ 集合(set): 对象以无序的方式进行存储 
> ④ 字典(dict):对象以键值对映射的方式存储数据
> 
在编程中，最常见的操作就是从这些容器中拿出数据。而容器一般是不具备取出数据的功能的。我们平时取出数据的操作实际上是先经过`__iter__()`方法转为迭代器，之后再通过`__next__()`方法拿取的（参考`for`循环,`map()`,`filter()`）。可以说迭代器赋予了容器取出数据的能力，但迭代器每次调用`__next__()`方法只能取出一个数据，这种方法显然是很笨拙的，于是引入`for`循环，每次循环自动调用`__next__()`方法，这使得访问容器中的对象变得十分方便。
&emsp;&emsp; 举个例子，迭代器的存在有点像指针。迭代器具有`__iter__()`方法(可迭代对象)就好比具备存放指针的资格，而`__next__()`方法，表示指针调度的规则。每次访问容器中的元素，首先调用`__iter__()`方法在容器元素头部放一个指针，此指针不指向任何元素，位于所有元素前面，为待操作状态，随时准备被调用。然后通过`__next__()`方法制定的规则来调度这个指针，使其指向不同的对象，指针所指之处便是所访问对象。此指针默认有一些属性：只能向前，不能回退，当没有元素时，抛出`StopIteration`,过程结束，过程如图：
<div align="center"> <img src="./pic/iterator.png"> </div>

**使用迭代器一个明显的优势是：减少内存占用**：
> **不使用迭代器**：如果我们想访问一个容器中的所有元素，就需要将所有的元素都加载到内存中，然后一次性打印，对于少量元素来说，这无关紧要，但当数据量非常大时，这种做法将占用很大的内存，影响程序性能。
> **使用迭代器**：我们访问一个容器中的所有元素，不会将所有元素都加载出来，而是一个一个的加载，然后打印，这样会极大的减少内存的占用。
> 

&emsp;
## 3. 生成器(generator)
### 3.1 什么是生成器？它的作用是？
&emsp;&emsp; 生成器是一个**用于创建迭代器**的简单而强大的工具。

### 3.2 生成器有什么优点？
&emsp;&emsp; 我们都知道列表中的数据是存在内存中的，数量少还好，如果数量巨大（如1000w条）的话可能会挤爆内存，如果列表元素梦按照某种算法推算出来，那我们就可以在循环的过程中不断推算出后续的元素，这样就不必创建完整的list，从而节省大量的空间。二生成器就是用来完成这个工作的。
&emsp;&emsp; 简单一句话：想要得到庞大的数据，又想让它占用空间少，那就用生成器！

### 3.3 如何获得一个生成器
#### 3.3.1 使用 生成器表达式(又称为生成器推导)
把一个列表生成式的`[]`改成`()`，就创建了一个 生成器：
```python
L = [x * x for x in range(6)]
print(L)

G = (x * x for x in range(6))
print(G)
```
输出结果：
```
[0, 1, 4, 9, 16, 25]
<generator object <genexpr> at 0x00000232B24F9A10>
```
根据上面的代码可知，创建`L`和`G`的区别仅在于最外层的`[]`和`()`，`L`是一个`list`，而`G`是一个`generator`。

#### 3.3.2 使用函数
&emsp;&emsp; 生成器非常强大。如果推算的算法比较复杂，用类似列表生成式的`for`循环无法实现的时候，还可以用函数来实现。比如，著名的斐波拉契数列（Fibonacci），除第一个和第二个数外，任意一个数都可由前两个数相加得到：
> 1, 1, 2, 3, 5, 8, 13, 21, 34, ...
> 
斐波拉契数列用列表生成式写不出来，但是，用函数把它打印出来却很容易：
```python
def fib(max):
    n, a, b = 0, 0, 1
    while n < max:
        print(b)
        a, b = b, a + b
        n = n + 1

fib(6)
```
上面的函数和生成器仅一步之遥。要把`fib()`函数变成生成器，只需要把`print(b)`改为`yield b`就可以了：
```python
def fib(max):
    n, a, b = 0, 0, 1
    while n < max:
        yield b
        a, b = b, a + b
        n = n + 1

print(fib(6))
```
输出结果：
```
<generator object fib at 0x000001995FE89A10>
```
这就是定义生成器的另一种方法。如果一个函数定义中包含`yield`关键字，那么这个函数就不再是一个普通函数，而是一个生成器：

### 3.4 生成器 和 迭代器 是什么关系？
简单点理解，生成器就是 迭代器的一种：
<div align="center"> <img src="./pic/generator_iterator.png"> </div>

### 3.5 如何访问一个生成器
&emsp;前面已经提到，生成器其实就是迭代器的一种，因此我们之前是怎么访问迭代器，就可以怎么访问生成器：
> &emsp;&emsp; ① 使用`__next__`方法；
> &emsp;&emsp; ② 使用`for ... in ...`等迭代工具
> 
**① 使用`__next__`方法；**
```python
G = (x * x for x in range(6))
print(G)

# 通过 __next__ 访问
print(next(G))
print(next(G))
print(next(G))
print(next(G))
print(next(G))
print(next(G))
print(next(G))
```
输出结果：
```
0
1
4
9
16
25
Traceback (most recent call last):
  File "d:\code_practice\practice.py", line 11, in <module>
    print(next(G))
StopIteration
```
**② 使用`for ... in ...`等迭代工具**
```python
G = (x * x for x in range(6))
print(G)

# 通过 for循环 访问：
for i in G:
    print(i)
```
输出结果：
```
0
1
4
9
16
25
```

### 3.6 生成器函数的工作原理（执行流程）
#### 3.6.1 如何区分 普通函数 和 生成器函数？
&emsp;&emsp; 有`yield`语句的就是 生成器函数。
#### 3.6.2 生成器的工作原理
&emsp;&emsp; 生成器的写法类似于标准的函数，但当它们要返回数据时会使用`yield`语句。每次在生成器上调`用next()` 时，它会从上次离开的位置恢复执行（它会记住上次执行语句时的所有数据值）。
&emsp;&emsp; 生成器 和 函数 的执行流程不一样：
> 函数是顺序执行，遇到`return`语句或者最后一行函数语句就返回。
> 而变成generator的函数，在每次调用`next()`的时候执行，遇到`yield`语句返回，**再次执行时**从上次返回的`yield`语句处继续执行。
> 
举个简单的例子，定义一个generator，依次返回数字1，3，5：
```python
def odd():
    print('step 1')
    yield 1
    print('step 2')
    yield 3
    print('step 3')
    yield 5

o = odd()
print(next(o))
print(next(o))
print(next(o))
print(next(o))
```
输出结果：
```
step 1
1
step 2
3
step 3
5
Traceback (most recent call last):
  File "d:\code_practice\practice.py", line 13, in <module>
    print(next(o))
StopIteration
```
**结果分析**：
&emsp;&emsp; 可以看到，`odd`不是普通函数，而是generator，在执行过程中，遇到`yield`就中断，下次又继续执行。执行3次`yield`后，已经没有`yield`可以执行了，所以，第4次调用`next()`就报错。

**再来看前面的 生成器`fib`：**
```python
def fib(max):
    print("Inside of fib()")
    n, a, b = 0, 0, 1
    while n < max:
        yield b
        a, b = b, a + b
        n = n + 1


for i in fib(6):
    print(i)
```
输出结果：
```
Inside of fib()
1
1
2
3
5
8
```
**结果分析**
&emsp;&emsp; 我们可以看到，`print("Inside of fib()")`只调用了一次，也证实了 在对生成器进行迭代的时候 **它会从上次离开的位置恢复执行（它会记住上次执行语句时的所有数据值）**。
#### 3.6.3 总结：
&emsp;&emsp; 含有`yield`的函数就是生成器，对生成器函数进行迭代的时候，生成器遇到`yield`就返回，**下次迭代时代码会从`yield`的下一条语句开始执行**，直到没有可以数据可以返回时就抛出`StopIteration`异常。
&emsp;&emsp; 对于生成器函数的调用一般不会直接用`next()`，而是借助`for ... in ...`之类的迭代工具来简化操作。


&emsp;
## 4.`for ... in ...` 
### 4.1 当调用`for`循环 遍历一个 可迭代对象时，解释器做些哪些工作？
&emsp;&emsp; 可迭代对象都可以直接用 `for… in…` 循环访问，这个语句其实做了两件事：
> ① 调用`__iter__()`获得一个迭代器`itr`；
> ② 对前面得到的迭代器`itr`循环调用`__next__()`，不断的依次获取元素，并在捕捉到`StopIteration`异常时确定完成迭代。
> 
以上就是完整的迭代过程。

### 4.2 如何让自定义的类支持`for ... in ...`操作？
给这个类定义一个`__iter__()`函数，这个函数返回一个迭代器：
```python
class ForIn():
    def __init__(self, l):
        self.numbers = l

    def __iter__(self):
        return self.numbers.__iter__()


a = ForIn ([1, 2, 3])

for i in a:
    print(i)
```
输出结果：
```
1
2
3
```


&emsp;
## 5. `yiled from`
### 5.1 `yiled from`的使用
`yiled from`是python3.3引入的新特性，用它可以简化代码：
```python
def gene():
    for c in 'AB':
        yield c  # 遇到yield程序返回循环，下次从yield后面开始。
    for i in range(3):
        yield i 

print(list(gene())) #list内部会预激生成器
```
运行结果：
```
['A', 'B', 0, 1, 2]   
```
上面的代码可以使用`yiled from`来简化：
```python
def gene():
    yield from 'AB'
    yield from range(3)

print(list(gene())) #list内部会预激生成器
```
运行结果：
```
['A', 'B', 0, 1, 2]  
```
**结果分析：**
&emsp;&emsp; 由上面两种方式对比，可以看出，yield from 后面加上可迭代对象，他可以把可迭代对象里的每个元素一个一个的 yield 出来，对比 yield 来说代码更加简洁，结构更加清晰。

### 5.2 `yiled from`的原理
&emsp;&emsp; `yield from x` 表达式对`x`对象做的第一件事是，调用 `iter(x)`获取一个指向`x`的迭代器。所以`x`必须是可迭代对象。

### 5.3 `yiled from`的优势
&emsp;&emsp; ① 使代码更简洁；
&emsp;&emsp; ② 解释器对`yiled from`进行了优化，速度要比用`for`循环迭代要快。