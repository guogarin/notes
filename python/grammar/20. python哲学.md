- [一、鸭子类型(duck typing)](#一鸭子类型duck-typing)
  - [1. 什么是鸭子类型？](#1-什么是鸭子类型)
  - [2. 关于鸭子类型的批评](#2-关于鸭子类型的批评)
  - [3. python中的具体实现](#3-python中的具体实现)
  - [4. 自己的一点理解](#4-自己的一点理解)
- [二、猴子补丁](#二猴子补丁)
- [三、Python文化中的接口和协议(Interfaces and Protocols in Python Culture)](#三python文化中的接口和协议interfaces-and-protocols-in-python-culture)
  - [1 协议(protocol)](#1-协议protocol)
    - [1. 综合](#1-综合)
      - [1.1.1 什么是协议？](#111-什么是协议)
      - [1.1.2 协议是强制性的吗？](#112-协议是强制性的吗)
      - [1.1.3 python有哪些协议？这些协议分别需要实现哪些方法？](#113-python有哪些协议这些协议分别需要实现哪些方法)
  - [2 接口(interface)](#2-接口interface)
  - [python中的多态](#python中的多态)
  - [2. 序列协议(sequence protocol)](#2-序列协议sequence-protocol)
    - [2.1 序列协议的作用是？](#21-序列协议的作用是)
    - [2.2 序列协议需要实现哪几个方法？](#22-序列协议需要实现哪几个方法)
    - [2.3 如何正确的实现序列协议？](#23-如何正确的实现序列协议)
    - [2.4 可切片的序列(A Sliceable Sequence)](#24-可切片的序列a-sliceable-sequence)
      - [2.4.1 把切片委托给对象中的序列属性的做法不够完美](#241-把切片委托给对象中的序列属性的做法不够完美)
      - [2.4.2 切片的原理：切片对象`slice`](#242-切片的原理切片对象slice)
        - [(1) 代码探索切片原理](#1-代码探索切片原理)
        - [(2) 总结](#2-总结)
      - [2.4.3 为`Vector`类实现更完美的切片](#243-为vector类实现更完美的切片)
      - [2.4.4 切片总结](#244-切片总结)







&emsp;
&emsp;
&emsp;
# 一、鸭子类型(duck typing)
## 1. 什么是鸭子类型？
&emsp; 维基百科是这么说的:
> &emsp;&emsp; 鸭子类型 在程序设计中是**动态类型的一种风格**。在这种风格中，一个对象有效的语义，不是由继承自特定的类或实现特定的接口，而是由 “当前方法和属性的集合” 决定。
> 
这个概念的名字来源于由`James Whitcomb Riley` 提出的鸭子测试（见下面的“历史”章节），“鸭子测试”可以这样表述：
> &emsp;&emsp; “当看到一只鸟走起来像鸭子、游泳起来像鸭子、叫起来也像鸭子，那么这只鸟就可以被称为鸭子。”
> 
**在鸭子类型中，关注点在于对象的行为，能做什么；而不是关注对象所属的类型**。例如：
> &emsp;&emsp; 在不使用鸭子类型的语言中，我们可以编写一个函数，它接受一个类型为“鸭子”的对象，并调用它的“走”和“叫”方法。
> &emsp;&emsp; 在使用鸭子类型的语言中，这样的一个函数可以接受一个任意类型的对象，并调用它的“走”和“叫”方法。如果这些需要被调用的方法不存在，那么将引发一个运行时错误。任何拥有这样的正确的“走”和“叫”方法的对象都可被函数接受的这种行为引出了以上表述，这种决定类型的方式因此得名。
> 
&emsp;&emsp; 鸭子类型通常得益于“不”测试方法和函数中参数的类型，而是依赖文档、清晰的代码和测试来确保正确使用。
&emsp;&emsp; 在常规类型中，我们能否在一个特定场景中使用某个对象取决于这个对象的类型，而在鸭子类型中，则取决于这个对象是否具有某种属性或者方法——即只要具备特定的属性或方法，能通过鸭子测试，就可以使用。

## 2. 关于鸭子类型的批评
&emsp; 关于鸭子类型常常被引用的一个批评是：
> &emsp;&emsp; 它要求程序员在任何时候都必须很好地理解他正在编写的代码。在一个强静态类型的、使用了类型继承树和参数类型检查的语言中，给一个类提供未预测的对象类型更为困难。例如，在Python中，你可以创建一个称为Wine的类，并在其中需要实现press方法。然而，一个称为Trousers的类可能也实现press()方法。为了避免奇怪的、难以检测的错误，开发者在使用鸭子类型时需要意识到每一个“press”方法的可能使用，即使在语义上和他所正在编写工作的代码没有任何关系。
> 
本质上，问题是：
> “如果它走起来像鸭子并且叫起来像鸭子”，它也可以是一只正在模仿鸭子的龙。尽管它们可以模仿鸭子，但也许你不总是想让龙进入池塘。
> 

鸭子类型的提倡者，如吉多·范罗苏姆认为这个问题可以通过在测试和维护代码库前拥有足够的了解来解决。
对鸭子类型的批评倾向于成为关于动态类型和静态类型的争论的更广阔的观点的特殊情形。

## 3. python中的具体实现
下面的代码就是一个简单的鸭子类型：
```python
class duck():
    def walk(self):
        print('I walk like a duck')

    def swim(self):
        print('i swim like a duck')

class person():
    def walk(self):
        print('this one walk like a duck') 

    def swim(self):
        print('this man swim like a duck')
```
对于一个鸭子类型来说，我们并不关心这个对象的类型本身或是这个类继承，而是这个类是如何被使用的。我们可以通过下面的代码来调用这些类的方法。
```python
def watch_duck(animal):
    animal.walk()
    animal.swim()

small_duck = duck()
watch_duck(small_duck)

duck_like_man = person()
watch_duck(duck_like_man)
```
`watch_duck()`函数接收这个类的对象，然后并没有检查对象的类型，而是直接调用这个对象的走和游的方法，如果所需要的方法不存在就报错。

## 4. 自己的一点理解
鸭子类型的表述：
> &emsp;&emsp; “当看到一只鸟走起来像鸭子、游泳起来像鸭子、叫起来也像鸭子，那么这只鸟就可以被称为鸭子。”
> 
对于python中的序列：
> &emsp;&emsp; 当看到一只类型走起来像序列、游泳起来像序列、叫起来也像序列，那么这只鸟就可以被称为序列。
> 
那要怎么才能让 自定义的类型的“像”序列一样呢？我们只需要实现序列对应的魔术方法即可：
> (1) `__len__()` : 
> (2) `__getitem__()`
> (3) `__setitem__()`(非必须)
> 






&emsp;
&emsp;
&emsp;
# 二、猴子补丁










&emsp;
&emsp;
&emsp;
# 三、Python文化中的接口和协议(Interfaces and Protocols in Python Culture)
## 1 协议(protocol)
### 1. 综合
#### 1.1.1 什么是协议？
&emsp;&emsp; 在python中，协议是接口(interface)，**一种非正式的接口， 只在文档中定义， 在代码中不定义**。 例如，Python 的序列协议只需要 `__len__` 和 `__getitem__` 两个方法。任何类（如 `Spam`），只要使用标准的签名和语义实现了这两个方法，就能用在任何期待序列的地方。`Spam` 是不是哪个类的子类无关紧要，只要提供了所需的方法即可。 


#### 1.1.2 协议是强制性的吗？
&emsp;&emsp; 协议是接口，但不是正式的（只由文档和约定定义），所以协议不能像正式接口那样施加限制，因此如果你知道类的具体使用场景，通常只需要实现一个协议的部分。例如，为了支持迭代，只需实现 `__getitem__` 方法，没必要提供 `__len__` 方法。

#### 1.1.3 python有哪些协议？这些协议分别需要实现哪些方法？
| 协议           | 需实现的方法 |
| -------------- | ------------ |
| 序列协议       |              |
| 迭代协议       |              |
| 映射协议       |              |
| 散列协议       |              |
| 上下文管理协议 |              |
| 缓冲协议       |              |
| 描述符协议     |              |

## 2 接口(interface)
&emsp; 关于接口，这里有个实用的补充定义： 
> &emsp;&emsp; 对象公开方法的子集， 让对象在系统中扮演特定的角色。 Python 文档中的“文件类对象”或“可迭代对象”就是这个意思， 这种说法指的不是特定的类。 接口是实现特定角色的方法集合， 这样理解正是 Smalltalk 程序员所说的协议， 其他动态语言社区都借鉴了这个术语。 协议与继承没有关系。 一个类可能会实现多个接口， 从而让实例扮演多个角色。
> 

## python中的多态











&emsp;
&emsp;
&emsp;
## 2. 序列协议(sequence protocol)
### 2.1 序列协议的作用是？
实现序列协议有两个作用：
> (1) 可以像序列一样顺序读取，如`seq[3]`;
> (2) 可以切片，如`seq[:3]`
> 

### 2.2 序列协议需要实现哪几个方法？
Python 的序列协议只需要如下的方法：
> (1) `__len__()` : 
> (2) `__getitem__()`
> (3) `__setitem__()`(非必须)
> 

### 2.3 如何正确的实现序列协议？
> (1) `__len__()` : 返回对象的长度(一个`int`)
> (2) `__getitem__()` ： 根据索引返回对应的元素
> (3) `__setitem__()`(非必须) ： 修改指定位置的序列元素，这个不是必须的，如果想提供修改功能的话才要实现。
> 
```python
import collections

Card = collections.namedtuple('Card', ['rank', 'suit'])

class FrenchDeck:
    ranks = [str(n) for n in range(2, 11)] + list('JQKA')
    suits = 'spades diamonds clubs hearts'.split()

    def __init__(self):
        self._cards = [Card(rank, suit) for suit in self.suits
                                        for rank in self.ranks]

    def __len__(self):
        return len(self._cards)

    def __getitem__(self, position):
        return self._cards[position]

fd = FrenchDeck()
print(f'索引： {fd[3]}') 
print(f'切片： {fd[:3]}')
```
运行结果：
```
索引： Card(rank='5', suit='spades')
切片： [Card(rank='2', suit='spades'), Card(rank='3', suit='spades'), Card(rank='4', suit='spades')]
```

### 2.4 可切片的序列(A Sliceable Sequence)
#### 2.4.1 把切片委托给对象中的序列属性的做法不够完美
&emsp;&emsp; 如 `FrenchDeck` 类所示，如果能委托给对象中的序列属性，支持序列协议特别简单，对于向量类`Vector`，我可以这样写：
```python
class Vector:
    typecode = 'd'

    def __init__(self, components):
        self._components = array(self.typecode, components)

    def __len__(self):
        return len(self._components)

    def __getitem__(self, index):
        return self._components[index]
```
添加这两个方法之后， 就能执行下述操作了：
```python
>>> v1 = Vector([3, 4, 5])

>>> len(v1)
## 3

>>> v1[0], v1[-1]
## (3.0, 5.0)

>>> v7 = Vector(range(7))
>>> v7[1:4]
## array('d', [1.0, 2.0, 3.0])
```
&emsp;&emsp; 可以看到， 现在连切片都支持了，不过尚不完美，如果 `Vector` 实例的切片也是 `Vector` 实例，而不是数组，那就更好了。 前面那个 `FrenchDeck` 类也有类似的问题： 切片得到的是列表。 对 `Vector` 来说， 如果切片生成普通的数组， 将会缺失大量功能。
&emsp;&emsp; 想想内置的序列类型，切片得到的都是各自类型的新实例，而不是其他类型。
&emsp;&emsp; 因此，为了把 Vector 实例的切片也变成 Vector 实例， 我们不能简单地委托给数组切片。 我们要分析传给`__getitem__` 方法的参数， 做适当的处理。
下面来看 Python 如何把 my_seq[1:3] 句法变成传给 `my_seq.__getitem__(...)` 的参数。

#### 2.4.2 切片的原理：切片对象`slice`
##### (1) 代码探索切片原理
&emsp;&emsp; 当我们对一个支持切片的变量`obj`进行切片时(如`obj[1:6`])，系统就能返回位置`1 - 6`之间的元素呢？它里面是怎么实现的呢？我们先来看看一段简单的代码，`MySeq.__getitem__()`直接将收到参数返回：
```python
class MySeq:
    def __getitem__(self, index):
        return index  ## 直接将收到参数返回  

s = MySeq()

## ① 
print(f"① s[1] : {s[1]}\n")

## ② 
print(f"② type(s[1:4])  : {type(s[1:4])}" )
print(f"  s[1:4])       : {s[1:4]}\n" )
## ③ 
print(f"③ s[1:4:2]      : {s[1:4:2]}\n")
## ④ 
print(f"④ s[1:4:2, 9]   : {s[1:4:2, 9]}\n")
## ⑤
print(f"⑤ s[1:4:2, 7:9] : {s[1:4:2, 7:9]}")
```
运行结果：
```
① s[1] : 1

② type(s[1:4])  : <class 'slice'>
  s[1:4])       : slice(1, 4, None)

③ s[1:4:2]      : slice(1, 4, 2)

④ s[1:4:2, 9]   : (slice(1, 4, 2), 9)

⑤ s[1:4:2, 7:9] : (slice(1, 4, 2), slice(7, 9, None))
```
**结果分析：**
&emsp;&emsp; ① 直接返回传给它的值(即`100`)；
&emsp;&emsp; ②  `1:4` 表示法变成了 `slice(1, 4, None)`，而且`slice`是一个类；
&emsp;&emsp; ③ `slice(1, 4, 2)` 的意思是从 `1` 开始， 到 `4` 结束， 步幅为 `2`
&emsp;&emsp; ④ 神奇的事发生了： 如果 `[]` 中有逗号， 那么 `__getitem__`收到的是元组
&emsp;&emsp; ⑤  元组中甚至可以有多个切片对象，结果为多个`slice()`组成的元组。
通过查看`slice`类的源码，发现它有 `start`、 `stop` 和 `step` 数据属性，分别对应着切片的起点、终点和步长。

##### (2) 总结
&emsp;&emsp; 通过前面的代码，我们可以得到下面的结论，切片也是通过`__getitem__()`来实现的，并且，对于切片`s[1:4:2]`，解释器在后台做了如下几个工作：
> ① 先把`1:4:2`转换为`slice(1,4,2)`，即 `s[1:4:2]` --> `s[slice(1,4,2)]`
> ② 然后`__getitem__()`收到参数`slice(1,4,2)`
> 

#### 2.4.3 为`Vector`类实现更完美的切片
刚刚已经验证过切片的原理了，现在我们可以把`Vector`的序列协议改成如下：
```python
class Vector:
    typecode = 'd'

    def __init__(self, components):
        self._components = array(self.typecode, components)

    def __len__(self):
        return len(self._components)
    def __getitem__(self, index):
        cls = type(self) 
        ## 情况1：index参数是一个切片类型(即slice)
        if isinstance(index, slice): 
            ## 转换为Vector 后再返回
            return cls(self._components[index]) 
        ## 情况二：index参数是整形，说明是顺序访问
        elif isinstance(index, numbers.Integral): 
            return self._components[index] 
        ##  情况三：抛异常
        else:
            msg = '{cls.__name__} indices must be integers'
            raise TypeError(msg.format(cls=cls))
```

#### 2.4.4 切片总结
&emsp;&emsp; (1) 切片其实也是通过调用`__getitem__()`来实现的，只不过 序列访问传过去的是`int`，切片传过去的是一个切片对象`slice(start, end, stride)`。
&emsp;&emsp; (2) 如果想实现更完美的切片，可以在`__getitem__()`函数里面用 `isinstance()`来判断参数的类型，如果实参是`int`，那就是访问序列，如果是`slice()`对象，那就是切片



