# 1. with语句
## 1.1 `with statement_1 as statement_2`是什么意思？
表示把`statement_1`的返回值赋给`statement_2`，比如对于：
```python
with open("test.txt") as f:
    ...
```
的意思就是把`open("test.txt")`的返回值赋给了`f`。

## 1.2 如何让对象支持 上下文管理协议(with语句)
有两种方法：
**(1) 标准做法：实现 `__enter__()` 和 `__exit__()` 方法**
为了让一个对象兼容 `with` 语句，需要实现`__enter__()` 和 `__exit__()` 方法：
> ` __enter__()`：它将在`with`出现的时候被触发，返回对象会赋给`as`声明的变量；
> `__exit__()` ： 他将在 离开`with`语句块时被触发，一般用它来进行清理工作。
> 
**(2) 使用`contextlib`**
具体例子见[类高级](10.%20类高级.md)





&emsp;
&emsp;
# 2. `datetime` 和 `time`
## 2.1 两者的区别和联系
&emsp;&emsp; 在Python中，`time`模块提供的是 更加接近于操作系统层面的 功能，而`datetime`是基于 `time` 进行了封装，提供了更多实用的函数。

## 2.2 建议使用哪个？
&emsp;&emsp; 因为`datetime`是基于 `time` 进行了封装，提供了更多实用的函数，所以`datetime`模块会更友好一些，尤其是在 不同时区之间进行转换的时候。





&emsp;
&emsp;
# 3. Python的序列化操作
## 3.1 `pickle`
### 3.1.1 `pickle`介绍
#### (1) `pickle`的作用是？
&emsp;&emsp; `pickle`提供的是 `二进制序列 <———> Python对象` 直接的转换操作：
> `pickle`可以把 python对象 保存为 硬盘上的二进制文件。 
> 在后面需要用到时，然后再次将对象加载到python中。
> 

#### (2) `pickle`的使用
pickle.dump() : 将Python对象转换为二进制
pickle.load() : 将字节流转换成Python对象
```python
import pickle

class GameState:
    def __init__(self):
        self.level = 0
        self.lives = 4

state = GameState()
state.level += 1 # Player beat a level
state.lives -= 1 # Player had to try again
print(state.__dict__)

# 写入
state_path = 'game_state.bin'
with open(state_path, 'wb') as f:
    pickle.dump(state, f)

# 读取
with open(state_path, 'rb') as f:
    state_after = pickle.load(f)    
print(state_after.__dict__)    
```
运行结果：
```
{'level': 1, 'lives': 3}
{'level': 1, 'lives': 3}
```

### 3.1.2 为什么需要`pickle`？
&emsp;&emsp; `pickle`提供的是一种数据持化的存储，可以把对象保存在文件中，即使关机了也能在下次开机时从对应的文件中取出来。

### 3.1.3 使用`pickle`时需要注意什么？
**(1) 不应该`pickle.load`不信任的数据**
&emsp;&emsp; `pickle`有安全隐患，经过`pickle`处理的字节流，只应该在 彼此信任的双方之间传输，我们不应该在公共网络中传输`pickle`流，因为这么做有可能被植入恶意代码，在接收端反序列化的时候被执行：
> pickle在加载时有一个副作用就是它会自动加载相应模块并构造实例对象。如果被有心人利用，那么系统会被植入恶意代码，因此，一定要保证pickle只在相互之间可以认证对方的解析器的内部使用。
> 
&emsp;&emsp; 而且`pickle`的本意是只提供一种数据传输的手段，让程序员可以在自己控制的程序之间传递二进制形式的对象。
**(2) 结合`copyreg`使用，给新属性默认值**
Effective Python里面有。

&emsp;
## 3.2 `json`
### 3.2.1 

&emsp;
## 3.3 `pickle` 和 `json`
JSON:
> 优点：跨语言(不同语言间的数据传递可用json交接)、体积小
> 缺点：只能支持int\str\list\tuple\dict
> 
Pickle:
> 优点：专为python设计，支持python所有的数据类型
> 缺点：只能在python中使用，存储数据占空间大
> 
> 
另外，它俩还有一个差异：JSON是人可读的(文本数据)，Pickle不可读(二进制数据)





&emsp;
&emsp;
# 4 `解包(unpacking)`机制
## 4.1 什么是`解包(unpacking)`？
&emsp;&emsp; 解包在英文里叫做 Unpacking，就是将容器里面的元素逐个取出来，然后赋给新变量，元组、列表、字典，甚至字符串都支持解包操作：
**① 元组解包**
```python
tp = ("Jack", 26)
name, age = tp
print(f'{name} is {age} years old.')
```
运行结果：
```
Jack is 26 years old.
```

**② 列表解包**
```python
>>> a, b, c = [1,2,3]
>>> a
# 1
>>> b
# 2
>>> c
# 3
```

**③ 字典解包**
```python
>>> a,b,c = {"a":1, "b":2, "c":3}
>>> a
# 'a'
>>> b
# 'b'
>>> c
# 'c'
```
字典解包后，只会把字典的 key 取出来，value 则丢掉了

**④ 字符串解包**
```python
>>> a,b,c = "abc"
>>> a
# 'a'
>>> b
# 'b'
>>> c
# 'c'
```

## 4.2 将容器解包后赋予新的变量，这个新的变量被修改后，容器里面的元素会被修改吗？
不会，它们是独立的：
```python
tp = ("Jack", 26)
name, age = tp
print(f'{name} is {age} years old.')

age = 100
print(tp)
```
运行结果：
```
Jack is 26 years old.
('Jack', 26)
```

## 4.3 如何理解`a, *b, c = [1,2,3,4]` ？
```python
a, *b, c = [1,2,3,4,5]
print(f'a: {a}')
print(f'b: {b}')
print(f'c: {c}')
```
运行结果：
```
a: 1
b: [2, 3, 4]
c: 5
```
这个其实就是在某个变量面前加一个星号`*`，而且这个星号可以放在任意变量，每个变量都分配一个元素后，**剩下的元素都分配给这个带星号`*`的变量**。
如果你想取 **前两个变量**：
```python
a, b, *c = [1,2,3,4,5] # 星号给了 变量c
print(f'a: {a}')
print(f'b: {b}')
print(f'c: {c}')
```
运行结果：
```
a: 1
b: 2
c: [3, 4, 5]
```

## 4.4 带星号的表达式(starred expression)
### 4.4.1 什么是  带星号的表达式
下面的`*others`就属于带星号的表达式
```python
car_ages = [0, 9, 4, 8, 7, 20, 19, 1, 6, 15]
frist, *others = car_ages
```
### 4.4.2 使用带星号表达式时需要注意什么？
必须搭配一个普通变量使用：
```python
car_ages = [0, 9, 4, 8, 7, 20, 19, 1, 6, 15]
*all = car_ages
```
运行结果：
```
  File "d:\code_practice\practice.py", line 2
    *all = car_ages
    ^^^^
SyntaxError: starred assignment target must be in a list or tuple
```
### 4.4.3 当要拆分的序列里已经没有元素留给 带星号表达式 时 会发生什么？
带星号表达式 会得到一个空列表：
```python
car_ages = [0, 1]
first, second, *others = car_ages
print(first, second, others)
```
运行结果：
```
0 1 []
```





&emsp;
&emsp;
# 5. 三元表达式
```python
args = [0, 1, 2]

reslut_0 = args[0] if (args[0] == 0) else 100
reslut_1 = args[1] if (args[1] == 0) else 99

print(f'reslut_0:{reslut_0}')
print(f'reslut_1:{reslut_1}')
```
运行结果：
```
reslut_0:0
reslut_1:99
```
`reslut_0 = args[0] if (args[0] == 0) else 100`其实相当于：
```python
if args[0] == 0:
    reslut_0 = args[0]
else:
    reslut_0 = 100
```





&emsp;
&emsp;
# 6.  python中如何交换两个变量的值？
直接用 **解包(unpacking)** 就能做到，不需要用临时变量：
```python
def bubble_sort_by_tmp(a):
    for _ in range(len(a)):
        for i in range(1, len(a)):
            if a[i] < a[i-1]:
                temp = a[i]
                a[i] = a[i-1]
                a[i-1] = temp


def bubble_sort_by_unpacking(a):
    for _ in range(len(a)):
        for i in range(1, len(a)):
            if a[i] < a[i-1]:
                a[i-1], a[i] = a[i], a[i-1] # 不需要像        


names = ['pretzels', 'carrots', 'arugula', 'bacon']
bubble_sort_by_unpacking(names)
print(names)         
```
**用 解包(unpacking) 交换两个变量的值的原理是？**
&emsp;&emsp; Python在处理赋值操作时，首先处理的是`=`右侧的值，于是它会新建一个临时元组，例如在上面的`bubble_sort_by_unpacking()`中，第一次进入内部的`for`循环时，这`a[i-1], a[i]`分别是`'pretzels', 'carrots'`，于是，系统会创建出`('pretzels', 'carrots')`这样的元组，，然后Python会对这个临时元组进行`unpacking`操作。

