- [1. 列表的`+`和`*`运算符](#1-列表的和运算符)
  - [1.1 `+`和`*`运算符 分别完成算么工作？](#11-和运算符-分别完成算么工作)
  - [1.2 `+`和`*`运算符会修改原列表吗？](#12-和运算符会修改原列表吗)
  - [1.3 修改 由`+`和`*`运算符得到的新列表，会影响原列表吗？](#13-修改-由和运算符得到的新列表会影响原列表吗)
- [2. 序列的增量赋值`+=` 和 `*=`](#2-序列的增量赋值-和-)
  - [2.1 `+=` 和 `*=` 对应的魔术方法是？](#21--和--对应的魔术方法是)
  - [2.2 `a += b`会调用哪个方法？](#22-a--b会调用哪个方法)
  - [2.3](#23)



&emsp; 
&emsp;  
# 1. 列表的`+`和`*`运算符
## 1.1 `+`和`*`运算符 分别完成算么工作？
(1) `+` 将返回一个新列表，此列表由 `+`两侧的列表拼接而成；
```python
l1 = [1, 2, 3]
l2 = [4, 5, 6]

l3 = l1 + l2

print(f"l3: {l3}")
```
运行结果：
```
l3: [1, 2, 3, 4, 5, 6]
```
(2) `list * n` 将返回一个新列表，此列表由 `n`份`list`列表拼接而成：
```python
l1 = [1, 2, 3]

l3 = l1 * 3

print(f"l3: {l3}")
```
运行结果：
```
l3: [1, 2, 3, 1, 2, 3, 1, 2, 3]
```

## 1.2 `+`和`*`运算符会修改原列表吗？
`+`和`*` 都不会修改原列表， 而是构建一个全新的序列来存放结果：
```python
l1 = [1, 2, 3]
l2 = [4, 5, 6]

l3 = l1 + l2

print(f"l3: {l3}")

print(f"id(l1) : {id(l1)}")
print(f"id(l2) : {id(l2)}")
print(f"id(l3) : {id(l3)}")
```
运行结果：
```
l3: [1, 2, 3, 4, 5, 6]
id(l1) : 1528544639296
id(l2) : 1528544628032
id(l3) : 1528544624896
```

## 1.3 修改 由`+`和`*`运算符得到的新列表，会影响原列表吗？
&emsp;&emsp; `+`、`*` 和 列表的切片操作 一样，都是 **浅拷贝**，即只拷贝父对象，不会拷贝父对象的内部的子对象，我们用代码来验证一下：
**情况一，父对象中不包含子对象：**
```python
l1 = [1, 2, 3]
l2 = [4, 5, 6]

l3 = l1 + l2
l4 = l1 * 3

# 修改l1
l1[0] =  "@@"

# 看l3和l4是否受影响：
print(f"l1: {l1}")
print(f"l3: {l3}")
print(f"l4: {l4}")
```
运行结果：
```
l3: [1, 2, 3, 4, 5, 6]
l1: [1, 2, 3]
l1: [1, 2, 3]
```
**结果分析：**
&emsp;&emsp; 可以看到的是，`+`、`*`对父对象进行了复制，而不是引用。
**情况二，父对象中包含子序列：**
```python
# l1包含子序列
l1 = [1, 2, 3, ['a', 'b', 'c']]
l2 = [4, 5, 6, ]

l3 = l1 + l2
l4 = l1 * 3

# 修改一下 l1
l1[3][0] = "@@"
print(f"l3: {l3}")
print(f"l4: {l4}")
```
运行结果：
```
l3: [1, 2, 3, ['@@', 'b', 'c'], 4, 5, 6]
l4: [1, 2, 3, ['@@', 'b', 'c'], 1, 2, 3, ['@@', 'b', 'c'], 1, 2, 3, ['@@', 'b', 'c']]
```
**结果分析：**
&emsp;&emsp; 可以看到的是，`+`、`*`不会复制父对象的子对象，而是直接引用。





&emsp; 
&emsp;  
# 2. 序列的增量赋值`+=` 和 `*=` 
## 2.1 `+=` 和 `*=` 对应的魔术方法是？
&emsp;&emsp; `+=`对应`__iadd__`，这是in-place addition(就地加法)的缩写
&emsp;&emsp; `*=`对应`__imul__`，这是in-place multiplication(就地乘法)的缩写

## 2.2 `a += b`会调用哪个方法？
&emsp;&emsp; 如果 `a` 实现了 `__iadd__` 方法， 就会调用这个方法。 同时对可变序列（例如 `list`、 `bytearray` 和 `array.array`）来说， `a` 会就地改动， 就像调用了 `a.extend(b)` 一样。 
&emsp;&emsp; 但是如果 `a` 没有实现 `__iadd__` 的话， `a += b` 这个表达式的效果就变得跟 `a = a + b` 一样了： 首先计算 `a + b`， 得到一个新的对象， 然后赋值给 `a`。 也就是说， 在这个表达式中， 变量名会不会被关联到新的对象， 完全取决于这个类型有没有实现 `__iadd__` 这个方法。
&emsp;&emsp; 上面所说的这些关于 `+=` 的概念也适用于 `*=`，不同的是，后者相对应的是 `__imul__`。关于 `__iadd__` 和`__imul__`， 

## 2.3 

