- [1. 列表的`+`和`*`运算符](#1-列表的和运算符)
  - [1.1 `+`和`*`运算符 分别完成算么工作？](#11-和运算符-分别完成算么工作)
  - [1.2 `+`和`*`运算符会修改原列表吗？](#12-和运算符会修改原列表吗)
  - [1.3 修改 由`+`和`*`运算符得到的新列表，会影响原列表吗？](#13-修改-由和运算符得到的新列表会影响原列表吗)
- [2. 序列的增量赋值`+=` 和 `*=`](#2-序列的增量赋值-和-)
  - [2.1 `+=` 和 `*=` 对应的魔术方法是？](#21--和--对应的魔术方法是)
  - [2.2 `a += b`会调用哪个方法？](#22-a--b会调用哪个方法)
  - [2.3](#23)
- [3 `list.sort`方法 和 内置函数`sorted`](#3-listsort方法-和-内置函数sorted)
  - [3.1 `list.sort`方法 和 内置函数`sorted` 是就地排序还是返回一个新的列表？](#31-listsort方法-和-内置函数sorted-是就地排序还是返回一个新的列表)
  - [3.2 `key`参数](#32-key参数)
- [4. 用`bisect`模块管理已排序的序列](#4-用bisect模块管理已排序的序列)
  - [4.1 `bisect`模块提供了什么操作？](#41-bisect模块提供了什么操作)
  - [4.2 `bisect`模块 主要提供哪些函数？](#42-bisect模块-主要提供哪些函数)
  - [4.3 使用实例](#43-使用实例)
- [5. 当列表不是首选时](#5-当列表不是首选时)
  - [5.1 适合用`array.array`的情况](#51-适合用arrayarray的情况)
  - [5.2 内存视图](#52-内存视图)
  - [5.3 `NumPy` 和 `SciPy`](#53-numpy-和-scipy)
  - [5.4 队列](#54-队列)



&emsp; 
&emsp;  
# 1. 列表的`+`和`*`运算符
## 1.1 `+`和`*`运算符 分别完成算么工作？
(1) `+` 将返回一个新列表，此列表由 `+`两侧的列表拼接而成；
```python
l1 = [1, 2, 3]
l2 = [4, 5, 6]

l3 = l1 + l2

print(f"l3: {l3}")
```
运行结果：
```
l3: [1, 2, 3, 4, 5, 6]
```
(2) `list * n` 将返回一个新列表，此列表由 `n`份`list`列表拼接而成：
```python
l1 = [1, 2, 3]

l3 = l1 * 3

print(f"l3: {l3}")
```
运行结果：
```
l3: [1, 2, 3, 1, 2, 3, 1, 2, 3]
```

## 1.2 `+`和`*`运算符会修改原列表吗？
`+`和`*` 都不会修改原列表， 而是构建一个全新的序列来存放结果：
```python
l1 = [1, 2, 3]
l2 = [4, 5, 6]

l3 = l1 + l2

print(f"l3: {l3}")

print(f"id(l1) : {id(l1)}")
print(f"id(l2) : {id(l2)}")
print(f"id(l3) : {id(l3)}")
```
运行结果：
```
l3: [1, 2, 3, 4, 5, 6]
id(l1) : 1528544639296
id(l2) : 1528544628032
id(l3) : 1528544624896
```

## 1.3 修改 由`+`和`*`运算符得到的新列表，会影响原列表吗？
&emsp;&emsp; `+`、`*` 和 列表的切片操作 一样，都是 **浅拷贝**，即只拷贝父对象，不会拷贝父对象的内部的子对象，我们用代码来验证一下：
**情况一，父对象中不包含子对象：**
```python
l1 = [1, 2, 3]
l2 = [4, 5, 6]

l3 = l1 + l2
l4 = l1 * 3

# 修改l1
l1[0] =  "@@"

# 看l3和l4是否受影响：
print(f"l1: {l1}")
print(f"l3: {l3}")
print(f"l4: {l4}")
```
运行结果：
```
l3: [1, 2, 3, 4, 5, 6]
l1: [1, 2, 3]
l1: [1, 2, 3]
```
**结果分析：**
&emsp;&emsp; 可以看到的是，`+`、`*`对父对象进行了复制，而不是引用。
**情况二，父对象中包含子序列：**
```python
# l1包含子序列
l1 = [1, 2, 3, ['a', 'b', 'c']]
l2 = [4, 5, 6, ]

l3 = l1 + l2
l4 = l1 * 3

# 修改一下 l1
l1[3][0] = "@@"
print(f"l3: {l3}")
print(f"l4: {l4}")
```
运行结果：
```
l3: [1, 2, 3, ['@@', 'b', 'c'], 4, 5, 6]
l4: [1, 2, 3, ['@@', 'b', 'c'], 1, 2, 3, ['@@', 'b', 'c'], 1, 2, 3, ['@@', 'b', 'c']]
```
**结果分析：**
&emsp;&emsp; 可以看到的是，`+`、`*`不会复制父对象的子对象，而是直接引用。





&emsp; 
&emsp;  
# 2. 序列的增量赋值`+=` 和 `*=` 
## 2.1 `+=` 和 `*=` 对应的魔术方法是？
&emsp;&emsp; `+=`对应`__iadd__`，这是in-place addition(就地加法)的缩写
&emsp;&emsp; `*=`对应`__imul__`，这是in-place multiplication(就地乘法)的缩写

## 2.2 `a += b`会调用哪个方法？
&emsp;&emsp; 如果 `a` 实现了 `__iadd__` 方法， 就会调用这个方法。 同时对可变序列（例如 `list`、 `bytearray` 和 `array.array`）来说， `a` 会就地改动， 就像调用了 `a.extend(b)` 一样。 
&emsp;&emsp; 但是如果 `a` 没有实现 `__iadd__` 的话， `a += b` 这个表达式的效果就变得跟 `a = a + b` 一样了： 首先计算 `a + b`， 得到一个新的对象， 然后赋值给 `a`。 也就是说， 在这个表达式中， 变量名会不会被关联到新的对象， 完全取决于这个类型有没有实现 `__iadd__` 这个方法。
&emsp;&emsp; 上面所说的这些关于 `+=` 的概念也适用于 `*=`，不同的是，后者相对应的是 `__imul__`。关于 `__iadd__` 和`__imul__`， 

## 2.3 






&emsp; 
&emsp;  
# 3 `list.sort`方法 和 内置函数`sorted`
## 3.1 `list.sort`方法 和 内置函数`sorted` 是就地排序还是返回一个新的列表？
他俩有些不一样：
&emsp;&emsp; `list.sort`方法会就地排序列表， 也就是说不会把原列表复制一份。 这也是这个方法的返回值是 `None` 的原因， 提醒你本方法不会新建一个列表。 在这种情况下返回 `None` 其实是 Python 的一个惯例： 如果一个函数或者方法对对象进行的是就地改动， 那它就应该返回 `None`， 好让调用者知道传入的参数发生了变动， 而且并未产生新的对象。 例如， `random.shuffle`函数也遵守了这个惯例。
&emsp;&emsp; 内置函数`sorted`会新建一个列表作为返回值。

## 3.2 `key`参数






&emsp; 
&emsp;  
# 4. 用`bisect`模块管理已排序的序列
## 4.1 `bisect`模块提供了什么操作？
&emsp; &emsp;  `bisect`是一个内置模块，它为数组提供了`bisection algorith(二分法`)查找算法。

## 4.2 `bisect`模块 主要提供哪些函数？
看了下`bisect`模块的源码(3.10版本)，它包含了如下4个函数：
> ① `bisect.bisect_left(a, x, lo=0, hi=len(a), *, key=None)` :
> > > &emsp; &emsp;  在 `a` 中找到 `x` 合适的插入点以维持有序。参数 `lo` 和 `hi` 可以被用于确定需要考虑的子集；默认情况下整个列表都会被使用。如果 `x` 已经在 `a` 里存在，那么插入点会在已存在元素之前（也就是左边）。
> 
> ② `bisect.bisect_right(a, x, lo=0, hi=len(a), *, key=None)` :
> > > &emsp; &emsp;  类似于 `bisect_left()`，但是返回的插入点是 `a` 中已存在元素 `x` 的右侧。
> 
> ③ `bisect.insort_left(a, x, lo=0, hi=len(a), *, key=None)` :
> > > &emsp; &emsp; 按照已排序顺序将 `x` 插入到 `a` 中已存在元素 `x` 的坐侧。
> 
> ④ `bisect.insort_right(a, x, lo=0, hi=len(a), *, key=None)` :
> > > &emsp; &emsp; 类似于 `insort_left()`，但是把 `x` 插入到 `a` 中已存在元素 `x` 的右侧。
> 
至于`bisect()` 和 `insort()`，他们都只是别名而已：
```python
# 下面是部分源码：

# Create aliases
bisect = bisect_right
insort = insort_right
```

## 4.3 使用实例
```python

```
运行结果：
```

```






&emsp; 
&emsp;  
# 5. 当列表不是首选时
## 5.1 适合用`array.array`的情况
如果我们需要一个只包含同一数据类型的列表，那`array.array`会更适合，因为它不仅更节省空间，而且还提供从文件读取和存入文件的更快的方法， 如`frombytes` 和 `tofile`。

## 5.2 内存视图
操作实现了缓冲协议的对象时，内存视图效率更高。

## 5.3 `NumPy` 和 `SciPy`
 `NumPy` 和 `SciPy` 提供的高阶数组和矩阵操作

## 5.4 队列
&emsp; &emsp;  虽然利用 `append` 和 `pop` 方法可以把列表当作栈或者队列来用，但是删除列表的第一个元素（抑或是在第一个元素之前添加一个元素） 之类的操作是很耗时的， 因为这些操作会牵扯到移动列表里的所有元素。
`collections.deque`类（双向队列） 是一个线程安全、 可以快速从两端添加或者删除元素的数据类型。