[toc]




# 图论
## 1. 

## 2. 图的遍历
### 2.1 深度优先(Depth First Search, DFS)

### 2.2 广度优先(Breadth First Search, BFS)
BFS 可以看成是层序遍历。从某个结点出发，BFS 首先遍历到距离为 1 的结点，然后是距离为 2、3、4…… 的结点。因此，BFS 可以用来求最短路径问题。BFS 先搜索到的结点，一定是距离最近的结点。
#### BFS适合的场景
最短路径

### 2.3 实例讲解DFS和BFS：
### (1) 岛屿数量
题目：[200. 岛屿数量](https://leetcode.cn/problems/number-of-islands/?envType=study-plan-v2&envId=top-100-liked)
解法：
```python
class Solution:
    def numIslands(self, grid: List[List[str]]) -> int:
        def dfs(r, c):
            # 判断边界
            if  r < 0 or r >= len(grid) or c < 0 or c >= len(grid[0]):
                return
            # 改为0也可以，但是这样就不能区分陆地和水了
            if grid[r][c] == "1": 
                grid[r][c] = "2" 
            elif grid[r][c] == "0" or grid[r][c] == "2":
                return
            # 深度优先遍历(r, c)上下左右四个节点
            dfs(r-1, c), dfs(r+1, c), dfs(r, c-1), dfs(r, c+1)

        cnt = 0
        for r in range(len(grid)):
            for c in range(len(grid[0])):
                print(r, c)
                if grid[r][c] == "1":
                    cnt += 1
                    dfs(r, c)                    
        return cnt
```
### (2) 腐烂的橘子
题目：[994. 腐烂的橘子](https://leetcode.cn/problems/rotting-oranges/?envType=study-plan-v2&envId=top-100-liked)
解法：
使用BFS
**为何使用BFS？**
> &emsp;&emsp; BFS 可以看成是层序遍历。从某个结点出发，BFS 首先遍历到距离为 1 的结点，然后是距离为 2、3、4…… 的结点。因此，BFS 可以用来求最短路径问题。BFS 先搜索到的结点，一定是距离最近的结点。
> &emsp;&emsp; 再看看这道题的题目要求：返回直到单元格中没有新鲜橘子为止所必须经过的最小分钟数。翻译一下，实际上就是求腐烂橘子到所有新鲜橘子的最短路径。那么这道题使用 BFS，应该是毫无疑问的了。
> 
```python

```





&emsp;
&emsp;
# 回溯算法(Back Tracking)
## 1 什么是回溯算法？
&emsp;&emsp; 回溯法 采用试错的思想，它尝试分步的去解决一个问题。在分步解决问题的过程中，当它通过尝试发现现有的分步答案不能得到有效的正确的解答的时候，它将取消上一步甚至是上几步的计算，再通过其它的可能的分步解答再次尝试寻找问题的答案。回溯法通常用最简单的递归方法来实现，在反复重复上述的步骤后可能出现两种情况：
* 找到一个可能存在的正确的答案；
* 在尝试了所有可能的分步方法后宣告该问题没有答案。

> &emsp;&emsp; 回溯法可以理解为通过选择不同的岔路口寻找目的地，一个岔路口一个岔路口的去尝试找到目的地。如果走错了路，继续返回来找到岔路口的另一条路，直到找到目的地。
>

## 2 回溯算法思想
&emsp;&emsp; 回溯法一般都用在要给出多个可以实现最终条件的解的最终形式。回溯法要求对解要添加一些约束条件。总的来说，如果要解决一个回溯法的问题，通常要确定三个元素：
1、**选择**。对于每个特定的解，肯定是由一步步构建而来的，而每一步怎么构建，肯定都是有限个选择，要怎么选择，这个要知道；同时，在编程时候要定下，优先或合法的每一步选择的顺序，一般是通过多个if或者for循环来排列。

2、**条件**。对于每个特定的解的某一步，他必然要符合某个解要求符合的条件，如果不符合条件，就要回溯，其实回溯也就是递归调用的返回。

3、**结束**。当到达一个特定结束条件时候，就认为这个一步步构建的解是符合要求的解了。把解存下来或者打印出来。对于这一步来说，有时候也可以另外写一个issolution函数来进行判断。注意，当到达第三步后，有时候还需要构建一个数据结构，把符合要求的解存起来，便于当得到所有解后，把解空间输出来。这个数据结构必须是全局的，作为参数之一传递给递归函数。

## 回溯 和 递归
&emsp;&emsp; 很多人认为回溯和递归是一样的，其实不然。在回溯法中可以看到有递归的身影，但是两者是有区别的：
> &emsp;&emsp; **回溯法** 从问题本身出发，寻找可能实现的所有情况。和穷举法的思想相近，不同在于穷举法是将所有的情况都列举出来以后再一一筛选，而回溯法在列举过程如果发现当前情况根本不可能存在，就停止后续的所有工作，返回上一步进行新的尝试。
> &emsp;&emsp; **递归** 是从问题的结果出发，例如求 n！，要想知道 n！的结果，就需要知道 n*(n-1)! 的结果，而要想知道 (n-1)! 结果，就需要提前知道 (n-1)*(n-2)!。这样不断地向自己提问，不断地调用自己的思想就是递归。
> 
回&emsp;&emsp; 溯和递归唯一的联系就是，回溯法可以用递归思想实现。

## 实例讲解一：全排列
[46. 全排列](https://leetcode.cn/problems/permutations/?envType=study-plan-v2&envId=top-100-liked)

## 实例讲解二：八皇后问题