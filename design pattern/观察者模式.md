## 1 观察者模式有何特点？
&emsp;&emsp; 观察者模式又叫做发布-订阅（Publish/Subscribe） 模式。它定义了一种 一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态发生变化时，会通知所有观察者对象，使它们能自动更新自己。
&emsp;&emsp; 换句话说，观察者模式可以简化成报纸订阅系统。报纸会给所有订阅的用户发送新报纸，任何人都可以成为订阅用户或是取消订阅。





&emsp;
&emsp;
## 2 C++实现
观察者模式的核心思想是 1对多，角色：被观察对象，观察者，它们之间的关系是：
> 1）被观察对象：观察者 = 1：n
> 2）被观察对象状态发生变化，会通知所有观察者，观察者将做出相应的反应
> 
### 2.1 普通实现
#### 2.1.1 代码
```cpp
#include <algorithm>
#include <vector>
#include <stdio.h>

class Observable;

// Observer是一个 抽象基类，因为它含有纯虚函数 update()
// 将Observer定义为抽象基类，这样用户就可以对其进行继承，
// 然后通过重写update()来自定义观察行为
class Observer
{
    public:
        virtual ~Observer();// 基类的析构函数应定义为虚函数
        virtual void update() = 0; // 纯虚函数，让派生类可以自定义 update()操作

        void observe(Observable* s);

    protected:
        Observable* subject_;
};

class Observable
{
public:
    void register_(Observer* x);
    void unregister(Observer* x);

    void notifyObservers()
    {
        for (size_t i = 0; i < observers_.size(); ++i)
        {
            Observer* x = observers_[i];
            if (x) {
                x->update(); // (3)
            }
        }
    }

private:
    // 注意，vector的类型是 指向基类的指针 Observer*，这样就可以把派生类绑定到上面
    std::vector<Observer*> observers_; 
};

Observer::~Observer()
{
    subject_->unregister(this);
}

void Observer::observe(Observable* s)
{
    s->register_(this);
    subject_ = s;
}

void Observable::register_(Observer* x)
{
    observers_.push_back(x);
}

void Observable::unregister(Observer* x)
{
    std::vector<Observer*>::iterator it = std::find(observers_.begin(), observers_.end(), x);
    if (it != observers_.end())
    {
        // 这里对vector的删除操作也是很有想法的，
        // (1) 先把 待删除的元素 和 最后一个元素 换个位置
        // (2) 删除最后一个元素
        std::swap(*it, observers_.back());// back()返回的是vector中最后一个元素的引用
        observers_.pop_back();
    }
}

// ---------------------
// Foo 是观察者
class Foo : public Observer
{
    // 重写基类的纯虚函数，达到自定义 update()方法的目的
    virtual void update() 
    {
        printf("Foo::update() %p\n", this);
    }
};

class Test : public Observer{
    virtual void update(){
        printf("%p, 回家吃饭啦！\n", this);
    }
};


int main()
{
    Observable obs;

    Foo * ptr_f = new Foo;
    ptr_f -> observe(&obs);
    
    Test * ptr_t = new Test;
    ptr_t -> observe(&obs);

    obs.notifyObservers();
    delete ptr_f;
    obs.notifyObservers();
    delete ptr_t;
    obs.notifyObservers();
}
```
编译后运行：
```
Foo::update() 0x1f52eb0
0x1f52ef0, 回家吃饭啦！
0x1f52ef0, 回家吃饭啦！
```
#### 2.1.2 实现细节
&emsp;&emsp; 前面提到，观察者模式可以简化成报纸订阅系统。报纸会给所有订阅的用户发送新报纸，任何人都可以成为订阅用户或是取消订阅。因此观察者模式可以实现为两个类：观察者类`Observer` 和 观测对象类`Observable`，其中 `Observer`是报纸的订阅者，`Observable`是出版社，因此出版社(`Observable`对象)只有一个，而报纸的订阅者(`Observer`对象)可以有很多个。

#### 2.1.3 自己实现时遇到的问题
(1) 注册总是是忘记传`this`指针进去
(2) 忘记定义`subject_`来记住 `Observable`对象
(3) notifyObservers为什么在类内部实现，而 register_在类外实现？
(4) notifyObservers实现的时候没有先对vector里面的元素进行判空
(5) `Observer::subject_`为什么要声明为`protected`？
&emsp;&emsp; 应该是为了让子类可以直接访问，方便以后扩展
(6) 编译时，报错信息如下：
```
test.cpp: In destructor ‘virtual Observer::~Observer()’:
test.cpp:18:14: error: invalid use of incomplete type ‘class Observable’
     subject_ -> unregister_(this);// TODO
              ^~
test.cpp:6:7: note: forward declaration of ‘class Observable’
 class Observable;
       ^~~~~~~~~~
test.cpp: In member function ‘void Observer::observer(Observable*)’:
test.cpp:23:14: error: invalid use of incomplete type ‘class Observable’
     subject_ -> register_(this);
              ^~
test.cpp:6:7: note: forward declaration of ‘class Observable’
 class Observable;
       ^~~~~~~~~~
```
**原因：**
试图访问仅仅进行了前向声明的类`Observable`的成员，但是：
> &emsp;&emsp; C++的类可以进行前向声明。但是，仅仅进行前向声明而没有定义的类是不完整的，这样的类，只能用于定义指针、引用、以及用于函数形参的指针和引用。
> &emsp;&emsp; 而不能定义对象(因为此时编译器只知道这是个类，还不知道这个类的大小有多大)，也不能访问类的对象，任何形式的访问都不允许(因为此时根本不知道有些什么成员)。等到类正式定义以后，就可以以各种方式使用该类了。
> 
#### 2.1.4 不足
TODO:

### 2.2 线程安全的实现




&emsp;
&emsp;
## 参考文献
1. [Linux多线程服务端编程 : 使用muduo C++网络库](https://book.douban.com/subject/20471211/)
2. [设计模式之禅(第二版)](https://book.douban.com/subject/25843319/)
3. [大话设计模式](https://book.douban.com/subject/2334288/)
4. [观察者模式（c++学习笔记）](https://zhuanlan.zhihu.com/p/119308881)