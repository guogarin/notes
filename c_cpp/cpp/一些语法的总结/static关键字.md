## 1. 总结
### 1.1 `static`关键字有哪些用处？
`static`根据使用场景的不同（变量、普通函数、类），可以有以下几种用处：
> (1) 静态成员变量（面向对象）
> (2) 静态成员函数（面向对象）
> (3) 静态全局变量（面向过程）
> (4) 静态局部变量（面向过程）
> (5) 静态函数&emsp;&emsp;（面向过程）
> 
### 静态变量 和 非静态变量 的区别
可见性、生存周期、默认初始化方式、内存分配的位置

### 静态函数 和 非静态函数 的区别

### 类的 静态成员 和 非静态成员 的区别




&emsp;
&emsp;
## 2. 用在 变量 中
&emsp;&emsp; 在变量前加上关键字`static`，这就声明了一个静态变量，然后根据变量的可见性，又能分为 静态全局变量 和 静态局部变量
### 2.1 静态全局变量
#### 2.1.1 如何声明 静态全局变量
&emsp;&emsp; 在全局变量前，加上关键字static，该变量就被定义成为一个静态全局变量。
```cpp
#include <iostream.h> 

static int n; //定义静态全局变量 

void main()
{
	n=20;
	cout<<n<<endl;
}
```
#### 2.1.2 静态全局变量有哪些特点？
(1) 该变量在全局数据区分配内存；
(2) 未经初始化的静态全局变量会被程序自动初始化为0（自动变量的自动初始化值是随机的）；
(3) 静态全局变量在声明它的整个文件都是可见的，而在文件之外是不可见的； 　
静态变量都在全局数据区分配内存，包括后面将要提到的静态局部变量。对于一个完整的程序，在内存中的分布情况如下：【代码区】【全局数据区】【堆区】【栈

#### 2.1.3 静态全局变量 和 普通全局变量 有何区别
&emsp;&emsp; 生存周期，内存分配位置都一样，初始化也是一样的；它们主要的区别就是 可见性，普通全局变量在其它文件中也可见，`static`全局变量在其它文件不可见。

#### 2.1.4 有了 普通全局变量了，为什么还需要 静态全局变量？
&emsp;&emsp; 希望变量被改文件私有时需要使用 静态全局变量。

### 2.2 静态局部变量
#### 2.2.1 如何声明 静态局部变量？
在局部变量前，加上关键字static，该变量就被定义成为一个静态局部变量。
```cpp
#include <iostream.h> 

void func(){
	static int n; //定义静态全局变量 
}

void main()
{
	func();
}
```
#### 2.2.2 静态局部变量什么时候被初始化？
&emsp;&emsp; 静态局部变量在程序执行到该对象的声明处时被首次初始化，即以后的函数调用不再进行初始化；
#### 2.2.3 静态局部变量在内存中 被分配在什么地方？
&emsp;&emsp; 不同于普通局部变量，静态局部变量分配在全局区。
#### 2.2.4 静态局部变量 什么时候被销毁？
&emsp;&emsp; 程序运行结束时销毁
#### 2.2.5 静态局部变量 有何特点？
(1) 静态局部变量在全局数据区分配内存（普通的局部变量在栈区）；
(2) 静态局部变量在程序执行到该对象的声明处时被首次初始化，即以后的函数调用不再进行初始化；
(3) 静态局部变量一般在声明处初始化，如果没有显式初始化，会被程序自动初始化为0；
(4) 静态局部变量始终驻留在全局数据区，直到程序运行结束。但其作用域为局部作用域，当定义它的函数或语句块结束时，其作用域随之结束；
#### 2.2.6 C++11 关于 局部静态变量 的初始化 的新特性
&emsp;&emsp; 我们都知道，局部静态变量在第一次执行时初始化，而且只初始化一次。而对于局部静态对象，其初始化发生在控制流第一次执行到该对象的初始化语句时，多个线程的控制流可能同时到达其初始化语句。
&emsp;&emsp; 在C++11之前，在多线程环境下局部静态对象的初始化并不是线程安全的。具体表现就是：如果一个线程正在执行局部静态对象的初始化语句但还没有完成初始化，此时若其它线程也执行到该语句，那么这个线程会认为自己是第一次执行该语句并进入该局部静态对象的构造函数中。这会造成这个局部静态对象的重复构造，进而产生内存泄露问题。所以，局部静态对象在多线程环境下的重复构造问题是需要解决的。
&emsp;&emsp; 而C++11则在语言规范中解决了这个问题。C++11规定，在一个线程开始局部静态 对象的初始化后到完成初始化前，其他线程执行到这个局部静态对象的初始化语句就会等待，直到该局部静态 对象初始化完成。



### 2.3 总结
| 变量类型         | 可见性           | 生存周期           | 内存分配的位置 | 何时初始化                                         | 默认初始化为何值 |
| ---------------- | ---------------- | ------------------ | -------------- | -------------------------------------------------- | ---------------- |
| 普通局部变量     | 局部可见         | 离开作用域则销毁   | 栈区 或 堆区   | 运行到所在语句块时                                 | 未定义           |
| `static`局部变量 | 局部可见         | 一直存在到程序结束 | 全局数据区     | 在程序执行到该对象的声明处时(下次再遇到不会初始化) | 0                |
| 普通全局变量     | **其它文件**可见 | 一直存在到程序结束 | 全局数据区     | main执行之前                                       | 0                |
| `static`全局变量 | 仅**本文件**可见 | 一直存在到程序结束 | 全局数据区     | main执行之前                                       | 0                |



&emsp;
&emsp;
## 3. 用在函数上： 静态函数
### 3.1 如何声明静态函数
&emsp;&emsp; 在函数的返回类型前加上static关键字,函数即被定义为静态函数。
```cpp
static void fn()
{
	int n=10;
	cout<<n<<endl;
}
```

### 3.2 静态函数 和 普通函数有何区别？
&emsp;&emsp; 静态函数与普通函数不同，它只能在声明它的文件当中可见，不能被其它文件使用。其它文件中可以定义相同名字的函数，不会发生冲突；

### 3.3 静态函数 的使用场景是什么？
&emsp;&emsp; 当你不希望函数被其它文件使用时。



&emsp;
&emsp;
## 4. 用在类成员上
见C++ primer 第7章的笔记



## 参考目录
1. [C/C++ 中的static关键字](https://zhuanlan.zhihu.com/p/37439983)
2. [c++11 最简单的线程安全的单例模式（利用local static）](https://blog.csdn.net/lgfun/article/details/105810039)