# 综述：用于大型程序的工具
&emsp;&emsp; 与仅需几个程序员就能开发完成的系统相比，大规模编程对程序设计语言的要求更高。大规模应用程序的特殊要求包括：
> ① 在独立开发的子系统之间协同处理错误的能力；
> ② 使用各种库（可能包含独立开发的库）进行协同开发的能力；
> ③ 对比较复杂的应用概念建模的能力。
> 
本章需要介绍的三种C++语言特性正好能满足上述要求：
> ① 异常处理
> ② 命名空间
> ③ 多重继承
> 







&emsp;
&emsp;
&emsp; 
# 一、异常处理(exception handling)







&emsp;
&emsp;
&emsp; 
# 二、命名空间(namespace)
## 1. 为什么需要 命名空间？
### 1.1 待解决的问题
&emsp;&emsp; 大型程序往往会使用多个独立开发的库，这些库又会定义大量的全局对象（如类、函数、模板等）。当应用程序用到多个供应商提供的库时，不可避免的会发生某些名字冲突的情况，此时如果将这些库的名字放置在全局命名空间中将引发**命名空间污染(namespace pollution)**。
### 1.2 传统的解决方法
&emsp;&emsp; 传统上，程序员通过将其定义全局名字设置的很长，以此来避免命名空间污染问题，这样的名字通常包含名字所属库的前缀部分：
```cpp
// cplusplus 前缀
class cplusplus_primer_Query { ... };
string cplusplus_primer_make_plural(size_t, string&);
```
这种解决方案显然不太理想：
> 对于程序员来说，书写、阅读 这么长的名字费时费力且过于繁琐。
> 
### 1.3 更优秀的解决方法：命名空间
&emsp;&emsp; 命名空间(namespace) 为防止名字冲突提供了更加可控的机制：
> 命名空间分割了全局命名空间，其中每个命名空间都是一个作用域，通过在某个命名空间中定义库的名字，可以避免命名冲突。
> 
### 1.3 总结
&emsp;&emsp; 命名空间其实就是用来解决命名冲突的。

&emsp; 
## 2. 命名空间的定义
### 2.1 如何定义一个命名空间？
&emsp;&emsp; 一个命名空间的定义包含两部分：
> ① 关键字`namespace`
> ② 命名空间的名字，并在名字的后面跟着一系列由花括号括起来的声明和定义。
> 
只要能出现在全局作用域中的声明就能置于命名空间内：
```cpp
namespace cplusplus_primer {
    class Sales_data { / * ... * /};
    Sales_data operator+(const Sales_data&,
                          const Sales_data&);
    class Query { /* ... */ };
    class Query_base { /* ... */};
} // 注意，无需分号
```
上面的代码定义了一个名为`cplusplus_primer`的命名空间，该命名空间包含四个成员：3个类 和 一个重载的`+`运算符。


## 3. 为什么命名空间可以解决命名冲突？
&emsp;&emsp; 因为每个命名空间都是一个单独的作用域，所以在不同的命名空间内可以有相同的名字。

## 4. 如何访问一个命名空间内的成员？
&emsp;&emsp; 定义在某个命名空间中的名字可以被该命名空间内的其它成员直接访问，也可以被这些成员内嵌的任何单位访问：
```cpp
namespace cplusplus_primer {
    class Sales_data { / * ... * /};

    Sales_data s; // 直接访问同一命名空间内的Sales_data类
} 
```
&emsp;&emsp; 



### 可以在`miain`函数内定义命名空间吗？