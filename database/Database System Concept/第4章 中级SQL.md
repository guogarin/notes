[toc]





# 1. 连接表达式
## 1.1 笛卡尔积(Cartesian product)  
### 1.1.1 什么是笛卡尔积？
&emsp;&emsp; 笛卡尔积原本是代数的概念，他的意思是对于两个不同的集合A，B。对于A中的每一个元素，都有对于在B中的所有元素做连接运算 。可以见得对于两个元组分别为m，n的表。笛卡尔积后得到的元组个数为m x n个元组。
&emsp;&emsp; 例如现在我们有两个集合 `A = {0,1}` , `B = {2,3,4}`,那么，集合 `A * B` 得到的结果就是
> A * B = {(0,2)、(1,2)、(0,3)、(1,3)、(0,4)、(1,4)};
> 
`B * A` 得到的结果就是
> B * A = {(2,0)、{2,1}、{3,0}、{3,1}、{4,0}、(4,1)};
> 
上面 `A * B` 和 `B * A` 的结果就可以称为两个集合相乘的 笛卡尔积


### 1.1.2 如何得到笛卡尔积？
&emsp;&emsp; 笛卡尔积是指将两个或多个表中的每一行组合在一起，形成所有可能的组合。
&emsp;&emsp; 当在MySQL中使用`JOIN`语句时，如果**没有明确指定连接条件** 或 **使用`WHERE`子句**，那么将产生笛卡尔积（Cartesian product）。
```
Sales 表：
+---------+------------+------+----------+-------+
| sale_id | product_id | year | quantity | price |
+---------+------------+------+----------+-------+ 
| 1       | 100        | 2008 | 10       | 5000  |
| 2       | 100        | 2009 | 12       | 5000  |
| 7       | 200        | 2011 | 15       | 9000  |
+---------+------------+------+----------+-------+

Product 表：
+------------+--------------+
| product_id | product_name |
+------------+--------------+
| 100        | Nokia        |
| 200        | Apple        |
| 300        | Samsung      |
+------------+--------------+
```
有sql如下：
```sql
select * from Sales, product; -- 获取 Sales表 和 product表 的笛卡尔积
```
执行结果如下：
```
| sale_id | product_id | year | quantity | price | product_id | product_name |
| ------- | ---------- | ---- | -------- | ----- | ---------- | ------------ |
| 7       | 200        | 2011 | 15       | 9000  | 100        | Nokia        |
| 2       | 100        | 2009 | 12       | 5000  | 100        | Nokia        |
| 1       | 100        | 2008 | 10       | 5000  | 100        | Nokia        |
| 7       | 200        | 2011 | 15       | 9000  | 200        | Apple        |
| 2       | 100        | 2009 | 12       | 5000  | 200        | Apple        |
| 1       | 100        | 2008 | 10       | 5000  | 200        | Apple        |
| 7       | 200        | 2011 | 15       | 9000  | 300        | Samsung      |
| 2       | 100        | 2009 | 12       | 5000  | 300        | Samsung      |
| 1       | 100        | 2008 | 10       | 5000  | 300        | Samsung      |
```

## 1.2 自然连接(natural join)
### 1.2.1 什么是自然连接？它和笛卡尔积有何区别？
&emsp;&emsp; 自然连接运算作用于两个表，并产生一个表作为结果。与两个表的笛卡尔积不同的是，自然连接只考虑在两个表的模式中都出现的那些属性上取值相同的元组对，而笛卡尔积将第一个表的每个元组与第二个表的每个元组进行串接。

### 1.2.2 如何得到 自然连接？
对于`Sales`表 和 `product`表，可通过如下sql获取自然连接：
```sql
select * from Sales natural join product;
```
执行结果如下：
```
| product_id | sale_id | year | quantity | price | product_name |
| ---------- | ------- | ---- | -------- | ----- | ------------ |
| 100        | 2       | 2009 | 12       | 5000  | Nokia        |
| 100        | 1       | 2008 | 10       | 5000  | Nokia        |
| 200        | 7       | 2011 | 15       | 9000  | Apple        |
```
可以看到的是

### 1.2.3 如果自然连接的两个表有多个属性相同，会发生什么？


## 连接条件
```sql
select * from Sales natural join product;

select * from Sales  join Product on Sales.product_id=Product.product_id;
```
执行结果如下：
```
| product_id | sale_id | year | quantity | price | product_name |
| ---------- | ------- | ---- | -------- | ----- | ------------ |
| 100        | 2       | 2009 | 12       | 5000  | Nokia        |
| 100        | 1       | 2008 | 10       | 5000  | Nokia        |
| 200        | 7       | 2011 | 15       | 9000  | Apple        |

| sale_id | product_id | year | quantity | price | product_id | product_name |
| ------- | ---------- | ---- | -------- | ----- | ---------- | ------------ |
| 2       | 100        | 2009 | 12       | 5000  | 100        | Nokia        |
| 1       | 100        | 2008 | 10       | 5000  | 100        | Nokia        |
| 7       | 200        | 2011 | 15       | 9000  | 200        | Apple        |
```
可以看到的是，`join on`比  `natural join`多了一个`product_id`属性，那是因为 `select *`将`Sales`表 和 `product`表的`product_id`属性都筛选了出来。

有几种join？

为什么基于 ANSI 标准的 SQL里面没有自然连接？

