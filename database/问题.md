[toc]





&emsp;
&emsp;
## 1、 数据库的三大范式
> ① 第一范式:  每个列都不可以再拆分。
> ② 第二范式:  非主键列完全依赖于主键，而不能是依赖于主键的一部分.。
> ③ 第三范式:  非主键列只依赖于主键，不依赖于其他非主键。
> 
在设计数据库结构的时候,要尽量遵守三范式,如果不遵守,必须有足够的理由，比如性能。事实上我们经常会 为了性能而妥协数据库的设计。


&emsp;
## 2、Mysql有哪些部分组成以及作用
### 2.1 MySQL 的基本架构示意图
下图是 MySQL 的基本架构示意图：
<div align="center"> <img src="./pic/questions/componentOfMysql.png"> </div>

### 2.2 Mysql有哪些部分组成以及作用
MySQL 可以分为 **Server层** 和 **存储引擎层** 两部分
(1) 其中server包括了如下**4个**部分：
> ① **连接器**: 管理连接, 权限验证.
> ② **分析器**: 词法分析, 语法分析.
> ③ **优化器**: 执行计划生成, 索引的选择.
> ④ **执行器**: 操作存储引擎, 返回执行结果.
> 
(2) 储存引擎：存储数据, 提供读写接口.
&emsp;&emsp; 存储引擎层负责数据的存储和提取。其架构模式是插件式的，MySQL支持 `InnoDB`、`MyISAM``、Memory` 等多个存储引擎。 目前最常见的存储引擎是 `InnoDB`


&emsp;
## 3、NULL
### 3.1 NULL 和 空值 是一样的吗？
&emsp;&emsp; null 和空值不一样，空值不占用空间，而null 占用空间，所以字段设置成 not null 之后仍然可以插入空值。
### 3.2 数据库字段为什么要求定义成NOT NULL ？
MySQL官网这样介绍:
> &emsp;&emsp; NULL columns require additional space in the row to record whether their values are NULL. For MyISAM tables, each NULL columntakes one bit extra, rounded up to the nearest byte.
> &emsp;&emsp; null值会占用更多的字节，且会在程序中造成很多与预期不符的情况.
> 
字段设置成 not null 的原因有以下几点：
(1) NULL 值会影响一些函数的计算，比如如 `count()`函数遇到 NULL 值，这条记录不会统计在内：
<div align="center"> <img src="./pic/questions/not_null.png"> </div>

(2) `=` 与 `!=` 失效
对于NULL值的列，是不能使用 " = " 表达式进行判断的，下面对name的查询是不成立的，必须使用is NULL:
<div align="center"> <img src="./pic/questions/not_null_2.png"> </div>
表中只有一条有名字的记录，此时查询名字 !=a 预期的结果应该是想查出来剩余的两条记录，会发现与预期结果不匹配:
<div align="center"> <img src="./pic/questions/not_null_3.png"> </div>

(3)  NULL与其他值运算结果为NULL
NULL和其他任何值进行运算结果都是NULL，包括表达式的值也是NULL。
user表第二条记录：
> age是NULL，所以+1之后还是NULL；
> name是NULL，进行concat运算之后结果还是NULL。
> 
<div align="center"> <img src="./pic/questions/not_null_4.png"> </div>

(4) 对`distinct`、`group by`、`order by`等排序结果的影响
对于d`istinct` 和 `group by`来说，所有的`NULL`值都会被视为相等；
对于`order by`来说升序`NULL`会排在最前；

### 3.3 若平时在插入数据时不能保证字段一定有值，应该怎么做？
(1) 通过设置默认值的形式，定义时使用DEFAULT ''或DEFAULT 0，来避免空字段的产生。
(2) 若一张表中，允许为空的列比较多，接近表全部列数的三分之一。而且，  这些列在大部分情况下，都是可有可无的。若数据库管理员遇到这种情况，可以考虑另外建立一张副表，以保存这些列。



&emsp;
## 4、ACID
### 4.1 ACID是什么？
&emsp;&emsp; ACID，是指数据库在写入或更新资料的过程中，为保证事务（transaction）是正确可靠的，所必须具备的四个特性：
> ① 原子性（atomicity，或称不可分割性）
> ② 一致性（consistency）
> ③ 隔离性（isolation，又称独立性）
> ④ 持久性（durability）。
> 
**① Atomicity（原子性）**：一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被恢复（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。
**② Consistency（一致性）**：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。
**③ Isolation（隔离性）**：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。
**④ Durability（持久性）**：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。

### 4.2 若无法保证ACID会造成什么后果？
我们以从A账户转账50元到B账户为例进行说明一下
**(1) 如果无法保证原子性会怎么样？**
> 这样就会出现账目不一致的情形，A账户减去50元成功，而B账户增加50元操作失败。系统将无故丢失50元
> 
**(2) 如果无法保证一致性会怎么样？**
&emsp;&emsp; 首先，根据定义，一致性是指事务执行前后，数据处于一种合法的状态，这种状态是语义上的而不是语法上的。 那什么是合法的数据状态呢？ oK，这个状态是满足预定的约束就叫做合法的状态，再通俗一点，这状态是由你自己来定义的。满足这个状态，数据就是一致的，不满足这个状态，数据就是不一致的！
> &emsp;&emsp; 例一:A账户有200元，转账300元出去，此时A账户余额变成了-100元。你自然就发现了此时数据是不一致的，为什么呢？因为你定义了一个状态：账户余额这列必须大于0。
> &emsp;&emsp; 例二:A账户200元，转账50元给B账户，A账户的钱扣了，但是B账户因为各种意外，余额并没有增加。你也知道此时数据是不一致的，为什么呢？因为你定义了一个状态，要求A+B的余额必须不变。
> 
**(3) 如果无法保证隔离性会怎么样？**
&emsp;&emsp; 根据定义，隔离性是指多个事务并发执行的时候，事务内部的操作与其他事务是隔离的，并发执行的各个事务之间不能互相干扰。
> &emsp;&emsp; 假设A账户有200元，B账户0元。A账户往B账户转账两次，金额为50元，分别在两个事务中执行。如果无法保证隔离性，会出现下面的情形：
>
<div align="center"> <img src="./pic/questions/ACID_1.jpg"> </div>
如图所示，如果不保证隔离性，A扣款两次，而B只加款一次，凭空消失了50元，依然出现了数据不一致的情形！

**(4) 如果无法保证持久性会怎么样？**
&emsp;&emsp; 在Mysql中，为了解决CPU和磁盘速度不一致问题，Mysql是将磁盘上的数据加载到内存，对内存进行操作，然后再回写磁盘。好，假设此时宕机了，在内存中修改的数据全部丢失了，持久性就无法保证。
&emsp;&emsp; 设想一下，系统提示你转账成功。但是你发现金额没有发生任何改变，此时数据出现了不合法的数据状态，我们将这种状态认为是数据不一致的情形。

### 4.3 MySQL是如何保证ACID的？
**（1）Mysql怎么保证原子性的？**
&emsp;&emsp; MySQL是利用`undo log`来保证原子性。 `undo log`名为回滚日志，是实现原子性的关键，当事务回滚时能够撤销所有已经成功执行的sql语句，他需要记录你要回滚的相应日志信息。 例如
> ① 当你`delete`一条数据的时候，就需要记录这条数据的信息，回滚的时候，`insert`这条旧数据
> ② 当你`update`一条数据的时候，就需要记录之前的旧值，回滚的时候，根据旧值执行`update`操作
> ③ 当年`insert`一条数据的时候，就需要这条记录的主键，回滚的时候，根据主键执行`delete`操作
> 
`undo log`记录了这些回滚需要的信息，当事务执行失败或调用了`rollback`，导致事务需要回滚，便可以利用`undo log`中的信息将数据回滚到修改之前的样子。

**（2）Mysql怎么保证一致性的？**
这个问题得分为两个层面来说。 
① 从数据库层面来说：
> &emsp;&emsp; 数据库通过原子性、隔离性、持久性来保证一致性。也就是说ACID四大特性之中，C(一致性)是目的，A(原子性)、I(隔离性)、D(持久性)是手段，是为了保证一致性，数据库提供的手段。数据库必须要实现AID三大特性，才有可能实现一致性。例如，原子性无法保证，显然一致性也无法保证。
> &emsp;&emsp; 但是，如果你在事务里故意写出违反约束的代码，一致性还是无法保证的。例如，你在转账的例子中，你的代码里故意不给B账户加钱，那一致性还是无法保证。因此，还必须从应用层角度考虑。
> 
② 从应用层面来说：
> &emsp;&emsp; 通过代码判断数据库数据是否有效，然后决定回滚还是提交数据！
> 

**（3）Mysql怎么保证隔离性的？**
利用的是锁和MVCC机制。

**（4）Mysql怎么保证持久性的？**
&emsp;&emsp; MySQL是利用`redo log`日志来保证持久性的。 正如之前说的，Mysql是先把磁盘上的数据加载到内存中，在内存中对数据进行修改，再刷回磁盘上。如果此时突然宕机，内存中的数据就会丢失。 怎么解决这个问题呢？ 简单啊，事务提交前直接把数据写入磁盘就行啊。 这么做有什么问题？
> &emsp;&emsp; 只修改一个页面里的一个字节，就要将整个页面刷入磁盘，太浪费资源了。毕竟一个页面16kb大小，你只改其中一点点东西，就要将16kb的内容刷入磁盘，听着也不合理。
> &emsp;&emsp; 毕竟一个事务里的SQL可能牵涉到多个数据页的修改，而这些数据页可能不是相邻的，也就是属于随机IO。显然操作随机IO，速度会比较慢。
> 
于是，决定采用`redo log`解决上面的问题。当做数据修改的时候，不仅在内存中操作，还会在`redo log`中记录这次操作。当事务提交的时候，会将`redo log`日志进行刷盘(`redo log`一部分在内存中，一部分在磁盘上)。当数据库宕机重启的时候，会将`redo log`中的内容恢复到数据库中，再根据`undo log`和`binlog`（归档日志）内容决定回滚数据还是提交数据。
**采用`redo log`有何好处？**
其实好处就是将`redo log`进行刷盘比对数据页刷盘效率高，具体表现如下
> `redo log`体积小，毕竟只记录了哪一页修改了啥，因此体积小，刷盘快。
> `redo log`是一直往末尾进行追加，属于顺序`IO`。效率显然比随机`IO`来的快。
> 


&emsp;
## 5、同时有多个事务正在进行提交，会发生什么？
事务（transaction）是作为一个单元的一组有序的数据库操作。如果组中的所有操作都成功， 则认为 事务成功， 即使只有一个操作失败， 事务也不成功。如果所有操作完成， 事务则提交， 其修改将作用 于所有其他数据库进程。如果一个操作失败， 则事务将回滚， 该事务所有操作的影响都将取消。

事务特性
原子性即不可分割性， 事务要么全部被执行， 要么就全部不被执行。

一致性或可串性事务的执行使得数据库从一种正确状态转换成另一种正确状 态

隔离性在事务正确提交之前，不允许把该事务对数据的任何改变提供给任何 其他事务，

持久性事务正确提交后， 其结果将永久保存在数据库中， 即使在事务提交后有了其他故障， 事务 的处理结果也会得到保存。或者这样理解：事务就是被绑定在一起作为一个逻辑工作单元的 SQL 语句分 组， 如果任何一个语句操作失败那么整个操作就被失败， 以后操作就会回滚到操作前状态， 或者是上 有个节点。为了确保要么执行， 要么不执行， 就可以使用事务。要将有组语句作为事务考虑， 就需要 通过 ACID 测试， 即原子性， 一致性， 隔离性和持久性。


&emsp;
## 6、Mysql索引分哪些？
从数据结构角度
1、B+树索引(O(log(n)))：关于B+树索引，

2、hash索引： a 仅仅能满足"=","IN"和"<=>"查询，不能使用范围查询 b 其检索效率非常高，索引的检索可以一次定位，不像B-Tree 索引需要从根节点到枝节点，最后才能访问到页节点这样多次的IO访问，所以 Hash 索引的查询效率要远高于 B-Tree 索引 c 只有Memory存储引擎显示支持hash索引

3、FULLTEXT索引（现在MyISAM和InnoDB引擎都支持了）

4、R-Tree索引（用于对GIS数据类型创建SPATIAL索引）

从物理存储角度
1、聚集索引（clustered index）

2、非聚集索引（non-clustered index）

聚集索引和非聚集索引的区别如下：

聚集索引和非聚集索引的根本区别是表记录的排列顺序和与索引的排列顺序是否一致，聚集索引表记录的排列顺序与索引的排列顺序一致，优点是查询速度快，因为一旦 具有第一个索引值的纪录被找到，具有连续索引值的记录也一定物理的紧跟其后。

聚集索引的缺点是对表进行修改速度较慢，这是为了保持表中的记录的物理顺序与索 引的顺序一致，而把记录插入到数据页的相应位置，必须在数据页中进行数据重排， 降低了执行速度。非聚集索引指定了表中记录的逻辑顺序，但记录的物理顺序和索引的顺序不一致，聚集索引和非聚集索引都采用了B+树的结构，但非聚集索引的叶子层并不与实际的

从逻辑角度
1、主键索引：主键索引是一种特殊的唯一索引，不允许有空值

2、普通索引或者单列索引

3、多列索引（复合索引）：复合索引指多个字段上创建的索引，只有在查询条件中使用了创建索引时的第一个字段，索引才会被使用。使用复合索引时遵循最左前缀集合

4、唯一索引或者非唯一索引

5、空间索引：空间索引是对空间数据类型的字段建立的索引，MYSQL中的空间数据类型有4种，分别是GEOMETRY、POINT、LINESTRING、POLYGON。MYSQL使用SPATIAL关键字进行扩展，使得能够用于创建正规索引类型的语法创建空间索引。创建空间索引的列，必须将其声明为NOT NULL，空间索引只能在存储引擎为MYISAM的表中创建

CREATE TABLE table_name[col_name data type]  [unique|fulltext|spatial][index|key][index_name](col_name[length])[asc|desc]
1、unique|fulltext|spatial为可选参数，分别表示唯一索引、全文索引和空间索引；

2、index和key为同义词，两者作用相同，用来指定创建索引

3、col_name为需要创建索引的字段列，该列必须从数据表中该定义的多个列中选择；

4、index_name指定索引的名称，为可选参数，如果不指定，MYSQL默认col_name为索引值；

5、length为可选参数，表示索引的长度，只有字符串类型的字段才能指定索引长度；

6、asc或desc指定升序或降序的索引值存储


&emsp;
## 7、建立了主键索引还可以建立唯一索引吗？
一、主键与索引的区别如下：
主键是一种约束，唯一索引是一种索引，两者在本质上是不同的。

主键创建后一定包含一个唯一性索引，唯一性索引并不一定就是主键。

唯一性索引列允许空值，而主键列不允许为空值。

主键列在创建时，已经默认不为空值 + 唯一索引了。

主键可以被其他表引用为外键，而唯一索引不能。

一个表最多只能创建一个主键，但可以创建多个唯一索引。

主键更适合那些不容易更改的唯一标识，如自动递增列、身份证号等。

二、回答
主键是一种约束，目的是对这个表的某一列进行限制； 唯一索引是一种索引，索引是数据库表的一个冗余结构，目的是为了更好的查询； 主键列不允许为空值，而唯一性索引列允许空值； 一个表最多只能一个主键，但是可以包含多个唯一索引；

1、一个表中可以有多个唯一索引，但是只能有一个主键。

2、主键一定是唯一性索引，唯一性索引并不一定就是主键

主键不允许为空，唯一键允许为空，空值不受唯一约束，也就是说可以有多个空值。

注：可以多列组合成一个唯一索引或者一个主键，即组合索引或组合主键


&emsp;
## 8、建立索引常用的知识和规则如下：
1、表的主键、外键必须有索引； 2、数据量超过300的表应该有索引； 3、经常与其他表进行连接的表，在连接字段上应该建立索引； 4、经常出现在Where子句中的字段，特别是大表的字段，应该建立索引； 5、索引应该建在选择性高的字段上； 6、索引应该建在小字段上，对于大的文本字段甚至超长字段，不要建索引； 7、复合索引的建立需要进行仔细分析；尽量考虑用单字段索引代替： 8、频繁进行数据操作的表，不要建立太多的索引； 9、删除无用的索引，避免对执行计划造成负面影响；